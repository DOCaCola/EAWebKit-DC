// Generated by opcode_generator.rb from C:/Webkit2016/WebKit/Source/JavaScriptCore/b3/air/AirOpcode.opcodes -- do not edit!
#ifndef AirOpcodeGenerated_h
#define AirOpcodeGenerated_h
#include "AirInstInlines.h"
#include "wtf/PrintStream.h"
namespace WTF {
using namespace JSC::B3::Air;
void printInternal(PrintStream& out, Opcode opcode)
{
    switch (opcode) {
    case Nop:
        out.print("Nop");
        return;
    case Add32:
        out.print("Add32");
        return;
    case Add64:
        out.print("Add64");
        return;
    case AddDouble:
        out.print("AddDouble");
        return;
    case AddFloat:
        out.print("AddFloat");
        return;
    case Sub32:
        out.print("Sub32");
        return;
    case Sub64:
        out.print("Sub64");
        return;
    case SubDouble:
        out.print("SubDouble");
        return;
    case SubFloat:
        out.print("SubFloat");
        return;
    case Neg32:
        out.print("Neg32");
        return;
    case Neg64:
        out.print("Neg64");
        return;
    case Mul32:
        out.print("Mul32");
        return;
    case Mul64:
        out.print("Mul64");
        return;
    case MulDouble:
        out.print("MulDouble");
        return;
    case MulFloat:
        out.print("MulFloat");
        return;
    case DivDouble:
        out.print("DivDouble");
        return;
    case DivFloat:
        out.print("DivFloat");
        return;
    case X86ConvertToDoubleWord32:
        out.print("X86ConvertToDoubleWord32");
        return;
    case X86ConvertToQuadWord64:
        out.print("X86ConvertToQuadWord64");
        return;
    case X86Div32:
        out.print("X86Div32");
        return;
    case X86Div64:
        out.print("X86Div64");
        return;
    case Lea:
        out.print("Lea");
        return;
    case And32:
        out.print("And32");
        return;
    case And64:
        out.print("And64");
        return;
    case AndDouble:
        out.print("AndDouble");
        return;
    case AndFloat:
        out.print("AndFloat");
        return;
    case Lshift32:
        out.print("Lshift32");
        return;
    case Lshift64:
        out.print("Lshift64");
        return;
    case Rshift32:
        out.print("Rshift32");
        return;
    case Rshift64:
        out.print("Rshift64");
        return;
    case urshift32:
        out.print("urshift32");
        return;
    case Urshift32:
        out.print("Urshift32");
        return;
    case Urshift64:
        out.print("Urshift64");
        return;
    case Or32:
        out.print("Or32");
        return;
    case Or64:
        out.print("Or64");
        return;
    case Xor32:
        out.print("Xor32");
        return;
    case Xor64:
        out.print("Xor64");
        return;
    case Not32:
        out.print("Not32");
        return;
    case Not64:
        out.print("Not64");
        return;
    case CeilDouble:
        out.print("CeilDouble");
        return;
    case CeilFloat:
        out.print("CeilFloat");
        return;
    case SqrtDouble:
        out.print("SqrtDouble");
        return;
    case SqrtFloat:
        out.print("SqrtFloat");
        return;
    case ConvertInt32ToDouble:
        out.print("ConvertInt32ToDouble");
        return;
    case ConvertInt64ToDouble:
        out.print("ConvertInt64ToDouble");
        return;
    case CountLeadingZeros32:
        out.print("CountLeadingZeros32");
        return;
    case CountLeadingZeros64:
        out.print("CountLeadingZeros64");
        return;
    case ConvertDoubleToFloat:
        out.print("ConvertDoubleToFloat");
        return;
    case ConvertFloatToDouble:
        out.print("ConvertFloatToDouble");
        return;
    case Move:
        out.print("Move");
        return;
    case Move32:
        out.print("Move32");
        return;
    case SignExtend32ToPtr:
        out.print("SignExtend32ToPtr");
        return;
    case ZeroExtend8To32:
        out.print("ZeroExtend8To32");
        return;
    case SignExtend8To32:
        out.print("SignExtend8To32");
        return;
    case ZeroExtend16To32:
        out.print("ZeroExtend16To32");
        return;
    case SignExtend16To32:
        out.print("SignExtend16To32");
        return;
    case MoveFloat:
        out.print("MoveFloat");
        return;
    case MoveDouble:
        out.print("MoveDouble");
        return;
    case MoveZeroToDouble:
        out.print("MoveZeroToDouble");
        return;
    case Move64ToDouble:
        out.print("Move64ToDouble");
        return;
    case Move32ToFloat:
        out.print("Move32ToFloat");
        return;
    case MoveDoubleTo64:
        out.print("MoveDoubleTo64");
        return;
    case MoveFloatTo32:
        out.print("MoveFloatTo32");
        return;
    case Load8:
        out.print("Load8");
        return;
    case Store8:
        out.print("Store8");
        return;
    case Load8SignedExtendTo32:
        out.print("Load8SignedExtendTo32");
        return;
    case Load16:
        out.print("Load16");
        return;
    case Load16SignedExtendTo32:
        out.print("Load16SignedExtendTo32");
        return;
    case Store16:
        out.print("Store16");
        return;
    case Compare32:
        out.print("Compare32");
        return;
    case Compare64:
        out.print("Compare64");
        return;
    case Test32:
        out.print("Test32");
        return;
    case Test64:
        out.print("Test64");
        return;
    case CompareDouble:
        out.print("CompareDouble");
        return;
    case CompareFloat:
        out.print("CompareFloat");
        return;
    case Branch8:
        out.print("Branch8");
        return;
    case Branch32:
        out.print("Branch32");
        return;
    case Branch64:
        out.print("Branch64");
        return;
    case BranchTest8:
        out.print("BranchTest8");
        return;
    case BranchTest32:
        out.print("BranchTest32");
        return;
    case BranchTest64:
        out.print("BranchTest64");
        return;
    case BranchDouble:
        out.print("BranchDouble");
        return;
    case BranchFloat:
        out.print("BranchFloat");
        return;
    case BranchAdd32:
        out.print("BranchAdd32");
        return;
    case BranchAdd64:
        out.print("BranchAdd64");
        return;
    case BranchMul32:
        out.print("BranchMul32");
        return;
    case BranchMul64:
        out.print("BranchMul64");
        return;
    case BranchSub32:
        out.print("BranchSub32");
        return;
    case BranchSub64:
        out.print("BranchSub64");
        return;
    case BranchNeg32:
        out.print("BranchNeg32");
        return;
    case BranchNeg64:
        out.print("BranchNeg64");
        return;
    case MoveConditionally32:
        out.print("MoveConditionally32");
        return;
    case MoveConditionally64:
        out.print("MoveConditionally64");
        return;
    case MoveConditionallyTest32:
        out.print("MoveConditionallyTest32");
        return;
    case MoveConditionallyTest64:
        out.print("MoveConditionallyTest64");
        return;
    case MoveConditionallyDouble:
        out.print("MoveConditionallyDouble");
        return;
    case MoveConditionallyFloat:
        out.print("MoveConditionallyFloat");
        return;
    case MoveDoubleConditionally32:
        out.print("MoveDoubleConditionally32");
        return;
    case MoveDoubleConditionally64:
        out.print("MoveDoubleConditionally64");
        return;
    case MoveDoubleConditionallyTest32:
        out.print("MoveDoubleConditionallyTest32");
        return;
    case MoveDoubleConditionallyTest64:
        out.print("MoveDoubleConditionallyTest64");
        return;
    case MoveDoubleConditionallyDouble:
        out.print("MoveDoubleConditionallyDouble");
        return;
    case MoveDoubleConditionallyFloat:
        out.print("MoveDoubleConditionallyFloat");
        return;
    case Jump:
        out.print("Jump");
        return;
    case Ret:
        out.print("Ret");
        return;
    case Oops:
        out.print("Oops");
        return;
    case Patch:
        out.print("Patch");
        return;
    }
    RELEASE_ASSERT_NOT_REACHED();
}
} // namespace WTF
namespace JSC { namespace B3 { namespace Air {
bool Inst::isValidForm()
{
switch (this->opcode) {
case Nop:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Add32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Add64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case AddDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case AddFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Sub32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Sub64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SubDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SubFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Neg32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Neg64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Mul32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Mul64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MulDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MulFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case DivDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case DivFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case X86ConvertToDoubleWord32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86ConvertToDoubleWord32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case X86ConvertToQuadWord64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86ConvertToQuadWord64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case X86Div32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86Div32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case X86Div64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86Div64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Lea:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case And32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case And64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case AndDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case AndFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Lshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isLshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Lshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isLshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Rshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Rshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case urshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Urshift32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isUrshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Urshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isUrshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Or32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Or64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Xor32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Xor64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Not32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Not64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case CeilDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case CeilFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SqrtDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SqrtFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ConvertInt32ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ConvertInt64ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case CountLeadingZeros32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case CountLeadingZeros64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ConvertDoubleToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ConvertFloatToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Move:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::pointerWidth()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::Imm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::pointerWidth()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Move32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SignExtend32ToPtr:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ZeroExtend8To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SignExtend8To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ZeroExtend16To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SignExtend16To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveZeroToDouble:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Move64ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Move32ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleTo64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveFloatTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Load8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Store8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Load8SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Load16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Load16SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Store16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Compare32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Compare64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Test32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Test64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case CompareDouble:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case CompareFloat:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Branch8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width8))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Branch32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Imm:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Branch64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchTest8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width8))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchTest32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Imm:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchTest64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchAdd32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchAdd64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchMul32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchMul64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchSub32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchSub64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchNeg32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchNeg64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionally32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionally64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionallyTest32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionallyTest64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionallyDouble:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionallyFloat:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleConditionally32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleConditionally64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleConditionallyTest32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleConditionallyTest64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleConditionallyDouble:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleConditionallyFloat:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Jump:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Ret:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Oops:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Patch:
if (args.size() < 1)
return false;
if (!args[0].isSpecial())
return false;
OPGEN_RETURN(args[0].special()->isValid(*this));
break;
default:
break;
}
return false;
}
bool Inst::admitsStack(unsigned argIndex)
{
switch (opcode) {
case Nop:
switch (argIndex) {
default:
break;
}
break;
case Add32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Add64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case AddDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case AddFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Sub32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case Sub64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case SubDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case SubFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Neg32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Neg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Mul32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Mul64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MulDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MulFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case DivDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case DivFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case X86ConvertToDoubleWord32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case X86ConvertToQuadWord64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case X86Div32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case X86Div64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Lea:
switch (argIndex) {
case 0:
OPGEN_RETURN(true);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case And32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case And64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case AndDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case AndFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Lshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Lshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Rshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Rshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case urshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Urshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Urshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Or32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case Or64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Xor32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case Xor64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case Not32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 1:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Not64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 1:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case CeilDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case CeilFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case SqrtDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case SqrtFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ConvertInt32ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ConvertInt64ToDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case CountLeadingZeros32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case CountLeadingZeros64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ConvertDoubleToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ConvertFloatToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Move:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
#if USE(JSVALUE64)
case Arg::Imm64:
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::Imm64:
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Move32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::Imm:
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SignExtend32ToPtr:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ZeroExtend8To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case SignExtend8To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ZeroExtend16To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case SignExtend16To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveZeroToDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Move64ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Move32ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleTo64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveFloatTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Load8:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Store8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Load8SignedExtendTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Load16:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Load16SignedExtendTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Store16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Compare32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Compare64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Test32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Test64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case CompareDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case CompareFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Branch8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Branch32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Branch64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchTest8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchMul32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchMul64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchSub32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchSub64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchNeg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchNeg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveConditionally32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveConditionally64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveConditionallyTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveConditionallyTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveConditionallyDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveConditionallyFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleConditionally32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleConditionally64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleConditionallyTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleConditionallyTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleConditionallyDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleConditionallyFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Jump:
switch (argIndex) {
default:
break;
}
break;
case Ret:
switch (argIndex) {
default:
break;
}
break;
case Oops:
switch (argIndex) {
default:
break;
}
break;
case Patch:
if (!argIndex)
return false;
OPGEN_RETURN(args[0].special()->admitsStack(*this, argIndex));
break;
default:
break;
}
return false;
}
bool Inst::hasNonArgNonControlEffects()
{
switch (opcode) {
case Patch:
return args[0].special()->hasNonArgNonControlEffects();
default:
return false;
}
}
bool Inst::hasNonArgEffects()
{
switch (opcode) {
case Branch8:
case Branch32:
case Branch64:
case BranchTest8:
case BranchTest32:
case BranchTest64:
case BranchDouble:
case BranchFloat:
case BranchAdd32:
case BranchAdd64:
case BranchMul32:
case BranchMul64:
case BranchSub32:
case BranchSub64:
case BranchNeg32:
case BranchNeg64:
case Jump:
case Ret:
case Oops:
return true;
case Patch:
return args[0].special()->hasNonArgNonControlEffects();
default:
return false;
}
}
CCallHelpers::Jump Inst::generate(CCallHelpers& jit, GenerationContext& context)
{
UNUSED_PARAM(jit);
UNUSED_PARAM(context);
CCallHelpers::Jump result;
switch (this->opcode) {
case Nop:
jit.nop();
OPGEN_RETURN(result);
break;
break;
case Add32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.add32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
jit.add32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
jit.add32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Tmp:
jit.add32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Add64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.add64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.add64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.add64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case AddDouble:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.addDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case AddFloat:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.addFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Sub32:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.sub32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
jit.sub32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Sub64:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.sub64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.sub64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.sub64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.sub64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.sub64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case SubDouble:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.subDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case SubFloat:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.subFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Neg32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.neg32(args[0].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.neg32(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Neg64:
#if CPU(X86_64) || CPU(ARM64)
jit.neg64(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Mul32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.mul32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
jit.mul32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Mul64:
#if CPU(X86_64) || CPU(ARM64)
jit.mul64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case MulDouble:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.mulDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case MulFloat:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.mulFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case DivDouble:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.divDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.divDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.divDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case DivFloat:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.divFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.divFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.divFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case X86ConvertToDoubleWord32:
#if CPU(X86) || CPU(X86_64)
jit.x86ConvertToDoubleWord32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case X86ConvertToQuadWord64:
#if CPU(X86_64)
jit.x86ConvertToQuadWord64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case X86Div32:
#if CPU(X86) || CPU(X86_64)
jit.x86Div32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case X86Div64:
#if CPU(X86_64)
jit.x86Div64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Lea:
#if CPU(X86) || CPU(X86_64)
jit.lea(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case And32:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.and32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.and32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case And64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.and64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.and64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case AndDouble:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.andDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.andDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case AndFloat:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.andFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.andFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Lshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.lshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.lshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.lshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.lshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Lshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.lshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.lshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.lshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.lshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Rshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.rshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.rshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.rshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.rshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Rshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.rshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.rshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.rshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.rshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case urshift32:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.urshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.urshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Urshift32:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.urshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.urshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Urshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.urshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.urshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.urshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.urshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Or32:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.or32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.or32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Or64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.or64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.or64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Xor32:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.xor32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.xor32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Xor64:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.xor64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.xor64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.xor64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Not32:
switch (this->args.size()) {
case 2:
#if CPU(ARM64)
jit.not32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.not32(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.not32(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Not64:
switch (this->args.size()) {
case 2:
#if CPU(ARM64)
jit.not64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.not64(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.not64(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case CeilDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.ceilDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.ceilDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case CeilFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.ceilFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.ceilFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case SqrtDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.sqrtDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sqrtDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case SqrtFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.sqrtFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sqrtFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case ConvertInt32ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertInt32ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertInt32ToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case ConvertInt64ToDouble:
#if CPU(X86_64) || CPU(ARM64)
jit.convertInt64ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case CountLeadingZeros32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.countLeadingZeros32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.countLeadingZeros32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case CountLeadingZeros64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.countLeadingZeros64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.countLeadingZeros64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case ConvertDoubleToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertDoubleToFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertDoubleToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case ConvertFloatToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertFloatToDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertFloatToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Move:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.move(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storePtr(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.storePtr(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.signExtend32ToPtr(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storePtr(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::Imm64:
jit.move(args[0].asTrustedImm64(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.loadPtr(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.loadPtr(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Move32:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.zeroExtend32ToPtr(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.store32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.store32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.load32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.store32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.store32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case SignExtend32ToPtr:
jit.signExtend32ToPtr(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case ZeroExtend8To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.zeroExtend8To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.load8(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case SignExtend8To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.signExtend8To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.load8SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case ZeroExtend16To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.zeroExtend16To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.load16(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case SignExtend16To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.signExtend16To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.load16SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case MoveFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.moveDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storeFloat(args[0].fpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.storeFloat(args[0].fpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.loadFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.loadFloat(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case MoveDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.moveDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storeDouble(args[0].fpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.storeDouble(args[0].fpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.loadDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.loadDouble(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case MoveZeroToDouble:
jit.moveZeroToDouble(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Move64ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.move64ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.loadDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
jit.loadDouble(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Move32ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.move32ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.loadFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.loadFloat(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case MoveDoubleTo64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleTo64(args[0].fpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.load64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
jit.load64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case MoveFloatTo32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.moveFloatTo32(args[0].fpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.load32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Load8:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.load8(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Store8:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
jit.store8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.store8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.store8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.store8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Load8SignedExtendTo32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.load8SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Load16:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.load16(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Load16SignedExtendTo32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.load16SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Store16:
switch (this->args[1].kind()) {
case Arg::Index:
jit.store16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Compare32:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.compare32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
jit.compare32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Compare64:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.compare64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.compare64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Test32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.test32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
jit.test32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Test64:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.test64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.test64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case CompareDouble:
jit.compareDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case CompareFloat:
jit.compareFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Branch8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branch8(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branch8(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Branch32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Branch64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchTest8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest8(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest8(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchTest32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
result = jit.branchTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest32(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchTest64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchDouble:
result = jit.branchDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case BranchFloat:
result = jit.branchFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case BranchAdd32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchAdd64:
switch (this->args[1].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchMul32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 4:
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case BranchMul64:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchMul64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case BranchSub32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchSub32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchSub32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchSub32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchSub32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchSub32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchSub64:
switch (this->args[1].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchSub64(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchSub64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchNeg32:
result = jit.branchNeg32(args[0].asResultCondition(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case BranchNeg64:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchNeg64(args[0].asResultCondition(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case MoveConditionally32:
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
case MoveConditionally64:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case MoveConditionallyTest32:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case MoveConditionallyTest64:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case MoveConditionallyDouble:
jit.moveConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
case MoveConditionallyFloat:
jit.moveConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
case MoveDoubleConditionally32:
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
break;
break;
case MoveDoubleConditionally64:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case MoveDoubleConditionallyTest32:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case MoveDoubleConditionallyTest64:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case MoveDoubleConditionallyDouble:
jit.moveDoubleConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
break;
break;
case MoveDoubleConditionallyFloat:
jit.moveDoubleConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
break;
break;
case Jump:
result = jit.jump();
OPGEN_RETURN(result);
break;
break;
case Ret:
jit.ret();
OPGEN_RETURN(result);
break;
break;
case Oops:
jit.oops();
OPGEN_RETURN(result);
break;
break;
case Patch:
OPGEN_RETURN(args[0].special()->generate(*this, jit, context));
break;
default:
break;
}
RELEASE_ASSERT_NOT_REACHED();
return result;
}
} } } // namespace JSC::B3::Air
#endif // AirOpcodeGenerated_h
