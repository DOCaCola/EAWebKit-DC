/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(VIDEO)

#include "JSHTMLMediaElement.h"

#include "EventNames.h"
#include "HTMLMediaElementMediaSession.h"
#include "HTMLMediaElementMediaStream.h"
#include "HTMLNames.h"
#include "JSDOMBinding.h"
#include "JSDOMConstructor.h"
#include "JSDOMConvert.h"
#include "JSDOMPromise.h"
#include "JSEventListener.h"
#include "JSMediaController.h"
#include "JSMediaError.h"
#include "JSTextTrack.h"
#include "JSTimeRanges.h"
#include "JSVideoPlaybackQuality.h"
#include "RuntimeEnabledFeatures.h"
#include <runtime/Error.h>
#include <wtf/GetPtr.h>

#if ENABLE(ENCRYPTED_MEDIA)
#include "JSMediaKeys.h"
#endif

#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
#include "JSWebKitMediaKeys.h"
#endif

#if ENABLE(MEDIA_SESSION) && ENABLE(VIDEO)
#include "JSMediaSession.h"
#endif

#if ENABLE(MEDIA_STREAM) && ENABLE(VIDEO)
#include "JSMediaStream.h"
#endif

#if ENABLE(VIDEO_TRACK)
#include "JSAudioTrackList.h"
#include "JSTextTrackList.h"
#include "JSVideoTrackList.h"
#endif

using namespace JSC;

namespace WebCore {

// Functions

JSC::EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionLoad(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionCanPlayType(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionGetStartDate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionPlay(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionPause(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionFastSeek(JSC::ExecState*);
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
JSC::EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionWebkitSetMediaKeys(JSC::ExecState*);
#endif
#if ENABLE(ENCRYPTED_MEDIA)
JSC::EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionSetMediaKeys(JSC::ExecState*);
#endif
#if ENABLE(VIDEO_TRACK)
JSC::EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionAddTextTrack(JSC::ExecState*);
#endif
#if ENABLE(MEDIA_SOURCE)
JSC::EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionGetVideoPlaybackQuality(JSC::ExecState*);
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
JSC::EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionWebkitShowPlaybackTargetPicker(JSC::ExecState*);
#endif

// Attributes

JSC::EncodedJSValue jsHTMLMediaElementError(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsHTMLMediaElementSrc(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementSrc(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementCurrentSrc(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsHTMLMediaElementCrossOrigin(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementCrossOrigin(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementNetworkState(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsHTMLMediaElementPreload(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementPreload(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementBuffered(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsHTMLMediaElementReadyState(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsHTMLMediaElementSeeking(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsHTMLMediaElementCurrentTime(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementCurrentTime(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementDuration(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsHTMLMediaElementPaused(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsHTMLMediaElementDefaultPlaybackRate(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementDefaultPlaybackRate(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementPlaybackRate(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementPlaybackRate(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementPlayed(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsHTMLMediaElementSeekable(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsHTMLMediaElementEnded(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsHTMLMediaElementAutoplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementAutoplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementLoop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementLoop(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementControls(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementControls(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementVolume(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementVolume(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementMuted(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementMuted(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementDefaultMuted(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementDefaultMuted(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementWebkitPreservesPitch(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementWebkitPreservesPitch(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementWebkitHasClosedCaptions(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsHTMLMediaElementWebkitClosedCaptionsVisible(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementWebkitClosedCaptionsVisible(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#if ENABLE(MEDIA_STATISTICS)
JSC::EncodedJSValue jsHTMLMediaElementWebkitAudioDecodedByteCount(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
#endif
#if ENABLE(MEDIA_STATISTICS)
JSC::EncodedJSValue jsHTMLMediaElementWebkitVideoDecodedByteCount(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
JSC::EncodedJSValue jsHTMLMediaElementWebkitKeys(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
#endif
#if ENABLE(ENCRYPTED_MEDIA)
JSC::EncodedJSValue jsHTMLMediaElementMediaKeys(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
#endif
#if ENABLE(ENCRYPTED_MEDIA)
JSC::EncodedJSValue jsHTMLMediaElementOnencrypted(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementOnencrypted(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(ENCRYPTED_MEDIA)
JSC::EncodedJSValue jsHTMLMediaElementOnwaitingforkey(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementOnwaitingforkey(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(VIDEO_TRACK)
JSC::EncodedJSValue jsHTMLMediaElementAudioTracks(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
#endif
#if ENABLE(VIDEO_TRACK)
JSC::EncodedJSValue jsHTMLMediaElementTextTracks(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
#endif
#if ENABLE(VIDEO_TRACK)
JSC::EncodedJSValue jsHTMLMediaElementVideoTracks(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
#endif
JSC::EncodedJSValue jsHTMLMediaElementMediaGroup(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementMediaGroup(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsHTMLMediaElementController(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementController(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
JSC::EncodedJSValue jsHTMLMediaElementWebkitCurrentPlaybackTargetIsWireless(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
#endif
#if ENABLE(MEDIA_SESSION) && ENABLE(VIDEO)
JSC::EncodedJSValue jsHTMLMediaElementKind(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementKind(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(MEDIA_SESSION) && ENABLE(VIDEO)
JSC::EncodedJSValue jsHTMLMediaElementSession(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementSession(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(MEDIA_STREAM) && ENABLE(VIDEO)
JSC::EncodedJSValue jsHTMLMediaElementSrcObject(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementSrcObject(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
JSC::EncodedJSValue jsHTMLMediaElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSHTMLMediaElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);

class JSHTMLMediaElementPrototype : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;
    static JSHTMLMediaElementPrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSHTMLMediaElementPrototype* ptr = new (NotNull, JSC::allocateCell<JSHTMLMediaElementPrototype>(vm.heap)) JSHTMLMediaElementPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSHTMLMediaElementPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};

using JSHTMLMediaElementConstructor = JSDOMConstructorNotConstructable<JSHTMLMediaElement>;

/* Hash table for constructor */

static const HashTableValue JSHTMLMediaElementConstructorTableValues[] =
{
    { "NETWORK_EMPTY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0) } },
    { "NETWORK_IDLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(1) } },
    { "NETWORK_LOADING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(2) } },
    { "NETWORK_NO_SOURCE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(3) } },
    { "HAVE_NOTHING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0) } },
    { "HAVE_METADATA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(1) } },
    { "HAVE_CURRENT_DATA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(2) } },
    { "HAVE_FUTURE_DATA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(3) } },
    { "HAVE_ENOUGH_DATA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(4) } },
};

static_assert(HTMLMediaElement::NETWORK_EMPTY == 0, "NETWORK_EMPTY in HTMLMediaElement does not match value from IDL");
static_assert(HTMLMediaElement::NETWORK_IDLE == 1, "NETWORK_IDLE in HTMLMediaElement does not match value from IDL");
static_assert(HTMLMediaElement::NETWORK_LOADING == 2, "NETWORK_LOADING in HTMLMediaElement does not match value from IDL");
static_assert(HTMLMediaElement::NETWORK_NO_SOURCE == 3, "NETWORK_NO_SOURCE in HTMLMediaElement does not match value from IDL");
static_assert(HTMLMediaElement::HAVE_NOTHING == 0, "HAVE_NOTHING in HTMLMediaElement does not match value from IDL");
static_assert(HTMLMediaElement::HAVE_METADATA == 1, "HAVE_METADATA in HTMLMediaElement does not match value from IDL");
static_assert(HTMLMediaElement::HAVE_CURRENT_DATA == 2, "HAVE_CURRENT_DATA in HTMLMediaElement does not match value from IDL");
static_assert(HTMLMediaElement::HAVE_FUTURE_DATA == 3, "HAVE_FUTURE_DATA in HTMLMediaElement does not match value from IDL");
static_assert(HTMLMediaElement::HAVE_ENOUGH_DATA == 4, "HAVE_ENOUGH_DATA in HTMLMediaElement does not match value from IDL");

template<> JSValue JSHTMLMediaElementConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    return JSHTMLElement::getConstructor(vm, &globalObject);
}

template<> void JSHTMLMediaElementConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    putDirect(vm, vm.propertyNames->prototype, JSHTMLMediaElement::prototype(vm, &globalObject), DontDelete | ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("HTMLMediaElement"))), ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
    reifyStaticProperties(vm, JSHTMLMediaElementConstructorTableValues, *this);
}

template<> const ClassInfo JSHTMLMediaElementConstructor::s_info = { "HTMLMediaElement", &Base::s_info, 0, CREATE_METHOD_TABLE(JSHTMLMediaElementConstructor) };

/* Hash table for prototype */

static const HashTableValue JSHTMLMediaElementPrototypeTableValues[] =
{
    { "constructor", DontEnum, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementConstructor) } },
    { "error", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementError), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "src", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementSrc), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementSrc) } },
    { "currentSrc", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementCurrentSrc), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "crossOrigin", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementCrossOrigin), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementCrossOrigin) } },
    { "networkState", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementNetworkState), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "preload", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementPreload), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementPreload) } },
    { "buffered", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementBuffered), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "readyState", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementReadyState), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "seeking", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementSeeking), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "currentTime", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementCurrentTime), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementCurrentTime) } },
    { "duration", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementDuration), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "paused", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementPaused), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "defaultPlaybackRate", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementDefaultPlaybackRate), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementDefaultPlaybackRate) } },
    { "playbackRate", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementPlaybackRate), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementPlaybackRate) } },
    { "played", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementPlayed), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "seekable", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementSeekable), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "ended", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementEnded), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "autoplay", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementAutoplay), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementAutoplay) } },
    { "loop", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementLoop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementLoop) } },
    { "controls", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementControls), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementControls) } },
    { "volume", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementVolume), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementVolume) } },
    { "muted", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementMuted), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementMuted) } },
    { "defaultMuted", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementDefaultMuted), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementDefaultMuted) } },
    { "webkitPreservesPitch", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementWebkitPreservesPitch), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementWebkitPreservesPitch) } },
    { "webkitHasClosedCaptions", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementWebkitHasClosedCaptions), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "webkitClosedCaptionsVisible", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementWebkitClosedCaptionsVisible), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementWebkitClosedCaptionsVisible) } },
#if ENABLE(MEDIA_STATISTICS)
    { "webkitAudioDecodedByteCount", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementWebkitAudioDecodedByteCount), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(MEDIA_STATISTICS)
    { "webkitVideoDecodedByteCount", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementWebkitVideoDecodedByteCount), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
    { "webkitKeys", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementWebkitKeys), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    { "mediaKeys", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementMediaKeys), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    { "onencrypted", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementOnencrypted), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementOnencrypted) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    { "onwaitingforkey", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementOnwaitingforkey), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementOnwaitingforkey) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(VIDEO_TRACK)
    { "audioTracks", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementAudioTracks), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(VIDEO_TRACK)
    { "textTracks", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementTextTracks), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(VIDEO_TRACK)
    { "videoTracks", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementVideoTracks), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "mediaGroup", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementMediaGroup), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementMediaGroup) } },
    { "controller", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementController), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementController) } },
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
    { "webkitCurrentPlaybackTargetIsWireless", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementWebkitCurrentPlaybackTargetIsWireless), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(MEDIA_SESSION) && ENABLE(VIDEO)
    { "kind", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementKind), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementKind) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(MEDIA_SESSION) && ENABLE(VIDEO)
    { "session", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementSession), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementSession) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(MEDIA_STREAM) && ENABLE(VIDEO)
    { "srcObject", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLMediaElementSrcObject), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLMediaElementSrcObject) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "load", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLMediaElementPrototypeFunctionLoad), (intptr_t) (0) } },
    { "canPlayType", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLMediaElementPrototypeFunctionCanPlayType), (intptr_t) (1) } },
    { "getStartDate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLMediaElementPrototypeFunctionGetStartDate), (intptr_t) (0) } },
    { "play", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLMediaElementPrototypeFunctionPlay), (intptr_t) (0) } },
    { "pause", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLMediaElementPrototypeFunctionPause), (intptr_t) (0) } },
    { "fastSeek", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLMediaElementPrototypeFunctionFastSeek), (intptr_t) (1) } },
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
    { "webkitSetMediaKeys", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLMediaElementPrototypeFunctionWebkitSetMediaKeys), (intptr_t) (1) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    { "setMediaKeys", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLMediaElementPrototypeFunctionSetMediaKeys), (intptr_t) (1) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(VIDEO_TRACK)
    { "addTextTrack", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLMediaElementPrototypeFunctionAddTextTrack), (intptr_t) (1) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(MEDIA_SOURCE)
    { "getVideoPlaybackQuality", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLMediaElementPrototypeFunctionGetVideoPlaybackQuality), (intptr_t) (0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
    { "webkitShowPlaybackTargetPicker", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLMediaElementPrototypeFunctionWebkitShowPlaybackTargetPicker), (intptr_t) (0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "NETWORK_EMPTY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0) } },
    { "NETWORK_IDLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(1) } },
    { "NETWORK_LOADING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(2) } },
    { "NETWORK_NO_SOURCE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(3) } },
    { "HAVE_NOTHING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0) } },
    { "HAVE_METADATA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(1) } },
    { "HAVE_CURRENT_DATA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(2) } },
    { "HAVE_FUTURE_DATA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(3) } },
    { "HAVE_ENOUGH_DATA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(4) } },
};

const ClassInfo JSHTMLMediaElementPrototype::s_info = { "HTMLMediaElementPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSHTMLMediaElementPrototype) };

void JSHTMLMediaElementPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSHTMLMediaElementPrototypeTableValues, *this);
#if ENABLE(ENCRYPTED_MEDIA)
    if (!RuntimeEnabledFeatures::sharedFeatures().encryptedMediaAPIEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("setMediaKeys"), strlen("setMediaKeys"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    if (!RuntimeEnabledFeatures::sharedFeatures().encryptedMediaAPIEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("mediaKeys"), strlen("mediaKeys"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    if (!RuntimeEnabledFeatures::sharedFeatures().encryptedMediaAPIEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("onencrypted"), strlen("onencrypted"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    if (!RuntimeEnabledFeatures::sharedFeatures().encryptedMediaAPIEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("onwaitingforkey"), strlen("onwaitingforkey"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
#endif
}

const ClassInfo JSHTMLMediaElement::s_info = { "HTMLMediaElement", &Base::s_info, 0, CREATE_METHOD_TABLE(JSHTMLMediaElement) };

JSHTMLMediaElement::JSHTMLMediaElement(Structure* structure, JSDOMGlobalObject& globalObject, Ref<HTMLMediaElement>&& impl)
    : JSHTMLElement(structure, globalObject, WTFMove(impl))
{
}

void JSHTMLMediaElement::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));

}

JSObject* JSHTMLMediaElement::createPrototype(VM& vm, JSGlobalObject* globalObject)
{
    return JSHTMLMediaElementPrototype::create(vm, globalObject, JSHTMLMediaElementPrototype::createStructure(vm, globalObject, JSHTMLElement::prototype(vm, globalObject)));
}

JSObject* JSHTMLMediaElement::prototype(VM& vm, JSGlobalObject* globalObject)
{
    return getDOMPrototype<JSHTMLMediaElement>(vm, globalObject);
}

template<> inline JSHTMLMediaElement* BindingCaller<JSHTMLMediaElement>::castForAttribute(ExecState&, EncodedJSValue thisValue)
{
    return jsDynamicDowncast<JSHTMLMediaElement*>(JSValue::decode(thisValue));
}

template<> inline JSHTMLMediaElement* BindingCaller<JSHTMLMediaElement>::castForOperation(ExecState& state)
{
    return jsDynamicDowncast<JSHTMLMediaElement*>(state.thisValue());
}

static inline JSValue jsHTMLMediaElementErrorGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementError(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementErrorGetter>(state, thisValue, "error");
}

static inline JSValue jsHTMLMediaElementErrorGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<MediaError>>(state, *thisObject.globalObject(), impl.error());
    return result;
}

static inline JSValue jsHTMLMediaElementSrcGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementSrc(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementSrcGetter>(state, thisValue, "src");
}

static inline JSValue jsHTMLMediaElementSrcGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUSVString>(state, impl.getURLAttribute(WebCore::HTMLNames::srcAttr));
    return result;
}

static inline JSValue jsHTMLMediaElementCurrentSrcGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementCurrentSrc(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementCurrentSrcGetter>(state, thisValue, "currentSrc");
}

static inline JSValue jsHTMLMediaElementCurrentSrcGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUSVString>(state, impl.currentSrc());
    return result;
}

static inline JSValue jsHTMLMediaElementCrossOriginGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementCrossOrigin(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementCrossOriginGetter>(state, thisValue, "crossOrigin");
}

static inline JSValue jsHTMLMediaElementCrossOriginGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLNullable<IDLDOMString>>(state, impl.crossOrigin());
    return result;
}

static inline JSValue jsHTMLMediaElementNetworkStateGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementNetworkState(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementNetworkStateGetter>(state, thisValue, "networkState");
}

static inline JSValue jsHTMLMediaElementNetworkStateGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnsignedShort>(impl.networkState());
    return result;
}

static inline JSValue jsHTMLMediaElementPreloadGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementPreload(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementPreloadGetter>(state, thisValue, "preload");
}

static inline JSValue jsHTMLMediaElementPreloadGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDOMString>(state, impl.preload());
    return result;
}

static inline JSValue jsHTMLMediaElementBufferedGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementBuffered(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementBufferedGetter>(state, thisValue, "buffered");
}

static inline JSValue jsHTMLMediaElementBufferedGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<TimeRanges>>(state, *thisObject.globalObject(), impl.buffered());
    return result;
}

static inline JSValue jsHTMLMediaElementReadyStateGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementReadyState(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementReadyStateGetter>(state, thisValue, "readyState");
}

static inline JSValue jsHTMLMediaElementReadyStateGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnsignedShort>(impl.readyState());
    return result;
}

static inline JSValue jsHTMLMediaElementSeekingGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementSeeking(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementSeekingGetter>(state, thisValue, "seeking");
}

static inline JSValue jsHTMLMediaElementSeekingGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.seeking());
    return result;
}

static inline JSValue jsHTMLMediaElementCurrentTimeGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementCurrentTime(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementCurrentTimeGetter>(state, thisValue, "currentTime");
}

static inline JSValue jsHTMLMediaElementCurrentTimeGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnrestrictedDouble>(impl.currentTimeForBindings());
    return result;
}

static inline JSValue jsHTMLMediaElementDurationGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementDuration(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementDurationGetter>(state, thisValue, "duration");
}

static inline JSValue jsHTMLMediaElementDurationGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnrestrictedDouble>(impl.duration());
    return result;
}

static inline JSValue jsHTMLMediaElementPausedGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementPaused(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementPausedGetter>(state, thisValue, "paused");
}

static inline JSValue jsHTMLMediaElementPausedGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.paused());
    return result;
}

static inline JSValue jsHTMLMediaElementDefaultPlaybackRateGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementDefaultPlaybackRate(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementDefaultPlaybackRateGetter>(state, thisValue, "defaultPlaybackRate");
}

static inline JSValue jsHTMLMediaElementDefaultPlaybackRateGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnrestrictedDouble>(impl.defaultPlaybackRate());
    return result;
}

static inline JSValue jsHTMLMediaElementPlaybackRateGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementPlaybackRate(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementPlaybackRateGetter>(state, thisValue, "playbackRate");
}

static inline JSValue jsHTMLMediaElementPlaybackRateGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnrestrictedDouble>(impl.playbackRate());
    return result;
}

static inline JSValue jsHTMLMediaElementPlayedGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementPlayed(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementPlayedGetter>(state, thisValue, "played");
}

static inline JSValue jsHTMLMediaElementPlayedGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<TimeRanges>>(state, *thisObject.globalObject(), impl.played());
    return result;
}

static inline JSValue jsHTMLMediaElementSeekableGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementSeekable(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementSeekableGetter>(state, thisValue, "seekable");
}

static inline JSValue jsHTMLMediaElementSeekableGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<TimeRanges>>(state, *thisObject.globalObject(), impl.seekable());
    return result;
}

static inline JSValue jsHTMLMediaElementEndedGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementEnded(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementEndedGetter>(state, thisValue, "ended");
}

static inline JSValue jsHTMLMediaElementEndedGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.ended());
    return result;
}

static inline JSValue jsHTMLMediaElementAutoplayGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementAutoplay(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementAutoplayGetter>(state, thisValue, "autoplay");
}

static inline JSValue jsHTMLMediaElementAutoplayGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.hasAttributeWithoutSynchronization(WebCore::HTMLNames::autoplayAttr));
    return result;
}

static inline JSValue jsHTMLMediaElementLoopGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementLoop(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementLoopGetter>(state, thisValue, "loop");
}

static inline JSValue jsHTMLMediaElementLoopGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.hasAttributeWithoutSynchronization(WebCore::HTMLNames::loopAttr));
    return result;
}

static inline JSValue jsHTMLMediaElementControlsGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementControls(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementControlsGetter>(state, thisValue, "controls");
}

static inline JSValue jsHTMLMediaElementControlsGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.controls());
    return result;
}

static inline JSValue jsHTMLMediaElementVolumeGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementVolume(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementVolumeGetter>(state, thisValue, "volume");
}

static inline JSValue jsHTMLMediaElementVolumeGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDouble>(impl.volume());
    return result;
}

static inline JSValue jsHTMLMediaElementMutedGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementMuted(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementMutedGetter>(state, thisValue, "muted");
}

static inline JSValue jsHTMLMediaElementMutedGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.muted());
    return result;
}

static inline JSValue jsHTMLMediaElementDefaultMutedGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementDefaultMuted(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementDefaultMutedGetter>(state, thisValue, "defaultMuted");
}

static inline JSValue jsHTMLMediaElementDefaultMutedGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.hasAttributeWithoutSynchronization(WebCore::HTMLNames::mutedAttr));
    return result;
}

static inline JSValue jsHTMLMediaElementWebkitPreservesPitchGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementWebkitPreservesPitch(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementWebkitPreservesPitchGetter>(state, thisValue, "webkitPreservesPitch");
}

static inline JSValue jsHTMLMediaElementWebkitPreservesPitchGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.webkitPreservesPitch());
    return result;
}

static inline JSValue jsHTMLMediaElementWebkitHasClosedCaptionsGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementWebkitHasClosedCaptions(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementWebkitHasClosedCaptionsGetter>(state, thisValue, "webkitHasClosedCaptions");
}

static inline JSValue jsHTMLMediaElementWebkitHasClosedCaptionsGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.webkitHasClosedCaptions());
    return result;
}

static inline JSValue jsHTMLMediaElementWebkitClosedCaptionsVisibleGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementWebkitClosedCaptionsVisible(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementWebkitClosedCaptionsVisibleGetter>(state, thisValue, "webkitClosedCaptionsVisible");
}

static inline JSValue jsHTMLMediaElementWebkitClosedCaptionsVisibleGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.webkitClosedCaptionsVisible());
    return result;
}

#if ENABLE(MEDIA_STATISTICS)
static inline JSValue jsHTMLMediaElementWebkitAudioDecodedByteCountGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementWebkitAudioDecodedByteCount(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementWebkitAudioDecodedByteCountGetter>(state, thisValue, "webkitAudioDecodedByteCount");
}

static inline JSValue jsHTMLMediaElementWebkitAudioDecodedByteCountGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnsignedLong>(impl.webkitAudioDecodedByteCount());
    return result;
}

#endif

#if ENABLE(MEDIA_STATISTICS)
static inline JSValue jsHTMLMediaElementWebkitVideoDecodedByteCountGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementWebkitVideoDecodedByteCount(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementWebkitVideoDecodedByteCountGetter>(state, thisValue, "webkitVideoDecodedByteCount");
}

static inline JSValue jsHTMLMediaElementWebkitVideoDecodedByteCountGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnsignedLong>(impl.webkitVideoDecodedByteCount());
    return result;
}

#endif

#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
static inline JSValue jsHTMLMediaElementWebkitKeysGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementWebkitKeys(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementWebkitKeysGetter>(state, thisValue, "webkitKeys");
}

static inline JSValue jsHTMLMediaElementWebkitKeysGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<WebKitMediaKeys>>(state, *thisObject.globalObject(), impl.webkitKeys());
    return result;
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
static inline JSValue jsHTMLMediaElementMediaKeysGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementMediaKeys(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementMediaKeysGetter>(state, thisValue, "mediaKeys");
}

static inline JSValue jsHTMLMediaElementMediaKeysGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<MediaKeys>>(state, *thisObject.globalObject(), impl.mediaKeys());
    return result;
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
static inline JSValue jsHTMLMediaElementOnencryptedGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementOnencrypted(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementOnencryptedGetter>(state, thisValue, "onencrypted");
}

static inline JSValue jsHTMLMediaElementOnencryptedGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().encryptedEvent);
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
static inline JSValue jsHTMLMediaElementOnwaitingforkeyGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementOnwaitingforkey(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementOnwaitingforkeyGetter>(state, thisValue, "onwaitingforkey");
}

static inline JSValue jsHTMLMediaElementOnwaitingforkeyGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().waitingforkeyEvent);
}

#endif

#if ENABLE(VIDEO_TRACK)
static inline JSValue jsHTMLMediaElementAudioTracksGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementAudioTracks(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementAudioTracksGetter>(state, thisValue, "audioTracks");
}

static inline JSValue jsHTMLMediaElementAudioTracksGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<AudioTrackList>>(state, *thisObject.globalObject(), impl.audioTracks());
    return result;
}

#endif

#if ENABLE(VIDEO_TRACK)
static inline JSValue jsHTMLMediaElementTextTracksGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementTextTracks(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementTextTracksGetter>(state, thisValue, "textTracks");
}

static inline JSValue jsHTMLMediaElementTextTracksGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<TextTrackList>>(state, *thisObject.globalObject(), impl.textTracks());
    return result;
}

#endif

#if ENABLE(VIDEO_TRACK)
static inline JSValue jsHTMLMediaElementVideoTracksGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementVideoTracks(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementVideoTracksGetter>(state, thisValue, "videoTracks");
}

static inline JSValue jsHTMLMediaElementVideoTracksGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<VideoTrackList>>(state, *thisObject.globalObject(), impl.videoTracks());
    return result;
}

#endif

static inline JSValue jsHTMLMediaElementMediaGroupGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementMediaGroup(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementMediaGroupGetter>(state, thisValue, "mediaGroup");
}

static inline JSValue jsHTMLMediaElementMediaGroupGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDOMString>(state, impl.attributeWithoutSynchronization(WebCore::HTMLNames::mediagroupAttr));
    return result;
}

static inline JSValue jsHTMLMediaElementControllerGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementController(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementControllerGetter>(state, thisValue, "controller");
}

static inline JSValue jsHTMLMediaElementControllerGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLNullable<IDLInterface<MediaController>>>(state, *thisObject.globalObject(), impl.controllerForBindings());
    return result;
}

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
static inline JSValue jsHTMLMediaElementWebkitCurrentPlaybackTargetIsWirelessGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementWebkitCurrentPlaybackTargetIsWireless(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementWebkitCurrentPlaybackTargetIsWirelessGetter>(state, thisValue, "webkitCurrentPlaybackTargetIsWireless");
}

static inline JSValue jsHTMLMediaElementWebkitCurrentPlaybackTargetIsWirelessGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.webkitCurrentPlaybackTargetIsWireless());
    return result;
}

#endif

#if ENABLE(MEDIA_SESSION) && ENABLE(VIDEO)
static inline JSValue jsHTMLMediaElementKindGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementKind(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementKindGetter>(state, thisValue, "kind");
}

static inline JSValue jsHTMLMediaElementKindGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDOMString>(state, WebCore::HTMLMediaElementMediaSession::kind(impl));
    return result;
}

#endif

#if ENABLE(MEDIA_SESSION) && ENABLE(VIDEO)
static inline JSValue jsHTMLMediaElementSessionGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementSession(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementSessionGetter>(state, thisValue, "session");
}

static inline JSValue jsHTMLMediaElementSessionGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLNullable<IDLInterface<MediaSession>>>(state, *thisObject.globalObject(), WebCore::HTMLMediaElementMediaSession::session(impl));
    return result;
}

#endif

#if ENABLE(MEDIA_STREAM) && ENABLE(VIDEO)
static inline JSValue jsHTMLMediaElementSrcObjectGetter(ExecState&, JSHTMLMediaElement&, ThrowScope& throwScope);

EncodedJSValue jsHTMLMediaElementSrcObject(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSHTMLMediaElement>::attribute<jsHTMLMediaElementSrcObjectGetter>(state, thisValue, "srcObject");
}

static inline JSValue jsHTMLMediaElementSrcObjectGetter(ExecState& state, JSHTMLMediaElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLNullable<IDLInterface<MediaStream>>>(state, *thisObject.globalObject(), WebCore::HTMLMediaElementMediaStream::srcObject(impl));
    return result;
}

#endif

EncodedJSValue jsHTMLMediaElementConstructor(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSHTMLMediaElementPrototype* domObject = jsDynamicDowncast<JSHTMLMediaElementPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject))
        return throwVMTypeError(state, throwScope);
    return JSValue::encode(JSHTMLMediaElement::getConstructor(state->vm(), domObject->globalObject()));
}

bool setJSHTMLMediaElementConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSValue value = JSValue::decode(encodedValue);
    JSHTMLMediaElementPrototype* domObject = jsDynamicDowncast<JSHTMLMediaElementPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject)) {
        throwVMTypeError(state, throwScope);
        return false;
    }
    // Shadowing a built-in constructor
    return domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
}

static inline bool setJSHTMLMediaElementSrcFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementSrc(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementSrcFunction>(state, thisValue, encodedValue, "src");
}

static inline bool setJSHTMLMediaElementSrcFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLUSVString>(state, value, StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::srcAttr, WTFMove(nativeValue));
    return true;
}


static inline bool setJSHTMLMediaElementCrossOriginFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementCrossOrigin(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementCrossOriginFunction>(state, thisValue, encodedValue, "crossOrigin");
}

static inline bool setJSHTMLMediaElementCrossOriginFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLNullable<IDLDOMString>>(state, value, StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setCrossOrigin(WTFMove(nativeValue));
    return true;
}


static inline bool setJSHTMLMediaElementPreloadFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementPreload(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementPreloadFunction>(state, thisValue, encodedValue, "preload");
}

static inline bool setJSHTMLMediaElementPreloadFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLDOMString>(state, value, StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setPreload(WTFMove(nativeValue));
    return true;
}


static inline bool setJSHTMLMediaElementCurrentTimeFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementCurrentTime(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementCurrentTimeFunction>(state, thisValue, encodedValue, "currentTime");
}

static inline bool setJSHTMLMediaElementCurrentTimeFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLUnrestrictedDouble>(state, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    propagateException(state, throwScope, impl.setCurrentTimeForBindings(WTFMove(nativeValue)));
    return true;
}


static inline bool setJSHTMLMediaElementDefaultPlaybackRateFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementDefaultPlaybackRate(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementDefaultPlaybackRateFunction>(state, thisValue, encodedValue, "defaultPlaybackRate");
}

static inline bool setJSHTMLMediaElementDefaultPlaybackRateFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLUnrestrictedDouble>(state, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setDefaultPlaybackRate(WTFMove(nativeValue));
    return true;
}


static inline bool setJSHTMLMediaElementPlaybackRateFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementPlaybackRate(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementPlaybackRateFunction>(state, thisValue, encodedValue, "playbackRate");
}

static inline bool setJSHTMLMediaElementPlaybackRateFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLUnrestrictedDouble>(state, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setPlaybackRate(WTFMove(nativeValue));
    return true;
}


static inline bool setJSHTMLMediaElementAutoplayFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementAutoplay(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementAutoplayFunction>(state, thisValue, encodedValue, "autoplay");
}

static inline bool setJSHTMLMediaElementAutoplayFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLBoolean>(state, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setBooleanAttribute(WebCore::HTMLNames::autoplayAttr, WTFMove(nativeValue));
    return true;
}


static inline bool setJSHTMLMediaElementLoopFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementLoop(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementLoopFunction>(state, thisValue, encodedValue, "loop");
}

static inline bool setJSHTMLMediaElementLoopFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLBoolean>(state, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setBooleanAttribute(WebCore::HTMLNames::loopAttr, WTFMove(nativeValue));
    return true;
}


static inline bool setJSHTMLMediaElementControlsFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementControls(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementControlsFunction>(state, thisValue, encodedValue, "controls");
}

static inline bool setJSHTMLMediaElementControlsFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLBoolean>(state, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setControls(WTFMove(nativeValue));
    return true;
}


static inline bool setJSHTMLMediaElementVolumeFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementVolume(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementVolumeFunction>(state, thisValue, encodedValue, "volume");
}

static inline bool setJSHTMLMediaElementVolumeFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLDouble>(state, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    propagateException(state, throwScope, impl.setVolume(WTFMove(nativeValue)));
    return true;
}


static inline bool setJSHTMLMediaElementMutedFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementMuted(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementMutedFunction>(state, thisValue, encodedValue, "muted");
}

static inline bool setJSHTMLMediaElementMutedFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLBoolean>(state, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setMuted(WTFMove(nativeValue));
    return true;
}


static inline bool setJSHTMLMediaElementDefaultMutedFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementDefaultMuted(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementDefaultMutedFunction>(state, thisValue, encodedValue, "defaultMuted");
}

static inline bool setJSHTMLMediaElementDefaultMutedFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLBoolean>(state, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setBooleanAttribute(WebCore::HTMLNames::mutedAttr, WTFMove(nativeValue));
    return true;
}


static inline bool setJSHTMLMediaElementWebkitPreservesPitchFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementWebkitPreservesPitch(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementWebkitPreservesPitchFunction>(state, thisValue, encodedValue, "webkitPreservesPitch");
}

static inline bool setJSHTMLMediaElementWebkitPreservesPitchFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLBoolean>(state, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setWebkitPreservesPitch(WTFMove(nativeValue));
    return true;
}


static inline bool setJSHTMLMediaElementWebkitClosedCaptionsVisibleFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementWebkitClosedCaptionsVisible(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementWebkitClosedCaptionsVisibleFunction>(state, thisValue, encodedValue, "webkitClosedCaptionsVisible");
}

static inline bool setJSHTMLMediaElementWebkitClosedCaptionsVisibleFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLBoolean>(state, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setWebkitClosedCaptionsVisible(WTFMove(nativeValue));
    return true;
}


#if ENABLE(ENCRYPTED_MEDIA)
static inline bool setJSHTMLMediaElementOnencryptedFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementOnencrypted(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementOnencryptedFunction>(state, thisValue, encodedValue, "onencrypted");
}

static inline bool setJSHTMLMediaElementOnencryptedFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().encryptedEvent, value);
    return true;
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
static inline bool setJSHTMLMediaElementOnwaitingforkeyFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementOnwaitingforkey(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementOnwaitingforkeyFunction>(state, thisValue, encodedValue, "onwaitingforkey");
}

static inline bool setJSHTMLMediaElementOnwaitingforkeyFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().waitingforkeyEvent, value);
    return true;
}

#endif

static inline bool setJSHTMLMediaElementMediaGroupFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementMediaGroup(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementMediaGroupFunction>(state, thisValue, encodedValue, "mediaGroup");
}

static inline bool setJSHTMLMediaElementMediaGroupFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLDOMString>(state, value, StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::mediagroupAttr, WTFMove(nativeValue));
    return true;
}


static inline bool setJSHTMLMediaElementControllerFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementController(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementControllerFunction>(state, thisValue, encodedValue, "controller");
}

static inline bool setJSHTMLMediaElementControllerFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLNullable<IDLInterface<MediaController>>>(state, value, [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwAttributeTypeError(state, scope, "HTMLMediaElement", "controller", "MediaController"); });
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setControllerForBindings(WTFMove(nativeValue));
    return true;
}


#if ENABLE(MEDIA_SESSION) && ENABLE(VIDEO)
static inline bool setJSHTMLMediaElementKindFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementKind(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementKindFunction>(state, thisValue, encodedValue, "kind");
}

static inline bool setJSHTMLMediaElementKindFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLDOMString>(state, value, StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    WebCore::HTMLMediaElementMediaSession::setKind(impl, WTFMove(nativeValue));
    return true;
}

#endif

#if ENABLE(MEDIA_SESSION) && ENABLE(VIDEO)
static inline bool setJSHTMLMediaElementSessionFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementSession(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementSessionFunction>(state, thisValue, encodedValue, "session");
}

static inline bool setJSHTMLMediaElementSessionFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLNullable<IDLInterface<MediaSession>>>(state, value, [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwAttributeTypeError(state, scope, "HTMLMediaElement", "session", "MediaSession"); });
    RETURN_IF_EXCEPTION(throwScope, false);
    WebCore::HTMLMediaElementMediaSession::setSession(impl, WTFMove(nativeValue));
    return true;
}

#endif

#if ENABLE(MEDIA_STREAM) && ENABLE(VIDEO)
static inline bool setJSHTMLMediaElementSrcObjectFunction(ExecState&, JSHTMLMediaElement&, JSValue, ThrowScope&);

bool setJSHTMLMediaElementSrcObject(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSHTMLMediaElement>::setAttribute<setJSHTMLMediaElementSrcObjectFunction>(state, thisValue, encodedValue, "srcObject");
}

static inline bool setJSHTMLMediaElementSrcObjectFunction(ExecState& state, JSHTMLMediaElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLNullable<IDLInterface<MediaStream>>>(state, value, [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwAttributeTypeError(state, scope, "HTMLMediaElement", "srcObject", "MediaStream"); });
    RETURN_IF_EXCEPTION(throwScope, false);
    auto* context = jsCast<JSDOMGlobalObject*>(state.lexicalGlobalObject())->scriptExecutionContext();
    if (!context)
        return false;
    WebCore::HTMLMediaElementMediaStream::setSrcObject(*context, impl, WTFMove(nativeValue));
    return true;
}

#endif

JSValue JSHTMLMediaElement::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSHTMLMediaElementConstructor>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionLoadCaller(JSC::ExecState*, JSHTMLMediaElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionLoad(ExecState* state)
{
    return BindingCaller<JSHTMLMediaElement>::callOperation<jsHTMLMediaElementPrototypeFunctionLoadCaller>(state, "load");
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionLoadCaller(JSC::ExecState* state, JSHTMLMediaElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.load();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionCanPlayTypeCaller(JSC::ExecState*, JSHTMLMediaElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionCanPlayType(ExecState* state)
{
    return BindingCaller<JSHTMLMediaElement>::callOperation<jsHTMLMediaElementPrototypeFunctionCanPlayTypeCaller>(state, "canPlayType");
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionCanPlayTypeCaller(JSC::ExecState* state, JSHTMLMediaElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto type = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLDOMString>(*state, impl.canPlayType(WTFMove(type))));
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionGetStartDateCaller(JSC::ExecState*, JSHTMLMediaElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionGetStartDate(ExecState* state)
{
    return BindingCaller<JSHTMLMediaElement>::callOperation<jsHTMLMediaElementPrototypeFunctionGetStartDateCaller>(state, "getStartDate");
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionGetStartDateCaller(JSC::ExecState* state, JSHTMLMediaElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLDate>(*state, impl.getStartDate()));
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionPlayCaller(JSC::ExecState*, JSHTMLMediaElement*, Ref<DeferredPromise>&&, JSC::ThrowScope&);

static EncodedJSValue jsHTMLMediaElementPrototypeFunctionPlayPromise(ExecState*, Ref<DeferredPromise>&&);

EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionPlay(ExecState* state)
{
    ASSERT(state);
    return JSValue::encode(callPromiseFunction<jsHTMLMediaElementPrototypeFunctionPlayPromise, PromiseExecutionScope::WindowOnly>(*state));
}

static inline EncodedJSValue jsHTMLMediaElementPrototypeFunctionPlayPromise(ExecState* state, Ref<DeferredPromise>&& promise)
{
    return BindingCaller<JSHTMLMediaElement>::callPromiseOperation<jsHTMLMediaElementPrototypeFunctionPlayCaller>(state, WTFMove(promise), "play");
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionPlayCaller(JSC::ExecState* state, JSHTMLMediaElement* castedThis, Ref<DeferredPromise>&& promise, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.play(WTFMove(promise));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionPauseCaller(JSC::ExecState*, JSHTMLMediaElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionPause(ExecState* state)
{
    return BindingCaller<JSHTMLMediaElement>::callOperation<jsHTMLMediaElementPrototypeFunctionPauseCaller>(state, "pause");
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionPauseCaller(JSC::ExecState* state, JSHTMLMediaElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.pause();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionFastSeekCaller(JSC::ExecState*, JSHTMLMediaElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionFastSeek(ExecState* state)
{
    return BindingCaller<JSHTMLMediaElement>::callOperation<jsHTMLMediaElementPrototypeFunctionFastSeekCaller>(state, "fastSeek");
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionFastSeekCaller(JSC::ExecState* state, JSHTMLMediaElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto time = convert<IDLUnrestrictedDouble>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.fastSeek(WTFMove(time));
    return JSValue::encode(jsUndefined());
}

#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionWebkitSetMediaKeysCaller(JSC::ExecState*, JSHTMLMediaElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionWebkitSetMediaKeys(ExecState* state)
{
    return BindingCaller<JSHTMLMediaElement>::callOperation<jsHTMLMediaElementPrototypeFunctionWebkitSetMediaKeysCaller>(state, "webkitSetMediaKeys");
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionWebkitSetMediaKeysCaller(JSC::ExecState* state, JSHTMLMediaElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto mediaKeys = convert<IDLNullable<IDLInterface<WebKitMediaKeys>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "mediaKeys", "HTMLMediaElement", "webkitSetMediaKeys", "WebKitMediaKeys"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.webkitSetMediaKeys(WTFMove(mediaKeys));
    return JSValue::encode(jsUndefined());
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionSetMediaKeysCaller(JSC::ExecState*, JSHTMLMediaElement*, Ref<DeferredPromise>&&, JSC::ThrowScope&);

static EncodedJSValue jsHTMLMediaElementPrototypeFunctionSetMediaKeysPromise(ExecState*, Ref<DeferredPromise>&&);

EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionSetMediaKeys(ExecState* state)
{
    ASSERT(state);
    return JSValue::encode(callPromiseFunction<jsHTMLMediaElementPrototypeFunctionSetMediaKeysPromise, PromiseExecutionScope::WindowOnly>(*state));
}

static inline EncodedJSValue jsHTMLMediaElementPrototypeFunctionSetMediaKeysPromise(ExecState* state, Ref<DeferredPromise>&& promise)
{
    return BindingCaller<JSHTMLMediaElement>::callPromiseOperation<jsHTMLMediaElementPrototypeFunctionSetMediaKeysCaller>(state, WTFMove(promise), "setMediaKeys");
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionSetMediaKeysCaller(JSC::ExecState* state, JSHTMLMediaElement* castedThis, Ref<DeferredPromise>&& promise, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto mediaKeys = convert<IDLNullable<IDLInterface<MediaKeys>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "mediaKeys", "HTMLMediaElement", "setMediaKeys", "MediaKeys"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.setMediaKeys(WTFMove(mediaKeys), WTFMove(promise));
    return JSValue::encode(jsUndefined());
}

#endif

#if ENABLE(VIDEO_TRACK)
static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionAddTextTrackCaller(JSC::ExecState*, JSHTMLMediaElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionAddTextTrack(ExecState* state)
{
    return BindingCaller<JSHTMLMediaElement>::callOperation<jsHTMLMediaElementPrototypeFunctionAddTextTrackCaller>(state, "addTextTrack");
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionAddTextTrackCaller(JSC::ExecState* state, JSHTMLMediaElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto kind = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto label = state->argument(1).isUndefined() ? emptyString() : convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto language = state->argument(2).isUndefined() ? emptyString() : convert<IDLDOMString>(*state, state->uncheckedArgument(2), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<TextTrack>>(*state, *castedThis->globalObject(), throwScope, impl.addTextTrack(WTFMove(kind), WTFMove(label), WTFMove(language))));
}

#endif

#if ENABLE(MEDIA_SOURCE)
static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionGetVideoPlaybackQualityCaller(JSC::ExecState*, JSHTMLMediaElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionGetVideoPlaybackQuality(ExecState* state)
{
    return BindingCaller<JSHTMLMediaElement>::callOperation<jsHTMLMediaElementPrototypeFunctionGetVideoPlaybackQualityCaller>(state, "getVideoPlaybackQuality");
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionGetVideoPlaybackQualityCaller(JSC::ExecState* state, JSHTMLMediaElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLInterface<VideoPlaybackQuality>>(*state, *castedThis->globalObject(), impl.getVideoPlaybackQuality()));
}

#endif

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionWebkitShowPlaybackTargetPickerCaller(JSC::ExecState*, JSHTMLMediaElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsHTMLMediaElementPrototypeFunctionWebkitShowPlaybackTargetPicker(ExecState* state)
{
    return BindingCaller<JSHTMLMediaElement>::callOperation<jsHTMLMediaElementPrototypeFunctionWebkitShowPlaybackTargetPickerCaller>(state, "webkitShowPlaybackTargetPicker");
}

static inline JSC::EncodedJSValue jsHTMLMediaElementPrototypeFunctionWebkitShowPlaybackTargetPickerCaller(JSC::ExecState* state, JSHTMLMediaElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.webkitShowPlaybackTargetPicker();
    return JSValue::encode(jsUndefined());
}

#endif

void JSHTMLMediaElement::visitChildren(JSCell* cell, SlotVisitor& visitor)
{
    auto* thisObject = jsCast<JSHTMLMediaElement*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    thisObject->wrapped().visitJSEventListeners(visitor);
}

bool JSHTMLMediaElementOwner::isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void*, SlotVisitor& visitor)
{
    auto* jsHTMLMediaElement = jsCast<JSHTMLMediaElement*>(handle.slot()->asCell());
    if (jsHTMLMediaElement->wrapped().hasPendingActivity())
        return true;
    if (jsHTMLMediaElement->wrapped().isFiringEventListeners())
        return true;
    if (JSNodeOwner::isReachableFromOpaqueRoots(handle, 0, visitor))
        return true;
    UNUSED_PARAM(visitor);
    return false;
}

void JSHTMLMediaElementOwner::finalize(JSC::Handle<JSC::Unknown> handle, void* context)
{
    auto* jsHTMLMediaElement = static_cast<JSHTMLMediaElement*>(handle.slot()->asCell());
    auto& world = *static_cast<DOMWrapperWorld*>(context);
    uncacheWrapper(world, &jsHTMLMediaElement->wrapped(), jsHTMLMediaElement);
}

HTMLMediaElement* JSHTMLMediaElement::toWrapped(JSC::JSValue value)
{
    if (auto* wrapper = jsDynamicDowncast<JSHTMLMediaElement*>(value))
        return &wrapper->wrapped();
    return nullptr;
}

}

#endif // ENABLE(VIDEO)
