/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"
#include "JSElement.h"

#include "CustomElementReactionQueue.h"
#include "DOMJITAbstractHeapRepository.h"
#include "DOMJITCheckDOM.h"
#include "DOMJITIDLConvert.h"
#include "DOMJITIDLType.h"
#include "DOMJITIDLTypeFilter.h"
#include "EventNames.h"
#include "HTMLNames.h"
#include "JSAttr.h"
#include "JSCSSStyleDeclaration.h"
#include "JSClientRect.h"
#include "JSClientRectList.h"
#include "JSDOMBinding.h"
#include "JSDOMConstructor.h"
#include "JSDOMTokenList.h"
#include "JSElement.h"
#include "JSEventListener.h"
#include "JSHTMLCollection.h"
#include "JSHTMLSlotElement.h"
#include "JSNamedNodeMap.h"
#include "JSNodeList.h"
#include "JSRange.h"
#include "JSScrollToOptions.h"
#include "JSShadowRoot.h"
#include "JSShadowRootMode.h"
#include "JSWebAnimation.h"
#include "RuntimeEnabledFeatures.h"
#include <interpreter/FrameTracers.h>
#include <runtime/Error.h>
#include <runtime/JSArray.h>
#include <runtime/ObjectConstructor.h>
#include <wtf/GetPtr.h>
#include <wtf/Variant.h>

using namespace JSC;

namespace WebCore {

template<> Element::ShadowRootInit convertDictionary<Element::ShadowRootInit>(ExecState& state, JSValue value)
{
    VM& vm = state.vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (UNLIKELY(!isNullOrUndefined && !object)) {
        throwTypeError(&state, throwScope);
        return { };
    }
    if (UNLIKELY(object && object->type() == RegExpObjectType)) {
        throwTypeError(&state, throwScope);
        return { };
    }
    Element::ShadowRootInit result;
    JSValue modeValue = isNullOrUndefined ? jsUndefined() : object->get(&state, Identifier::fromString(&state, "mode"));
    if (!modeValue.isUndefined()) {
        result.mode = convert<IDLEnumeration<ShadowRootMode>>(state, modeValue);
        RETURN_IF_EXCEPTION(throwScope, { });
    } else {
        throwRequiredMemberTypeError(state, throwScope, "mode", "ShadowRootInit", "ShadowRootMode");
        return { };
    }
    return result;
}

// Functions

JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttribute(JSC::ExecState*);
JSC::EncodedJSValue JIT_OPERATION unsafeJsElementPrototypeFunctionGetAttribute(JSC::ExecState*, JSElement*, DOMJIT::IDLJSArgumentType<IDLDOMString>);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttribute(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttribute(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNode(JSC::ExecState*);
JSC::EncodedJSValue JIT_OPERATION unsafeJsElementPrototypeFunctionGetAttributeNode(JSC::ExecState*, JSElement*, DOMJIT::IDLJSArgumentType<IDLDOMString>);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNode(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttributeNode(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByTagName(JSC::ExecState*);
JSC::EncodedJSValue JIT_OPERATION unsafeJsElementPrototypeFunctionGetElementsByTagName(JSC::ExecState*, JSElement*, DOMJIT::IDLJSArgumentType<IDLDOMString>);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttributes(JSC::ExecState*);
JSC::EncodedJSValue JIT_OPERATION unsafeJsElementPrototypeFunctionHasAttributes(JSC::ExecState*, JSElement*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttributeNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByTagNameNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNodeNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNodeNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttribute(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttributeNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollIntoView(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollIntoViewIfNeeded(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScroll(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollTo(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollBy(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollByLines(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollByPages(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNames(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByClassName(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionMatches(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionClosest(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitMatchesSelector(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetClientRects(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetBoundingClientRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitRequestFullScreen(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitRequestFullscreen(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionInsertAdjacentElement(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionInsertAdjacentHTML(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionInsertAdjacentText(JSC::ExecState*);
#if ENABLE(POINTER_LOCK)
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRequestPointerLock(JSC::ExecState*);
#endif
#if ENABLE(CSS_REGIONS)
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitGetRegionFlowRanges(JSC::ExecState*);
#endif
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAttachShadow(JSC::ExecState*);
#if ENABLE(WEB_ANIMATIONS)
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAnimations(JSC::ExecState*);
#endif
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionBefore(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAfter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionReplaceWith(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemove(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionPrepend(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAppend(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionQuerySelector(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionQuerySelectorAll(JSC::ExecState*);

// Attributes

JSC::EncodedJSValue jsElementTagName(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementAttributes(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementStyle(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementId(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementId(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementNamespaceURI(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementPrefix(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementLocalName(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementOffsetLeft(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementOffsetTop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementOffsetWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementOffsetHeight(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementClientLeft(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementClientTop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementClientWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementClientHeight(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementScrollLeft(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementScrollLeft(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementScrollTop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementScrollTop(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementScrollWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementScrollHeight(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementOffsetParent(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementInnerHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementInnerHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOuterHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOuterHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementClassName(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementClassName(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementClassList(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementClassList(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#if ENABLE(CSS_REGIONS)
JSC::EncodedJSValue jsElementWebkitRegionOverset(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
#endif
JSC::EncodedJSValue jsElementShadowRoot(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementSlot(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementSlot(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnbeforecopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnbeforecopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnbeforecut(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnbeforecut(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnbeforeinput(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnbeforeinput(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnbeforepaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnbeforepaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOncopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOncopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOncut(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOncut(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnpaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnpaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnselectstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnselectstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#if ENABLE(FULLSCREEN_API)
JSC::EncodedJSValue jsElementOnwebkitfullscreenchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitfullscreenchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(FULLSCREEN_API)
JSC::EncodedJSValue jsElementOnwebkitfullscreenerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitfullscreenerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
JSC::EncodedJSValue jsElementOnanimationend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnanimationend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnanimationiteration(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnanimationiteration(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnanimationstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnanimationstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOntransitionend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOntransitionend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnwebkitanimationend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitanimationend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnwebkitanimationiteration(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitanimationiteration(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnwebkitanimationstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitanimationstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnwebkittransitionend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkittransitionend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#if ENABLE(IOS_GESTURE_EVENTS)
JSC::EncodedJSValue jsElementOngesturechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOngesturechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(IOS_GESTURE_EVENTS)
JSC::EncodedJSValue jsElementOngestureend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOngestureend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(IOS_GESTURE_EVENTS)
JSC::EncodedJSValue jsElementOngesturestart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOngesturestart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
JSC::EncodedJSValue jsElementOnfocusin(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnfocusin(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnfocusout(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnfocusout(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnbeforeload(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnbeforeload(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
JSC::EncodedJSValue jsElementOnwebkitneedkey(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitneedkey(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(VIDEO_PRESENTATION_MODE)
JSC::EncodedJSValue jsElementOnwebkitpresentationmodechanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitpresentationmodechanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
JSC::EncodedJSValue jsElementOnwebkitcurrentplaybacktargetiswirelesschanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitcurrentplaybacktargetiswirelesschanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
JSC::EncodedJSValue jsElementOnwebkitplaybacktargetavailabilitychanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitplaybacktargetavailabilitychanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
JSC::EncodedJSValue jsElementPreviousElementSibling(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementNextElementSibling(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementChildren(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementFirstElementChild(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementLastElementChild(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementChildElementCount(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementAssignedSlot(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);

#if ENABLE(JIT)
static const JSC::DOMJIT::Signature DOMJITSignatureForElementGetAttribute((uintptr_t)unsafeJsElementPrototypeFunctionGetAttribute, DOMJIT::checkDOM<Element>, JSElement::info(), JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), DOMJIT::IDLResultTypeFilter<IDLNullable<IDLDOMString>>::value, DOMJIT::IDLArgumentTypeFilter<IDLDOMString>::value);
#else
static const JSC::DOMJIT::Signature DOMJITSignatureForElementGetAttribute((uintptr_t)unsafeJsElementPrototypeFunctionGetAttribute, nullptr, JSElement::info(), JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), DOMJIT::IDLResultTypeFilter<IDLNullable<IDLDOMString>>::value, DOMJIT::IDLArgumentTypeFilter<IDLDOMString>::value);
#endif

#if ENABLE(JIT)
static const JSC::DOMJIT::Signature DOMJITSignatureForElementGetAttributeNode((uintptr_t)unsafeJsElementPrototypeFunctionGetAttributeNode, DOMJIT::checkDOM<Element>, JSElement::info(), JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), DOMJIT::IDLResultTypeFilter<IDLNullable<IDLInterface<Attr>>>::value, DOMJIT::IDLArgumentTypeFilter<IDLDOMString>::value);
#else
static const JSC::DOMJIT::Signature DOMJITSignatureForElementGetAttributeNode((uintptr_t)unsafeJsElementPrototypeFunctionGetAttributeNode, nullptr, JSElement::info(), JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), DOMJIT::IDLResultTypeFilter<IDLNullable<IDLInterface<Attr>>>::value, DOMJIT::IDLArgumentTypeFilter<IDLDOMString>::value);
#endif

#if ENABLE(JIT)
static const JSC::DOMJIT::Signature DOMJITSignatureForElementGetElementsByTagName((uintptr_t)unsafeJsElementPrototypeFunctionGetElementsByTagName, DOMJIT::checkDOM<Element>, JSElement::info(), JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), DOMJIT::IDLResultTypeFilter<IDLInterface<HTMLCollection>>::value, DOMJIT::IDLArgumentTypeFilter<IDLDOMString>::value);
#else
static const JSC::DOMJIT::Signature DOMJITSignatureForElementGetElementsByTagName((uintptr_t)unsafeJsElementPrototypeFunctionGetElementsByTagName, nullptr, JSElement::info(), JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), DOMJIT::IDLResultTypeFilter<IDLInterface<HTMLCollection>>::value, DOMJIT::IDLArgumentTypeFilter<IDLDOMString>::value);
#endif

#if ENABLE(JIT)
static const JSC::DOMJIT::Signature DOMJITSignatureForElementHasAttributes((uintptr_t)unsafeJsElementPrototypeFunctionHasAttributes, DOMJIT::checkDOM<Element>, JSElement::info(), JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), DOMJIT::IDLResultTypeFilter<IDLBoolean>::value);
#else
static const JSC::DOMJIT::Signature DOMJITSignatureForElementHasAttributes((uintptr_t)unsafeJsElementPrototypeFunctionHasAttributes, nullptr, JSElement::info(), JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), DOMJIT::IDLResultTypeFilter<IDLBoolean>::value);
#endif

class JSElementPrototype : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;
    static JSElementPrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSElementPrototype* ptr = new (NotNull, JSC::allocateCell<JSElementPrototype>(vm.heap)) JSElementPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSElementPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};

using JSElementConstructor = JSDOMConstructorNotConstructable<JSElement>;

template<> JSValue JSElementConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    return JSNode::getConstructor(vm, &globalObject);
}

template<> void JSElementConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    putDirect(vm, vm.propertyNames->prototype, JSElement::prototype(vm, &globalObject), DontDelete | ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("Element"))), ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
}

template<> const ClassInfo JSElementConstructor::s_info = { "Element", &Base::s_info, 0, CREATE_METHOD_TABLE(JSElementConstructor) };

/* Hash table for prototype */

static const HashTableValue JSElementPrototypeTableValues[] =
{
    { "constructor", DontEnum, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementConstructor) } },
    { "tagName", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementTagName), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "attributes", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementAttributes), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "style", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementStyle), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "id", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementId), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementId) } },
    { "namespaceURI", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementNamespaceURI), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "prefix", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementPrefix), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "localName", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementLocalName), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "offsetLeft", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetLeft), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "offsetTop", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetTop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "offsetWidth", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "offsetHeight", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetHeight), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "clientLeft", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClientLeft), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "clientTop", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClientTop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "clientWidth", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClientWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "clientHeight", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClientHeight), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "scrollLeft", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementScrollLeft), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementScrollLeft) } },
    { "scrollTop", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementScrollTop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementScrollTop) } },
    { "scrollWidth", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementScrollWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "scrollHeight", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementScrollHeight), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "offsetParent", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetParent), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "innerHTML", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementInnerHTML), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementInnerHTML) } },
    { "outerHTML", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOuterHTML), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOuterHTML) } },
    { "className", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClassName), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementClassName) } },
    { "classList", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClassList), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementClassList) } },
#if ENABLE(CSS_REGIONS)
    { "webkitRegionOverset", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementWebkitRegionOverset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "shadowRoot", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementShadowRoot), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "slot", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementSlot), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementSlot) } },
    { "onbeforecopy", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforecopy), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforecopy) } },
    { "onbeforecut", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforecut), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforecut) } },
    { "onbeforeinput", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforeinput), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforeinput) } },
    { "onbeforepaste", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforepaste), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforepaste) } },
    { "oncopy", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOncopy), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOncopy) } },
    { "oncut", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOncut), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOncut) } },
    { "onpaste", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnpaste), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnpaste) } },
    { "onselectstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnselectstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnselectstart) } },
#if ENABLE(FULLSCREEN_API)
    { "onwebkitfullscreenchange", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitfullscreenchange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitfullscreenchange) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(FULLSCREEN_API)
    { "onwebkitfullscreenerror", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitfullscreenerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitfullscreenerror) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "onanimationend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnanimationend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnanimationend) } },
    { "onanimationiteration", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnanimationiteration), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnanimationiteration) } },
    { "onanimationstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnanimationstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnanimationstart) } },
    { "ontransitionend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOntransitionend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOntransitionend) } },
    { "onwebkitanimationend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitanimationend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitanimationend) } },
    { "onwebkitanimationiteration", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitanimationiteration), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitanimationiteration) } },
    { "onwebkitanimationstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitanimationstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitanimationstart) } },
    { "onwebkittransitionend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkittransitionend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkittransitionend) } },
#if ENABLE(IOS_GESTURE_EVENTS)
    { "ongesturechange", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOngesturechange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOngesturechange) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(IOS_GESTURE_EVENTS)
    { "ongestureend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOngestureend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOngestureend) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(IOS_GESTURE_EVENTS)
    { "ongesturestart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOngesturestart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOngesturestart) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "onfocusin", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnfocusin), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnfocusin) } },
    { "onfocusout", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnfocusout), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnfocusout) } },
    { "onbeforeload", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforeload), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforeload) } },
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
    { "onwebkitneedkey", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitneedkey), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitneedkey) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(VIDEO_PRESENTATION_MODE)
    { "onwebkitpresentationmodechanged", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitpresentationmodechanged), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitpresentationmodechanged) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
    { "onwebkitcurrentplaybacktargetiswirelesschanged", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitcurrentplaybacktargetiswirelesschanged), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitcurrentplaybacktargetiswirelesschanged) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
    { "onwebkitplaybacktargetavailabilitychanged", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitplaybacktargetavailabilitychanged), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitplaybacktargetavailabilitychanged) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "previousElementSibling", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementPreviousElementSibling), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "nextElementSibling", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementNextElementSibling), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "children", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementChildren), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "firstElementChild", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementFirstElementChild), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "lastElementChild", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementLastElementChild), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "childElementCount", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementChildElementCount), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "assignedSlot", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementAssignedSlot), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "getAttribute", JSC::Function | DOMJITFunction, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttribute), (intptr_t) static_cast<const JSC::DOMJIT::Signature*>(&DOMJITSignatureForElementGetAttribute) } },
    { "setAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionSetAttribute), (intptr_t) (2) } },
    { "removeAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRemoveAttribute), (intptr_t) (1) } },
    { "getAttributeNode", JSC::Function | DOMJITFunction, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttributeNode), (intptr_t) static_cast<const JSC::DOMJIT::Signature*>(&DOMJITSignatureForElementGetAttributeNode) } },
    { "setAttributeNode", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionSetAttributeNode), (intptr_t) (1) } },
    { "removeAttributeNode", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRemoveAttributeNode), (intptr_t) (1) } },
    { "getElementsByTagName", JSC::Function | DOMJITFunction, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetElementsByTagName), (intptr_t) static_cast<const JSC::DOMJIT::Signature*>(&DOMJITSignatureForElementGetElementsByTagName) } },
    { "hasAttributes", JSC::Function | DOMJITFunction, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionHasAttributes), (intptr_t) static_cast<const JSC::DOMJIT::Signature*>(&DOMJITSignatureForElementHasAttributes) } },
    { "getAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttributeNS), (intptr_t) (2) } },
    { "setAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionSetAttributeNS), (intptr_t) (3) } },
    { "removeAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRemoveAttributeNS), (intptr_t) (2) } },
    { "getElementsByTagNameNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetElementsByTagNameNS), (intptr_t) (2) } },
    { "getAttributeNodeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttributeNodeNS), (intptr_t) (2) } },
    { "setAttributeNodeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionSetAttributeNodeNS), (intptr_t) (1) } },
    { "hasAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionHasAttribute), (intptr_t) (1) } },
    { "hasAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionHasAttributeNS), (intptr_t) (2) } },
    { "scrollIntoView", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollIntoView), (intptr_t) (0) } },
    { "scrollIntoViewIfNeeded", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollIntoViewIfNeeded), (intptr_t) (0) } },
    { "scroll", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScroll), (intptr_t) (0) } },
    { "scrollTo", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollTo), (intptr_t) (0) } },
    { "scrollBy", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollBy), (intptr_t) (0) } },
    { "scrollByLines", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollByLines), (intptr_t) (0) } },
    { "scrollByPages", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollByPages), (intptr_t) (0) } },
    { "getAttributeNames", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttributeNames), (intptr_t) (0) } },
    { "getElementsByClassName", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetElementsByClassName), (intptr_t) (1) } },
    { "matches", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionMatches), (intptr_t) (1) } },
    { "closest", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionClosest), (intptr_t) (1) } },
    { "webkitMatchesSelector", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionWebkitMatchesSelector), (intptr_t) (1) } },
    { "getClientRects", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetClientRects), (intptr_t) (0) } },
    { "getBoundingClientRect", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetBoundingClientRect), (intptr_t) (0) } },
    { "webkitRequestFullScreen", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionWebkitRequestFullScreen), (intptr_t) (0) } },
    { "webkitRequestFullscreen", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionWebkitRequestFullscreen), (intptr_t) (0) } },
    { "insertAdjacentElement", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionInsertAdjacentElement), (intptr_t) (2) } },
    { "insertAdjacentHTML", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionInsertAdjacentHTML), (intptr_t) (2) } },
    { "insertAdjacentText", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionInsertAdjacentText), (intptr_t) (2) } },
#if ENABLE(POINTER_LOCK)
    { "requestPointerLock", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRequestPointerLock), (intptr_t) (0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(CSS_REGIONS)
    { "webkitGetRegionFlowRanges", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionWebkitGetRegionFlowRanges), (intptr_t) (0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "attachShadow", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionAttachShadow), (intptr_t) (1) } },
#if ENABLE(WEB_ANIMATIONS)
    { "getAnimations", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAnimations), (intptr_t) (0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "before", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionBefore), (intptr_t) (0) } },
    { "after", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionAfter), (intptr_t) (0) } },
    { "replaceWith", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionReplaceWith), (intptr_t) (0) } },
    { "remove", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRemove), (intptr_t) (0) } },
    { "prepend", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionPrepend), (intptr_t) (0) } },
    { "append", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionAppend), (intptr_t) (0) } },
    { "querySelector", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionQuerySelector), (intptr_t) (1) } },
    { "querySelectorAll", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionQuerySelectorAll), (intptr_t) (1) } },
};

const ClassInfo JSElementPrototype::s_info = { "ElementPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSElementPrototype) };

void JSElementPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSElementPrototypeTableValues, *this);
    if (!RuntimeEnabledFeatures::sharedFeatures().shadowDOMEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("attachShadow"), strlen("attachShadow"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
#if ENABLE(WEB_ANIMATIONS)
    if (!RuntimeEnabledFeatures::sharedFeatures().webAnimationsEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("getAnimations"), strlen("getAnimations"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
#endif
    if (!RuntimeEnabledFeatures::sharedFeatures().shadowDOMEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("shadowRoot"), strlen("shadowRoot"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
    if (!RuntimeEnabledFeatures::sharedFeatures().shadowDOMEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("slot"), strlen("slot"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
    if (!RuntimeEnabledFeatures::sharedFeatures().shadowDOMEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("assignedSlot"), strlen("assignedSlot"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
    JSObject& unscopables = *constructEmptyObject(globalObject()->globalExec(), globalObject()->nullPrototypeObjectStructure());
    unscopables.putDirect(vm, Identifier::fromString(&vm, "before"), jsBoolean(true));
    unscopables.putDirect(vm, Identifier::fromString(&vm, "after"), jsBoolean(true));
    unscopables.putDirect(vm, Identifier::fromString(&vm, "replaceWith"), jsBoolean(true));
    unscopables.putDirect(vm, Identifier::fromString(&vm, "remove"), jsBoolean(true));
    unscopables.putDirect(vm, Identifier::fromString(&vm, "prepend"), jsBoolean(true));
    unscopables.putDirect(vm, Identifier::fromString(&vm, "append"), jsBoolean(true));
    putDirectWithoutTransition(vm, vm.propertyNames->unscopablesSymbol, &unscopables, DontEnum | ReadOnly);
}

const ClassInfo JSElement::s_info = { "Element", &Base::s_info, 0, CREATE_METHOD_TABLE(JSElement) };

JSElement::JSElement(Structure* structure, JSDOMGlobalObject& globalObject, Ref<Element>&& impl)
    : JSNode(structure, globalObject, WTFMove(impl))
{
}

void JSElement::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));

}

JSObject* JSElement::createPrototype(VM& vm, JSGlobalObject* globalObject)
{
    return JSElementPrototype::create(vm, globalObject, JSElementPrototype::createStructure(vm, globalObject, JSNode::prototype(vm, globalObject)));
}

JSObject* JSElement::prototype(VM& vm, JSGlobalObject* globalObject)
{
    return getDOMPrototype<JSElement>(vm, globalObject);
}

template<> inline JSElement* BindingCaller<JSElement>::castForAttribute(ExecState&, EncodedJSValue thisValue)
{
    return jsDynamicDowncast<JSElement*>(JSValue::decode(thisValue));
}

template<> inline JSElement* BindingCaller<JSElement>::castForOperation(ExecState& state)
{
    return jsDynamicDowncast<JSElement*>(state.thisValue());
}

static inline JSValue jsElementTagNameGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementTagName(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementTagNameGetter>(state, thisValue, "tagName");
}

static inline JSValue jsElementTagNameGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLNullable<IDLDOMString>>(state, impl.tagName());
    return result;
}

static inline JSValue jsElementAttributesGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementAttributes(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementAttributesGetter>(state, thisValue, "attributes");
}

static inline JSValue jsElementAttributesGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<NamedNodeMap>>(state, *thisObject.globalObject(), impl.attributes());
    return result;
}

static inline JSValue jsElementStyleGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementStyle(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementStyleGetter>(state, thisValue, "style");
}

static inline JSValue jsElementStyleGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<CSSStyleDeclaration>>(state, *thisObject.globalObject(), impl.cssomStyle());
    return result;
}

static inline JSValue jsElementIdGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementId(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementIdGetter>(state, thisValue, "id");
}

static inline JSValue jsElementIdGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDOMString>(state, impl.getIdAttribute());
    return result;
}

static inline JSValue jsElementNamespaceURIGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementNamespaceURI(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementNamespaceURIGetter>(state, thisValue, "namespaceURI");
}

static inline JSValue jsElementNamespaceURIGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLNullable<IDLDOMString>>(state, impl.namespaceURI());
    return result;
}

static inline JSValue jsElementPrefixGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementPrefix(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementPrefixGetter>(state, thisValue, "prefix");
}

static inline JSValue jsElementPrefixGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLNullable<IDLDOMString>>(state, impl.prefix());
    return result;
}

static inline JSValue jsElementLocalNameGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementLocalName(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementLocalNameGetter>(state, thisValue, "localName");
}

static inline JSValue jsElementLocalNameGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDOMString>(state, impl.localName());
    return result;
}

static inline JSValue jsElementOffsetLeftGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOffsetLeft(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOffsetLeftGetter>(state, thisValue, "offsetLeft");
}

static inline JSValue jsElementOffsetLeftGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDouble>(impl.offsetLeft());
    return result;
}

static inline JSValue jsElementOffsetTopGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOffsetTop(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOffsetTopGetter>(state, thisValue, "offsetTop");
}

static inline JSValue jsElementOffsetTopGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDouble>(impl.offsetTop());
    return result;
}

static inline JSValue jsElementOffsetWidthGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOffsetWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOffsetWidthGetter>(state, thisValue, "offsetWidth");
}

static inline JSValue jsElementOffsetWidthGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDouble>(impl.offsetWidth());
    return result;
}

static inline JSValue jsElementOffsetHeightGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOffsetHeight(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOffsetHeightGetter>(state, thisValue, "offsetHeight");
}

static inline JSValue jsElementOffsetHeightGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDouble>(impl.offsetHeight());
    return result;
}

static inline JSValue jsElementClientLeftGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementClientLeft(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementClientLeftGetter>(state, thisValue, "clientLeft");
}

static inline JSValue jsElementClientLeftGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDouble>(impl.clientLeft());
    return result;
}

static inline JSValue jsElementClientTopGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementClientTop(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementClientTopGetter>(state, thisValue, "clientTop");
}

static inline JSValue jsElementClientTopGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDouble>(impl.clientTop());
    return result;
}

static inline JSValue jsElementClientWidthGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementClientWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementClientWidthGetter>(state, thisValue, "clientWidth");
}

static inline JSValue jsElementClientWidthGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDouble>(impl.clientWidth());
    return result;
}

static inline JSValue jsElementClientHeightGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementClientHeight(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementClientHeightGetter>(state, thisValue, "clientHeight");
}

static inline JSValue jsElementClientHeightGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDouble>(impl.clientHeight());
    return result;
}

static inline JSValue jsElementScrollLeftGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementScrollLeft(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementScrollLeftGetter>(state, thisValue, "scrollLeft");
}

static inline JSValue jsElementScrollLeftGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLLong>(impl.scrollLeft());
    return result;
}

static inline JSValue jsElementScrollTopGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementScrollTop(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementScrollTopGetter>(state, thisValue, "scrollTop");
}

static inline JSValue jsElementScrollTopGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLLong>(impl.scrollTop());
    return result;
}

static inline JSValue jsElementScrollWidthGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementScrollWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementScrollWidthGetter>(state, thisValue, "scrollWidth");
}

static inline JSValue jsElementScrollWidthGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLLong>(impl.scrollWidth());
    return result;
}

static inline JSValue jsElementScrollHeightGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementScrollHeight(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementScrollHeightGetter>(state, thisValue, "scrollHeight");
}

static inline JSValue jsElementScrollHeightGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLLong>(impl.scrollHeight());
    return result;
}

static inline JSValue jsElementOffsetParentGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOffsetParent(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOffsetParentGetter>(state, thisValue, "offsetParent");
}

static inline JSValue jsElementOffsetParentGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<Element>>(state, *thisObject.globalObject(), impl.bindingsOffsetParent());
    return result;
}

static inline JSValue jsElementInnerHTMLGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementInnerHTML(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementInnerHTMLGetter>(state, thisValue, "innerHTML");
}

static inline JSValue jsElementInnerHTMLGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDOMString>(state, impl.innerHTML());
    return result;
}

static inline JSValue jsElementOuterHTMLGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOuterHTML(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOuterHTMLGetter>(state, thisValue, "outerHTML");
}

static inline JSValue jsElementOuterHTMLGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDOMString>(state, impl.outerHTML());
    return result;
}

static inline JSValue jsElementClassNameGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementClassName(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementClassNameGetter>(state, thisValue, "className");
}

static inline JSValue jsElementClassNameGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDOMString>(state, impl.attributeWithoutSynchronization(WebCore::HTMLNames::classAttr));
    return result;
}

static inline JSValue jsElementClassListGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementClassList(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementClassListGetter>(state, thisValue, "classList");
}

static inline JSValue jsElementClassListGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<DOMTokenList>>(state, *thisObject.globalObject(), impl.classList());
    return result;
}

#if ENABLE(CSS_REGIONS)
static inline JSValue jsElementWebkitRegionOversetGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementWebkitRegionOverset(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementWebkitRegionOversetGetter>(state, thisValue, "webkitRegionOverset");
}

static inline JSValue jsElementWebkitRegionOversetGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDOMString>(state, impl.webkitRegionOverset());
    return result;
}

#endif

static inline JSValue jsElementShadowRootGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementShadowRoot(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementShadowRootGetter>(state, thisValue, "shadowRoot");
}

static inline JSValue jsElementShadowRootGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<ShadowRoot>>(state, *thisObject.globalObject(), impl.shadowRootForBindings(state));
    return result;
}

static inline JSValue jsElementSlotGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementSlot(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementSlotGetter>(state, thisValue, "slot");
}

static inline JSValue jsElementSlotGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDOMString>(state, impl.attributeWithoutSynchronization(WebCore::HTMLNames::slotAttr));
    return result;
}

static inline JSValue jsElementOnbeforecopyGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnbeforecopy(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnbeforecopyGetter>(state, thisValue, "onbeforecopy");
}

static inline JSValue jsElementOnbeforecopyGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().beforecopyEvent);
}

static inline JSValue jsElementOnbeforecutGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnbeforecut(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnbeforecutGetter>(state, thisValue, "onbeforecut");
}

static inline JSValue jsElementOnbeforecutGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().beforecutEvent);
}

static inline JSValue jsElementOnbeforeinputGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnbeforeinput(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnbeforeinputGetter>(state, thisValue, "onbeforeinput");
}

static inline JSValue jsElementOnbeforeinputGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().beforeinputEvent);
}

static inline JSValue jsElementOnbeforepasteGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnbeforepaste(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnbeforepasteGetter>(state, thisValue, "onbeforepaste");
}

static inline JSValue jsElementOnbeforepasteGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().beforepasteEvent);
}

static inline JSValue jsElementOncopyGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOncopy(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOncopyGetter>(state, thisValue, "oncopy");
}

static inline JSValue jsElementOncopyGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().copyEvent);
}

static inline JSValue jsElementOncutGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOncut(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOncutGetter>(state, thisValue, "oncut");
}

static inline JSValue jsElementOncutGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().cutEvent);
}

static inline JSValue jsElementOnpasteGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnpaste(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnpasteGetter>(state, thisValue, "onpaste");
}

static inline JSValue jsElementOnpasteGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().pasteEvent);
}

static inline JSValue jsElementOnselectstartGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnselectstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnselectstartGetter>(state, thisValue, "onselectstart");
}

static inline JSValue jsElementOnselectstartGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().selectstartEvent);
}

#if ENABLE(FULLSCREEN_API)
static inline JSValue jsElementOnwebkitfullscreenchangeGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnwebkitfullscreenchange(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnwebkitfullscreenchangeGetter>(state, thisValue, "onwebkitfullscreenchange");
}

static inline JSValue jsElementOnwebkitfullscreenchangeGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().webkitfullscreenchangeEvent);
}

#endif

#if ENABLE(FULLSCREEN_API)
static inline JSValue jsElementOnwebkitfullscreenerrorGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnwebkitfullscreenerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnwebkitfullscreenerrorGetter>(state, thisValue, "onwebkitfullscreenerror");
}

static inline JSValue jsElementOnwebkitfullscreenerrorGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().webkitfullscreenerrorEvent);
}

#endif

static inline JSValue jsElementOnanimationendGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnanimationend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnanimationendGetter>(state, thisValue, "onanimationend");
}

static inline JSValue jsElementOnanimationendGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().animationendEvent);
}

static inline JSValue jsElementOnanimationiterationGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnanimationiteration(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnanimationiterationGetter>(state, thisValue, "onanimationiteration");
}

static inline JSValue jsElementOnanimationiterationGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().animationiterationEvent);
}

static inline JSValue jsElementOnanimationstartGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnanimationstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnanimationstartGetter>(state, thisValue, "onanimationstart");
}

static inline JSValue jsElementOnanimationstartGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().animationstartEvent);
}

static inline JSValue jsElementOntransitionendGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOntransitionend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOntransitionendGetter>(state, thisValue, "ontransitionend");
}

static inline JSValue jsElementOntransitionendGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().transitionendEvent);
}

static inline JSValue jsElementOnwebkitanimationendGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnwebkitanimationend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnwebkitanimationendGetter>(state, thisValue, "onwebkitanimationend");
}

static inline JSValue jsElementOnwebkitanimationendGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().webkitAnimationEndEvent);
}

static inline JSValue jsElementOnwebkitanimationiterationGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnwebkitanimationiteration(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnwebkitanimationiterationGetter>(state, thisValue, "onwebkitanimationiteration");
}

static inline JSValue jsElementOnwebkitanimationiterationGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().webkitAnimationIterationEvent);
}

static inline JSValue jsElementOnwebkitanimationstartGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnwebkitanimationstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnwebkitanimationstartGetter>(state, thisValue, "onwebkitanimationstart");
}

static inline JSValue jsElementOnwebkitanimationstartGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().webkitAnimationStartEvent);
}

static inline JSValue jsElementOnwebkittransitionendGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnwebkittransitionend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnwebkittransitionendGetter>(state, thisValue, "onwebkittransitionend");
}

static inline JSValue jsElementOnwebkittransitionendGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().webkitTransitionEndEvent);
}

#if ENABLE(IOS_GESTURE_EVENTS)
static inline JSValue jsElementOngesturechangeGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOngesturechange(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOngesturechangeGetter>(state, thisValue, "ongesturechange");
}

static inline JSValue jsElementOngesturechangeGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().gesturechangeEvent);
}

#endif

#if ENABLE(IOS_GESTURE_EVENTS)
static inline JSValue jsElementOngestureendGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOngestureend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOngestureendGetter>(state, thisValue, "ongestureend");
}

static inline JSValue jsElementOngestureendGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().gestureendEvent);
}

#endif

#if ENABLE(IOS_GESTURE_EVENTS)
static inline JSValue jsElementOngesturestartGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOngesturestart(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOngesturestartGetter>(state, thisValue, "ongesturestart");
}

static inline JSValue jsElementOngesturestartGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().gesturestartEvent);
}

#endif

static inline JSValue jsElementOnfocusinGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnfocusin(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnfocusinGetter>(state, thisValue, "onfocusin");
}

static inline JSValue jsElementOnfocusinGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().focusinEvent);
}

static inline JSValue jsElementOnfocusoutGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnfocusout(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnfocusoutGetter>(state, thisValue, "onfocusout");
}

static inline JSValue jsElementOnfocusoutGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().focusoutEvent);
}

static inline JSValue jsElementOnbeforeloadGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnbeforeload(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnbeforeloadGetter>(state, thisValue, "onbeforeload");
}

static inline JSValue jsElementOnbeforeloadGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().beforeloadEvent);
}

#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
static inline JSValue jsElementOnwebkitneedkeyGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnwebkitneedkey(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnwebkitneedkeyGetter>(state, thisValue, "onwebkitneedkey");
}

static inline JSValue jsElementOnwebkitneedkeyGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().webkitneedkeyEvent);
}

#endif

#if ENABLE(VIDEO_PRESENTATION_MODE)
static inline JSValue jsElementOnwebkitpresentationmodechangedGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnwebkitpresentationmodechanged(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnwebkitpresentationmodechangedGetter>(state, thisValue, "onwebkitpresentationmodechanged");
}

static inline JSValue jsElementOnwebkitpresentationmodechangedGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().webkitpresentationmodechangedEvent);
}

#endif

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
static inline JSValue jsElementOnwebkitcurrentplaybacktargetiswirelesschangedGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnwebkitcurrentplaybacktargetiswirelesschanged(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnwebkitcurrentplaybacktargetiswirelesschangedGetter>(state, thisValue, "onwebkitcurrentplaybacktargetiswirelesschanged");
}

static inline JSValue jsElementOnwebkitcurrentplaybacktargetiswirelesschangedGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent);
}

#endif

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
static inline JSValue jsElementOnwebkitplaybacktargetavailabilitychangedGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementOnwebkitplaybacktargetavailabilitychanged(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementOnwebkitplaybacktargetavailabilitychangedGetter>(state, thisValue, "onwebkitplaybacktargetavailabilitychanged");
}

static inline JSValue jsElementOnwebkitplaybacktargetavailabilitychangedGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    return eventHandlerAttribute(thisObject.wrapped(), eventNames().webkitplaybacktargetavailabilitychangedEvent);
}

#endif

static inline JSValue jsElementPreviousElementSiblingGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementPreviousElementSibling(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementPreviousElementSiblingGetter>(state, thisValue, "previousElementSibling");
}

static inline JSValue jsElementPreviousElementSiblingGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<Element>>(state, *thisObject.globalObject(), impl.previousElementSibling());
    return result;
}

static inline JSValue jsElementNextElementSiblingGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementNextElementSibling(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementNextElementSiblingGetter>(state, thisValue, "nextElementSibling");
}

static inline JSValue jsElementNextElementSiblingGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<Element>>(state, *thisObject.globalObject(), impl.nextElementSibling());
    return result;
}

static inline JSValue jsElementChildrenGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementChildren(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementChildrenGetter>(state, thisValue, "children");
}

static inline JSValue jsElementChildrenGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<HTMLCollection>>(state, *thisObject.globalObject(), impl.children());
    return result;
}

static inline JSValue jsElementFirstElementChildGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementFirstElementChild(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementFirstElementChildGetter>(state, thisValue, "firstElementChild");
}

static inline JSValue jsElementFirstElementChildGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<Element>>(state, *thisObject.globalObject(), impl.firstElementChild());
    return result;
}

static inline JSValue jsElementLastElementChildGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementLastElementChild(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementLastElementChildGetter>(state, thisValue, "lastElementChild");
}

static inline JSValue jsElementLastElementChildGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<Element>>(state, *thisObject.globalObject(), impl.lastElementChild());
    return result;
}

static inline JSValue jsElementChildElementCountGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementChildElementCount(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementChildElementCountGetter>(state, thisValue, "childElementCount");
}

static inline JSValue jsElementChildElementCountGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnsignedLong>(impl.childElementCount());
    return result;
}

static inline JSValue jsElementAssignedSlotGetter(ExecState&, JSElement&, ThrowScope& throwScope);

EncodedJSValue jsElementAssignedSlot(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSElement>::attribute<jsElementAssignedSlotGetter>(state, thisValue, "assignedSlot");
}

static inline JSValue jsElementAssignedSlotGetter(ExecState& state, JSElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLNullable<IDLInterface<HTMLSlotElement>>>(state, *thisObject.globalObject(), impl.assignedSlotForBindings());
    return result;
}

EncodedJSValue jsElementConstructor(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSElementPrototype* domObject = jsDynamicDowncast<JSElementPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject))
        return throwVMTypeError(state, throwScope);
    return JSValue::encode(JSElement::getConstructor(state->vm(), domObject->globalObject()));
}

bool setJSElementConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSValue value = JSValue::decode(encodedValue);
    JSElementPrototype* domObject = jsDynamicDowncast<JSElementPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject)) {
        throwVMTypeError(state, throwScope);
        return false;
    }
    // Shadowing a built-in constructor
    return domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
}

static inline bool setJSElementIdFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementId(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementIdFunction>(state, thisValue, encodedValue, "id");
}

static inline bool setJSElementIdFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    CustomElementReactionStack customElementReactionStack;
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLDOMString>(state, value, StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::idAttr, WTFMove(nativeValue));
    return true;
}


static inline bool setJSElementScrollLeftFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementScrollLeft(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementScrollLeftFunction>(state, thisValue, encodedValue, "scrollLeft");
}

static inline bool setJSElementScrollLeftFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLLong>(state, value, IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setScrollLeft(WTFMove(nativeValue));
    return true;
}


static inline bool setJSElementScrollTopFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementScrollTop(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementScrollTopFunction>(state, thisValue, encodedValue, "scrollTop");
}

static inline bool setJSElementScrollTopFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLLong>(state, value, IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setScrollTop(WTFMove(nativeValue));
    return true;
}


static inline bool setJSElementInnerHTMLFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementInnerHTML(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementInnerHTMLFunction>(state, thisValue, encodedValue, "innerHTML");
}

static inline bool setJSElementInnerHTMLFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    CustomElementReactionStack customElementReactionStack;
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLDOMString>(state, value, StringConversionConfiguration::TreatNullAsEmptyString);
    RETURN_IF_EXCEPTION(throwScope, false);
    propagateException(state, throwScope, impl.setInnerHTML(WTFMove(nativeValue)));
    return true;
}


static inline bool setJSElementOuterHTMLFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOuterHTML(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOuterHTMLFunction>(state, thisValue, encodedValue, "outerHTML");
}

static inline bool setJSElementOuterHTMLFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    CustomElementReactionStack customElementReactionStack;
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLDOMString>(state, value, StringConversionConfiguration::TreatNullAsEmptyString);
    RETURN_IF_EXCEPTION(throwScope, false);
    propagateException(state, throwScope, impl.setOuterHTML(WTFMove(nativeValue)));
    return true;
}


static inline bool setJSElementClassNameFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementClassName(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementClassNameFunction>(state, thisValue, encodedValue, "className");
}

static inline bool setJSElementClassNameFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    CustomElementReactionStack customElementReactionStack;
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLDOMString>(state, value, StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::classAttr, WTFMove(nativeValue));
    return true;
}


static inline bool setJSElementClassListFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementClassList(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementClassListFunction>(state, thisValue, encodedValue, "classList");
}

static inline bool setJSElementClassListFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    CustomElementReactionStack customElementReactionStack;
    Ref<DOMTokenList> forwardedImpl = thisObject.wrapped().classList();
    auto& impl = forwardedImpl.get();
    auto nativeValue = convert<IDLDOMString>(state, value, StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setValue(WTFMove(nativeValue));
    return true;
}


static inline bool setJSElementSlotFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementSlot(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementSlotFunction>(state, thisValue, encodedValue, "slot");
}

static inline bool setJSElementSlotFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    CustomElementReactionStack customElementReactionStack;
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLDOMString>(state, value, StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::slotAttr, WTFMove(nativeValue));
    return true;
}


static inline bool setJSElementOnbeforecopyFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnbeforecopy(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnbeforecopyFunction>(state, thisValue, encodedValue, "onbeforecopy");
}

static inline bool setJSElementOnbeforecopyFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().beforecopyEvent, value);
    return true;
}


static inline bool setJSElementOnbeforecutFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnbeforecut(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnbeforecutFunction>(state, thisValue, encodedValue, "onbeforecut");
}

static inline bool setJSElementOnbeforecutFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().beforecutEvent, value);
    return true;
}


static inline bool setJSElementOnbeforeinputFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnbeforeinput(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnbeforeinputFunction>(state, thisValue, encodedValue, "onbeforeinput");
}

static inline bool setJSElementOnbeforeinputFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().beforeinputEvent, value);
    return true;
}


static inline bool setJSElementOnbeforepasteFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnbeforepaste(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnbeforepasteFunction>(state, thisValue, encodedValue, "onbeforepaste");
}

static inline bool setJSElementOnbeforepasteFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().beforepasteEvent, value);
    return true;
}


static inline bool setJSElementOncopyFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOncopy(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOncopyFunction>(state, thisValue, encodedValue, "oncopy");
}

static inline bool setJSElementOncopyFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().copyEvent, value);
    return true;
}


static inline bool setJSElementOncutFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOncut(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOncutFunction>(state, thisValue, encodedValue, "oncut");
}

static inline bool setJSElementOncutFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().cutEvent, value);
    return true;
}


static inline bool setJSElementOnpasteFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnpaste(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnpasteFunction>(state, thisValue, encodedValue, "onpaste");
}

static inline bool setJSElementOnpasteFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().pasteEvent, value);
    return true;
}


static inline bool setJSElementOnselectstartFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnselectstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnselectstartFunction>(state, thisValue, encodedValue, "onselectstart");
}

static inline bool setJSElementOnselectstartFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().selectstartEvent, value);
    return true;
}


#if ENABLE(FULLSCREEN_API)
static inline bool setJSElementOnwebkitfullscreenchangeFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnwebkitfullscreenchange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnwebkitfullscreenchangeFunction>(state, thisValue, encodedValue, "onwebkitfullscreenchange");
}

static inline bool setJSElementOnwebkitfullscreenchangeFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().webkitfullscreenchangeEvent, value);
    return true;
}

#endif

#if ENABLE(FULLSCREEN_API)
static inline bool setJSElementOnwebkitfullscreenerrorFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnwebkitfullscreenerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnwebkitfullscreenerrorFunction>(state, thisValue, encodedValue, "onwebkitfullscreenerror");
}

static inline bool setJSElementOnwebkitfullscreenerrorFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().webkitfullscreenerrorEvent, value);
    return true;
}

#endif

static inline bool setJSElementOnanimationendFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnanimationend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnanimationendFunction>(state, thisValue, encodedValue, "onanimationend");
}

static inline bool setJSElementOnanimationendFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().animationendEvent, value);
    return true;
}


static inline bool setJSElementOnanimationiterationFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnanimationiteration(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnanimationiterationFunction>(state, thisValue, encodedValue, "onanimationiteration");
}

static inline bool setJSElementOnanimationiterationFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().animationiterationEvent, value);
    return true;
}


static inline bool setJSElementOnanimationstartFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnanimationstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnanimationstartFunction>(state, thisValue, encodedValue, "onanimationstart");
}

static inline bool setJSElementOnanimationstartFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().animationstartEvent, value);
    return true;
}


static inline bool setJSElementOntransitionendFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOntransitionend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOntransitionendFunction>(state, thisValue, encodedValue, "ontransitionend");
}

static inline bool setJSElementOntransitionendFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().transitionendEvent, value);
    return true;
}


static inline bool setJSElementOnwebkitanimationendFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnwebkitanimationend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnwebkitanimationendFunction>(state, thisValue, encodedValue, "onwebkitanimationend");
}

static inline bool setJSElementOnwebkitanimationendFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().webkitAnimationEndEvent, value);
    return true;
}


static inline bool setJSElementOnwebkitanimationiterationFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnwebkitanimationiteration(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnwebkitanimationiterationFunction>(state, thisValue, encodedValue, "onwebkitanimationiteration");
}

static inline bool setJSElementOnwebkitanimationiterationFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().webkitAnimationIterationEvent, value);
    return true;
}


static inline bool setJSElementOnwebkitanimationstartFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnwebkitanimationstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnwebkitanimationstartFunction>(state, thisValue, encodedValue, "onwebkitanimationstart");
}

static inline bool setJSElementOnwebkitanimationstartFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().webkitAnimationStartEvent, value);
    return true;
}


static inline bool setJSElementOnwebkittransitionendFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnwebkittransitionend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnwebkittransitionendFunction>(state, thisValue, encodedValue, "onwebkittransitionend");
}

static inline bool setJSElementOnwebkittransitionendFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().webkitTransitionEndEvent, value);
    return true;
}


#if ENABLE(IOS_GESTURE_EVENTS)
static inline bool setJSElementOngesturechangeFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOngesturechange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOngesturechangeFunction>(state, thisValue, encodedValue, "ongesturechange");
}

static inline bool setJSElementOngesturechangeFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().gesturechangeEvent, value);
    return true;
}

#endif

#if ENABLE(IOS_GESTURE_EVENTS)
static inline bool setJSElementOngestureendFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOngestureend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOngestureendFunction>(state, thisValue, encodedValue, "ongestureend");
}

static inline bool setJSElementOngestureendFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().gestureendEvent, value);
    return true;
}

#endif

#if ENABLE(IOS_GESTURE_EVENTS)
static inline bool setJSElementOngesturestartFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOngesturestart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOngesturestartFunction>(state, thisValue, encodedValue, "ongesturestart");
}

static inline bool setJSElementOngesturestartFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().gesturestartEvent, value);
    return true;
}

#endif

static inline bool setJSElementOnfocusinFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnfocusin(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnfocusinFunction>(state, thisValue, encodedValue, "onfocusin");
}

static inline bool setJSElementOnfocusinFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().focusinEvent, value);
    return true;
}


static inline bool setJSElementOnfocusoutFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnfocusout(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnfocusoutFunction>(state, thisValue, encodedValue, "onfocusout");
}

static inline bool setJSElementOnfocusoutFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().focusoutEvent, value);
    return true;
}


static inline bool setJSElementOnbeforeloadFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnbeforeload(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnbeforeloadFunction>(state, thisValue, encodedValue, "onbeforeload");
}

static inline bool setJSElementOnbeforeloadFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().beforeloadEvent, value);
    return true;
}


#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
static inline bool setJSElementOnwebkitneedkeyFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnwebkitneedkey(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnwebkitneedkeyFunction>(state, thisValue, encodedValue, "onwebkitneedkey");
}

static inline bool setJSElementOnwebkitneedkeyFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().webkitneedkeyEvent, value);
    return true;
}

#endif

#if ENABLE(VIDEO_PRESENTATION_MODE)
static inline bool setJSElementOnwebkitpresentationmodechangedFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnwebkitpresentationmodechanged(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnwebkitpresentationmodechangedFunction>(state, thisValue, encodedValue, "onwebkitpresentationmodechanged");
}

static inline bool setJSElementOnwebkitpresentationmodechangedFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().webkitpresentationmodechangedEvent, value);
    return true;
}

#endif

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
static inline bool setJSElementOnwebkitcurrentplaybacktargetiswirelesschangedFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnwebkitcurrentplaybacktargetiswirelesschanged(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnwebkitcurrentplaybacktargetiswirelesschangedFunction>(state, thisValue, encodedValue, "onwebkitcurrentplaybacktargetiswirelesschanged");
}

static inline bool setJSElementOnwebkitcurrentplaybacktargetiswirelesschangedFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent, value);
    return true;
}

#endif

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
static inline bool setJSElementOnwebkitplaybacktargetavailabilitychangedFunction(ExecState&, JSElement&, JSValue, ThrowScope&);

bool setJSElementOnwebkitplaybacktargetavailabilitychanged(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSElement>::setAttribute<setJSElementOnwebkitplaybacktargetavailabilitychangedFunction>(state, thisValue, encodedValue, "onwebkitplaybacktargetavailabilitychanged");
}

static inline bool setJSElementOnwebkitplaybacktargetavailabilitychangedFunction(ExecState& state, JSElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    setEventHandlerAttribute(state, thisObject, thisObject.wrapped(), eventNames().webkitplaybacktargetavailabilitychangedEvent, value);
    return true;
}

#endif

JSValue JSElement::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSElementConstructor>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetAttributeCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttribute(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionGetAttributeCaller>(state, "getAttribute");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetAttributeCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto name = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLDOMString>>(*state, impl.getAttribute(WTFMove(name))));
}

JSC::EncodedJSValue JIT_OPERATION unsafeJsElementPrototypeFunctionGetAttribute(JSC::ExecState* state, JSElement* castedThis, DOMJIT::IDLJSArgumentType<IDLDOMString> encodedName)
{
    UNUSED_PARAM(state);
    VM& vm = state->vm();
    JSC::NativeCallFrameTracer tracer(&vm, state);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto name = DOMJIT::DirectConverter<IDLDOMString>::directConvert<StringConversionConfiguration::Normal>(*state, encodedName);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLDOMString>>(*state, impl.getAttribute(WTFMove(name))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionSetAttributeCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttribute(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionSetAttributeCaller>(state, "setAttribute");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionSetAttributeCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto name = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    propagateException(*state, throwScope, impl.setAttribute(WTFMove(name), WTFMove(value)));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionRemoveAttributeCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttribute(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionRemoveAttributeCaller>(state, "removeAttribute");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionRemoveAttributeCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto name = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.removeAttribute(WTFMove(name));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetAttributeNodeCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNode(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionGetAttributeNodeCaller>(state, "getAttributeNode");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetAttributeNodeCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto name = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLInterface<Attr>>>(*state, *castedThis->globalObject(), impl.getAttributeNode(WTFMove(name))));
}

JSC::EncodedJSValue JIT_OPERATION unsafeJsElementPrototypeFunctionGetAttributeNode(JSC::ExecState* state, JSElement* castedThis, DOMJIT::IDLJSArgumentType<IDLDOMString> encodedName)
{
    UNUSED_PARAM(state);
    VM& vm = state->vm();
    JSC::NativeCallFrameTracer tracer(&vm, state);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto name = DOMJIT::DirectConverter<IDLDOMString>::directConvert<StringConversionConfiguration::Normal>(*state, encodedName);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLInterface<Attr>>>(*state, *castedThis->globalObject(), impl.getAttributeNode(WTFMove(name))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionSetAttributeNodeCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNode(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionSetAttributeNodeCaller>(state, "setAttributeNode");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionSetAttributeNodeCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto newAttr = convert<IDLInterface<Attr>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "newAttr", "Element", "setAttributeNode", "Attr"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLInterface<Attr>>>(*state, *castedThis->globalObject(), throwScope, impl.setAttributeNode(*newAttr)));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionRemoveAttributeNodeCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttributeNode(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionRemoveAttributeNodeCaller>(state, "removeAttributeNode");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionRemoveAttributeNodeCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto oldAttr = convert<IDLInterface<Attr>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "oldAttr", "Element", "removeAttributeNode", "Attr"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<Attr>>(*state, *castedThis->globalObject(), throwScope, impl.removeAttributeNode(*oldAttr)));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetElementsByTagNameCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByTagName(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionGetElementsByTagNameCaller>(state, "getElementsByTagName");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetElementsByTagNameCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto name = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<HTMLCollection>>(*state, *castedThis->globalObject(), impl.getElementsByTagName(WTFMove(name))));
}

JSC::EncodedJSValue JIT_OPERATION unsafeJsElementPrototypeFunctionGetElementsByTagName(JSC::ExecState* state, JSElement* castedThis, DOMJIT::IDLJSArgumentType<IDLDOMString> encodedName)
{
    UNUSED_PARAM(state);
    VM& vm = state->vm();
    JSC::NativeCallFrameTracer tracer(&vm, state);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto name = DOMJIT::DirectConverter<IDLDOMString>::directConvert<StringConversionConfiguration::Normal>(*state, encodedName);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<HTMLCollection>>(*state, *castedThis->globalObject(), impl.getElementsByTagName(WTFMove(name))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionHasAttributesCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttributes(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionHasAttributesCaller>(state, "hasAttributes");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionHasAttributesCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLBoolean>(impl.hasAttributes()));
}

JSC::EncodedJSValue JIT_OPERATION unsafeJsElementPrototypeFunctionHasAttributes(JSC::ExecState* state, JSElement* castedThis)
{
    UNUSED_PARAM(state);
    VM& vm = state->vm();
    JSC::NativeCallFrameTracer tracer(&vm, state);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLBoolean>(impl.hasAttributes()));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetAttributeNSCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNS(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionGetAttributeNSCaller>(state, "getAttributeNS");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetAttributeNSCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto namespaceURI = convert<IDLNullable<IDLDOMString>>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto localName = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLDOMString>>(*state, impl.getAttributeNS(WTFMove(namespaceURI), WTFMove(localName))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionSetAttributeNSCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNS(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionSetAttributeNSCaller>(state, "setAttributeNS");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionSetAttributeNSCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto namespaceURI = convert<IDLNullable<IDLDOMString>>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto qualifiedName = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLDOMString>(*state, state->uncheckedArgument(2), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    propagateException(*state, throwScope, impl.setAttributeNS(WTFMove(namespaceURI), WTFMove(qualifiedName), WTFMove(value)));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionRemoveAttributeNSCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttributeNS(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionRemoveAttributeNSCaller>(state, "removeAttributeNS");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionRemoveAttributeNSCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto namespaceURI = convert<IDLNullable<IDLDOMString>>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto localName = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.removeAttributeNS(WTFMove(namespaceURI), WTFMove(localName));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetElementsByTagNameNSCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByTagNameNS(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionGetElementsByTagNameNSCaller>(state, "getElementsByTagNameNS");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetElementsByTagNameNSCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto namespaceURI = convert<IDLNullable<IDLDOMString>>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto localName = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<HTMLCollection>>(*state, *castedThis->globalObject(), impl.getElementsByTagNameNS(WTFMove(namespaceURI), WTFMove(localName))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetAttributeNodeNSCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNodeNS(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionGetAttributeNodeNSCaller>(state, "getAttributeNodeNS");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetAttributeNodeNSCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto namespaceURI = convert<IDLNullable<IDLDOMString>>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto localName = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLInterface<Attr>>>(*state, *castedThis->globalObject(), impl.getAttributeNodeNS(WTFMove(namespaceURI), WTFMove(localName))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionSetAttributeNodeNSCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNodeNS(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionSetAttributeNodeNSCaller>(state, "setAttributeNodeNS");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionSetAttributeNodeNSCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto newAttr = convert<IDLInterface<Attr>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "newAttr", "Element", "setAttributeNodeNS", "Attr"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLInterface<Attr>>>(*state, *castedThis->globalObject(), throwScope, impl.setAttributeNodeNS(*newAttr)));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionHasAttributeCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttribute(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionHasAttributeCaller>(state, "hasAttribute");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionHasAttributeCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto name = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.hasAttribute(WTFMove(name))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionHasAttributeNSCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttributeNS(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionHasAttributeNSCaller>(state, "hasAttributeNS");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionHasAttributeNSCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto namespaceURI = convert<IDLNullable<IDLDOMString>>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto localName = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.hasAttributeNS(WTFMove(namespaceURI), WTFMove(localName))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollIntoViewCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollIntoView(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionScrollIntoViewCaller>(state, "scrollIntoView");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollIntoViewCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto alignWithTop = state->argument(0).isUndefined() ? true : convert<IDLBoolean>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.scrollIntoView(WTFMove(alignWithTop));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollIntoViewIfNeededCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollIntoViewIfNeeded(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionScrollIntoViewIfNeededCaller>(state, "scrollIntoViewIfNeeded");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollIntoViewIfNeededCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto centerIfNeeded = state->argument(0).isUndefined() ? true : convert<IDLBoolean>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.scrollIntoViewIfNeeded(WTFMove(centerIfNeeded));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScroll1Caller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

static inline EncodedJSValue jsElementPrototypeFunctionScroll1(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionScroll1Caller>(state, "scroll");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScroll1Caller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto options = convert<IDLDictionary<ScrollToOptions>>(*state, state->argument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.scrollTo(WTFMove(options));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScroll2Caller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

static inline EncodedJSValue jsElementPrototypeFunctionScroll2(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionScroll2Caller>(state, "scroll");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScroll2Caller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto x = convert<IDLUnrestrictedDouble>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLUnrestrictedDouble>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.scrollTo(WTFMove(x), WTFMove(y));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScroll(ExecState* state)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    size_t argsCount = std::min<size_t>(2, state->argumentCount());
    if (argsCount == 0) {
        return jsElementPrototypeFunctionScroll1(state);
    }
    if (argsCount == 1) {
        return jsElementPrototypeFunctionScroll1(state);
    }
    if (argsCount == 2) {
        return jsElementPrototypeFunctionScroll2(state);
    }
    return throwVMTypeError(state, throwScope);
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollTo1Caller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

static inline EncodedJSValue jsElementPrototypeFunctionScrollTo1(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionScrollTo1Caller>(state, "scrollTo");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollTo1Caller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto options = convert<IDLDictionary<ScrollToOptions>>(*state, state->argument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.scrollTo(WTFMove(options));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollTo2Caller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

static inline EncodedJSValue jsElementPrototypeFunctionScrollTo2(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionScrollTo2Caller>(state, "scrollTo");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollTo2Caller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto x = convert<IDLUnrestrictedDouble>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLUnrestrictedDouble>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.scrollTo(WTFMove(x), WTFMove(y));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollTo(ExecState* state)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    size_t argsCount = std::min<size_t>(2, state->argumentCount());
    if (argsCount == 0) {
        return jsElementPrototypeFunctionScrollTo1(state);
    }
    if (argsCount == 1) {
        return jsElementPrototypeFunctionScrollTo1(state);
    }
    if (argsCount == 2) {
        return jsElementPrototypeFunctionScrollTo2(state);
    }
    return throwVMTypeError(state, throwScope);
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollBy1Caller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

static inline EncodedJSValue jsElementPrototypeFunctionScrollBy1(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionScrollBy1Caller>(state, "scrollBy");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollBy1Caller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto option = convert<IDLDictionary<ScrollToOptions>>(*state, state->argument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.scrollBy(WTFMove(option));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollBy2Caller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

static inline EncodedJSValue jsElementPrototypeFunctionScrollBy2(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionScrollBy2Caller>(state, "scrollBy");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollBy2Caller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto x = convert<IDLUnrestrictedDouble>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLUnrestrictedDouble>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.scrollBy(WTFMove(x), WTFMove(y));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollBy(ExecState* state)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    size_t argsCount = std::min<size_t>(2, state->argumentCount());
    if (argsCount == 0) {
        return jsElementPrototypeFunctionScrollBy1(state);
    }
    if (argsCount == 1) {
        return jsElementPrototypeFunctionScrollBy1(state);
    }
    if (argsCount == 2) {
        return jsElementPrototypeFunctionScrollBy2(state);
    }
    return throwVMTypeError(state, throwScope);
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollByLinesCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollByLines(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionScrollByLinesCaller>(state, "scrollByLines");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollByLinesCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto lines = convert<IDLLong>(*state, state->argument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.scrollByLines(WTFMove(lines));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollByPagesCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollByPages(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionScrollByPagesCaller>(state, "scrollByPages");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionScrollByPagesCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto pages = convert<IDLLong>(*state, state->argument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.scrollByPages(WTFMove(pages));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetAttributeNamesCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNames(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionGetAttributeNamesCaller>(state, "getAttributeNames");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetAttributeNamesCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLSequence<IDLDOMString>>(*state, *castedThis->globalObject(), impl.getAttributeNames()));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetElementsByClassNameCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByClassName(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionGetElementsByClassNameCaller>(state, "getElementsByClassName");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetElementsByClassNameCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto name = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<HTMLCollection>>(*state, *castedThis->globalObject(), impl.getElementsByClassName(WTFMove(name))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionMatchesCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionMatches(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionMatchesCaller>(state, "matches");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionMatchesCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto selectors = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(*state, throwScope, impl.matches(WTFMove(selectors))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionClosestCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionClosest(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionClosestCaller>(state, "closest");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionClosestCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto selectors = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLInterface<Element>>>(*state, *castedThis->globalObject(), throwScope, impl.closest(WTFMove(selectors))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionWebkitMatchesSelectorCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitMatchesSelector(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionWebkitMatchesSelectorCaller>(state, "webkitMatchesSelector");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionWebkitMatchesSelectorCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto selectors = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(*state, throwScope, impl.matches(WTFMove(selectors))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetClientRectsCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetClientRects(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionGetClientRectsCaller>(state, "getClientRects");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetClientRectsCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLInterface<ClientRectList>>(*state, *castedThis->globalObject(), impl.getClientRects()));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetBoundingClientRectCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetBoundingClientRect(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionGetBoundingClientRectCaller>(state, "getBoundingClientRect");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetBoundingClientRectCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLInterface<ClientRect>>(*state, *castedThis->globalObject(), impl.getBoundingClientRect()));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionWebkitRequestFullScreenCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitRequestFullScreen(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionWebkitRequestFullScreenCaller>(state, "webkitRequestFullScreen");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionWebkitRequestFullScreenCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.webkitRequestFullscreen();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionWebkitRequestFullscreenCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitRequestFullscreen(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionWebkitRequestFullscreenCaller>(state, "webkitRequestFullscreen");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionWebkitRequestFullscreenCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.webkitRequestFullscreen();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionInsertAdjacentElementCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionInsertAdjacentElement(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionInsertAdjacentElementCaller>(state, "insertAdjacentElement");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionInsertAdjacentElementCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto where = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto element = convert<IDLInterface<Element>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "element", "Element", "insertAdjacentElement", "Element"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLInterface<Element>>>(*state, *castedThis->globalObject(), throwScope, impl.insertAdjacentElement(WTFMove(where), *element)));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionInsertAdjacentHTMLCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionInsertAdjacentHTML(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionInsertAdjacentHTMLCaller>(state, "insertAdjacentHTML");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionInsertAdjacentHTMLCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto where = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto html = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    propagateException(*state, throwScope, impl.insertAdjacentHTML(WTFMove(where), WTFMove(html)));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionInsertAdjacentTextCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionInsertAdjacentText(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionInsertAdjacentTextCaller>(state, "insertAdjacentText");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionInsertAdjacentTextCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto where = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto text = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    propagateException(*state, throwScope, impl.insertAdjacentText(WTFMove(where), WTFMove(text)));
    return JSValue::encode(jsUndefined());
}

#if ENABLE(POINTER_LOCK)
static inline JSC::EncodedJSValue jsElementPrototypeFunctionRequestPointerLockCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRequestPointerLock(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionRequestPointerLockCaller>(state, "requestPointerLock");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionRequestPointerLockCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.requestPointerLock();
    return JSValue::encode(jsUndefined());
}

#endif

#if ENABLE(CSS_REGIONS)
static inline JSC::EncodedJSValue jsElementPrototypeFunctionWebkitGetRegionFlowRangesCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitGetRegionFlowRanges(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionWebkitGetRegionFlowRangesCaller>(state, "webkitGetRegionFlowRanges");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionWebkitGetRegionFlowRangesCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLSequence<IDLInterface<Range>>>(*state, *castedThis->globalObject(), impl.webkitGetRegionFlowRanges()));
}

#endif

static inline JSC::EncodedJSValue jsElementPrototypeFunctionAttachShadowCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAttachShadow(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionAttachShadowCaller>(state, "attachShadow");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionAttachShadowCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto init = convert<IDLDictionary<Element::ShadowRootInit>>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<ShadowRoot>>(*state, *castedThis->globalObject(), throwScope, impl.attachShadow(WTFMove(init))));
}

#if ENABLE(WEB_ANIMATIONS)
static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetAnimationsCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAnimations(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionGetAnimationsCaller>(state, "getAnimations");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionGetAnimationsCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLSequence<IDLInterface<WebAnimation>>>(*state, *castedThis->globalObject(), impl.getAnimations()));
}

#endif

static inline JSC::EncodedJSValue jsElementPrototypeFunctionBeforeCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionBefore(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionBeforeCaller>(state, "before");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionBeforeCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto nodes = convertVariadicArguments<IDLUnion<IDLInterface<Node>, IDLDOMString>>(*state, 0);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    propagateException(*state, throwScope, impl.before(WTFMove(nodes.arguments.value())));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionAfterCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAfter(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionAfterCaller>(state, "after");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionAfterCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto nodes = convertVariadicArguments<IDLUnion<IDLInterface<Node>, IDLDOMString>>(*state, 0);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    propagateException(*state, throwScope, impl.after(WTFMove(nodes.arguments.value())));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionReplaceWithCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionReplaceWith(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionReplaceWithCaller>(state, "replaceWith");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionReplaceWithCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto nodes = convertVariadicArguments<IDLUnion<IDLInterface<Node>, IDLDOMString>>(*state, 0);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    propagateException(*state, throwScope, impl.replaceWith(WTFMove(nodes.arguments.value())));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionRemoveCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemove(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionRemoveCaller>(state, "remove");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionRemoveCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    propagateException(*state, throwScope, impl.remove());
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionPrependCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionPrepend(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionPrependCaller>(state, "prepend");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionPrependCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto nodes = convertVariadicArguments<IDLUnion<IDLInterface<Node>, IDLDOMString>>(*state, 0);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    propagateException(*state, throwScope, impl.prepend(WTFMove(nodes.arguments.value())));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionAppendCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAppend(ExecState* state)
{
    CustomElementReactionStack customElementReactionStack;
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionAppendCaller>(state, "append");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionAppendCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto nodes = convertVariadicArguments<IDLUnion<IDLInterface<Node>, IDLDOMString>>(*state, 0);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    propagateException(*state, throwScope, impl.append(WTFMove(nodes.arguments.value())));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionQuerySelectorCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionQuerySelector(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionQuerySelectorCaller>(state, "querySelector");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionQuerySelectorCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto selectors = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<Element>>(*state, *castedThis->globalObject(), throwScope, impl.querySelector(WTFMove(selectors))));
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionQuerySelectorAllCaller(JSC::ExecState*, JSElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionQuerySelectorAll(ExecState* state)
{
    return BindingCaller<JSElement>::callOperation<jsElementPrototypeFunctionQuerySelectorAllCaller>(state, "querySelectorAll");
}

static inline JSC::EncodedJSValue jsElementPrototypeFunctionQuerySelectorAllCaller(JSC::ExecState* state, JSElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto selectors = convert<IDLDOMString>(*state, state->uncheckedArgument(0), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJSNewlyCreated<IDLInterface<NodeList>>(*state, *castedThis->globalObject(), throwScope, impl.querySelectorAll(WTFMove(selectors))));
}

void JSElement::visitChildren(JSCell* cell, SlotVisitor& visitor)
{
    auto* thisObject = jsCast<JSElement*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    thisObject->wrapped().visitJSEventListeners(visitor);
}

Element* JSElement::toWrapped(JSC::JSValue value)
{
    if (auto* wrapper = jsDynamicDowncast<JSElement*>(value))
        return &wrapper->wrapped();
    return nullptr;
}

}
