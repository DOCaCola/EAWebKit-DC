/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"
#include "JSSVGSVGElement.h"

#include "JSDOMBinding.h"
#include "JSDOMConstructor.h"
#include "JSDOMConvert.h"
#include "JSElement.h"
#include "JSNodeList.h"
#include "JSSVGAngle.h"
#include "JSSVGAnimatedBoolean.h"
#include "JSSVGAnimatedLength.h"
#include "JSSVGAnimatedPreserveAspectRatio.h"
#include "JSSVGAnimatedRect.h"
#include "JSSVGElement.h"
#include "JSSVGLength.h"
#include "JSSVGMatrix.h"
#include "JSSVGNumber.h"
#include "JSSVGPoint.h"
#include "JSSVGRect.h"
#include "JSSVGTransform.h"
#include "JSSVGViewSpec.h"
#include <runtime/Error.h>
#include <wtf/GetPtr.h>

using namespace JSC;

namespace WebCore {

// Functions

JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionSuspendRedraw(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionUnsuspendRedraw(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionUnsuspendRedrawAll(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionForceRedraw(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionPauseAnimations(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionUnpauseAnimations(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionAnimationsPaused(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionGetCurrentTime(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionSetCurrentTime(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionGetIntersectionList(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionGetEnclosureList(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCheckIntersection(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCheckEnclosure(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionDeselectAll(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGNumber(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGLength(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGAngle(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGPoint(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGMatrix(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGTransform(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGTransformFromMatrix(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionGetElementById(JSC::ExecState*);

// Attributes

JSC::EncodedJSValue jsSVGSVGElementX(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementY(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementHeight(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementContentScriptType(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGSVGElementContentScriptType(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGSVGElementContentStyleType(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGSVGElementContentStyleType(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGSVGElementViewport(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementPixelUnitToMillimeterX(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementPixelUnitToMillimeterY(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementScreenPixelToMillimeterX(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementScreenPixelToMillimeterY(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementUseCurrentView(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementCurrentView(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementCurrentScale(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGSVGElementCurrentScale(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGSVGElementCurrentTranslate(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementExternalResourcesRequired(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementViewBox(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementPreserveAspectRatio(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGSVGElementZoomAndPan(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGSVGElementZoomAndPan(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGSVGElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGSVGElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);

class JSSVGSVGElementPrototype : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;
    static JSSVGSVGElementPrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSSVGSVGElementPrototype* ptr = new (NotNull, JSC::allocateCell<JSSVGSVGElementPrototype>(vm.heap)) JSSVGSVGElementPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSSVGSVGElementPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};

using JSSVGSVGElementConstructor = JSDOMConstructorNotConstructable<JSSVGSVGElement>;

/* Hash table for constructor */

static const HashTableValue JSSVGSVGElementConstructorTableValues[] =
{
    { "SVG_ZOOMANDPAN_UNKNOWN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0) } },
    { "SVG_ZOOMANDPAN_DISABLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(1) } },
    { "SVG_ZOOMANDPAN_MAGNIFY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(2) } },
};

static_assert(SVGSVGElement::SVG_ZOOMANDPAN_UNKNOWN == 0, "SVG_ZOOMANDPAN_UNKNOWN in SVGSVGElement does not match value from IDL");
static_assert(SVGSVGElement::SVG_ZOOMANDPAN_DISABLE == 1, "SVG_ZOOMANDPAN_DISABLE in SVGSVGElement does not match value from IDL");
static_assert(SVGSVGElement::SVG_ZOOMANDPAN_MAGNIFY == 2, "SVG_ZOOMANDPAN_MAGNIFY in SVGSVGElement does not match value from IDL");

template<> JSValue JSSVGSVGElementConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    return JSSVGGraphicsElement::getConstructor(vm, &globalObject);
}

template<> void JSSVGSVGElementConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    putDirect(vm, vm.propertyNames->prototype, JSSVGSVGElement::prototype(vm, &globalObject), DontDelete | ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("SVGSVGElement"))), ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
    reifyStaticProperties(vm, JSSVGSVGElementConstructorTableValues, *this);
}

template<> const ClassInfo JSSVGSVGElementConstructor::s_info = { "SVGSVGElement", &Base::s_info, 0, CREATE_METHOD_TABLE(JSSVGSVGElementConstructor) };

/* Hash table for prototype */

static const HashTableValue JSSVGSVGElementPrototypeTableValues[] =
{
    { "constructor", DontEnum, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGSVGElementConstructor) } },
    { "x", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementX), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "y", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementY), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "width", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "height", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementHeight), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "contentScriptType", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementContentScriptType), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGSVGElementContentScriptType) } },
    { "contentStyleType", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementContentStyleType), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGSVGElementContentStyleType) } },
    { "viewport", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementViewport), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "pixelUnitToMillimeterX", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementPixelUnitToMillimeterX), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "pixelUnitToMillimeterY", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementPixelUnitToMillimeterY), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "screenPixelToMillimeterX", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementScreenPixelToMillimeterX), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "screenPixelToMillimeterY", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementScreenPixelToMillimeterY), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "useCurrentView", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementUseCurrentView), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "currentView", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementCurrentView), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "currentScale", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementCurrentScale), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGSVGElementCurrentScale) } },
    { "currentTranslate", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementCurrentTranslate), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "externalResourcesRequired", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementExternalResourcesRequired), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "viewBox", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementViewBox), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "preserveAspectRatio", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementPreserveAspectRatio), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "zoomAndPan", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGSVGElementZoomAndPan), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGSVGElementZoomAndPan) } },
    { "suspendRedraw", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionSuspendRedraw), (intptr_t) (0) } },
    { "unsuspendRedraw", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionUnsuspendRedraw), (intptr_t) (0) } },
    { "unsuspendRedrawAll", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionUnsuspendRedrawAll), (intptr_t) (0) } },
    { "forceRedraw", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionForceRedraw), (intptr_t) (0) } },
    { "pauseAnimations", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionPauseAnimations), (intptr_t) (0) } },
    { "unpauseAnimations", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionUnpauseAnimations), (intptr_t) (0) } },
    { "animationsPaused", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionAnimationsPaused), (intptr_t) (0) } },
    { "getCurrentTime", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionGetCurrentTime), (intptr_t) (0) } },
    { "setCurrentTime", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionSetCurrentTime), (intptr_t) (0) } },
    { "getIntersectionList", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionGetIntersectionList), (intptr_t) (1) } },
    { "getEnclosureList", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionGetEnclosureList), (intptr_t) (1) } },
    { "checkIntersection", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionCheckIntersection), (intptr_t) (2) } },
    { "checkEnclosure", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionCheckEnclosure), (intptr_t) (2) } },
    { "deselectAll", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionDeselectAll), (intptr_t) (0) } },
    { "createSVGNumber", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionCreateSVGNumber), (intptr_t) (0) } },
    { "createSVGLength", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionCreateSVGLength), (intptr_t) (0) } },
    { "createSVGAngle", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionCreateSVGAngle), (intptr_t) (0) } },
    { "createSVGPoint", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionCreateSVGPoint), (intptr_t) (0) } },
    { "createSVGMatrix", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionCreateSVGMatrix), (intptr_t) (0) } },
    { "createSVGRect", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionCreateSVGRect), (intptr_t) (0) } },
    { "createSVGTransform", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionCreateSVGTransform), (intptr_t) (0) } },
    { "createSVGTransformFromMatrix", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionCreateSVGTransformFromMatrix), (intptr_t) (1) } },
    { "getElementById", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGSVGElementPrototypeFunctionGetElementById), (intptr_t) (1) } },
    { "SVG_ZOOMANDPAN_UNKNOWN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0) } },
    { "SVG_ZOOMANDPAN_DISABLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(1) } },
    { "SVG_ZOOMANDPAN_MAGNIFY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(2) } },
};

const ClassInfo JSSVGSVGElementPrototype::s_info = { "SVGSVGElementPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSSVGSVGElementPrototype) };

void JSSVGSVGElementPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSVGSVGElementPrototypeTableValues, *this);
}

const ClassInfo JSSVGSVGElement::s_info = { "SVGSVGElement", &Base::s_info, 0, CREATE_METHOD_TABLE(JSSVGSVGElement) };

JSSVGSVGElement::JSSVGSVGElement(Structure* structure, JSDOMGlobalObject& globalObject, Ref<SVGSVGElement>&& impl)
    : JSSVGGraphicsElement(structure, globalObject, WTFMove(impl))
{
}

void JSSVGSVGElement::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));

}

JSObject* JSSVGSVGElement::createPrototype(VM& vm, JSGlobalObject* globalObject)
{
    return JSSVGSVGElementPrototype::create(vm, globalObject, JSSVGSVGElementPrototype::createStructure(vm, globalObject, JSSVGGraphicsElement::prototype(vm, globalObject)));
}

JSObject* JSSVGSVGElement::prototype(VM& vm, JSGlobalObject* globalObject)
{
    return getDOMPrototype<JSSVGSVGElement>(vm, globalObject);
}

template<> inline JSSVGSVGElement* BindingCaller<JSSVGSVGElement>::castForAttribute(ExecState&, EncodedJSValue thisValue)
{
    return jsDynamicDowncast<JSSVGSVGElement*>(JSValue::decode(thisValue));
}

template<> inline JSSVGSVGElement* BindingCaller<JSSVGSVGElement>::castForOperation(ExecState& state)
{
    return jsDynamicDowncast<JSSVGSVGElement*>(state.thisValue());
}

static inline JSValue jsSVGSVGElementXGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementX(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementXGetter>(state, thisValue, "x");
}

static inline JSValue jsSVGSVGElementXGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<SVGAnimatedLength>>(state, *thisObject.globalObject(), impl.xAnimated());
    return result;
}

static inline JSValue jsSVGSVGElementYGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementY(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementYGetter>(state, thisValue, "y");
}

static inline JSValue jsSVGSVGElementYGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<SVGAnimatedLength>>(state, *thisObject.globalObject(), impl.yAnimated());
    return result;
}

static inline JSValue jsSVGSVGElementWidthGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementWidthGetter>(state, thisValue, "width");
}

static inline JSValue jsSVGSVGElementWidthGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<SVGAnimatedLength>>(state, *thisObject.globalObject(), impl.widthAnimated());
    return result;
}

static inline JSValue jsSVGSVGElementHeightGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementHeight(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementHeightGetter>(state, thisValue, "height");
}

static inline JSValue jsSVGSVGElementHeightGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<SVGAnimatedLength>>(state, *thisObject.globalObject(), impl.heightAnimated());
    return result;
}

static inline JSValue jsSVGSVGElementContentScriptTypeGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementContentScriptType(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementContentScriptTypeGetter>(state, thisValue, "contentScriptType");
}

static inline JSValue jsSVGSVGElementContentScriptTypeGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDOMString>(state, impl.contentScriptType());
    return result;
}

static inline JSValue jsSVGSVGElementContentStyleTypeGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementContentStyleType(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementContentStyleTypeGetter>(state, thisValue, "contentStyleType");
}

static inline JSValue jsSVGSVGElementContentStyleTypeGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLDOMString>(state, impl.contentStyleType());
    return result;
}

static inline JSValue jsSVGSVGElementViewportGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementViewport(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementViewportGetter>(state, thisValue, "viewport");
}

static inline JSValue jsSVGSVGElementViewportGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJSNewlyCreated<IDLInterface<SVGRect>>(state, *thisObject.globalObject(), impl.viewport());
    return result;
}

static inline JSValue jsSVGSVGElementPixelUnitToMillimeterXGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementPixelUnitToMillimeterX(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementPixelUnitToMillimeterXGetter>(state, thisValue, "pixelUnitToMillimeterX");
}

static inline JSValue jsSVGSVGElementPixelUnitToMillimeterXGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnrestrictedFloat>(impl.pixelUnitToMillimeterX());
    return result;
}

static inline JSValue jsSVGSVGElementPixelUnitToMillimeterYGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementPixelUnitToMillimeterY(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementPixelUnitToMillimeterYGetter>(state, thisValue, "pixelUnitToMillimeterY");
}

static inline JSValue jsSVGSVGElementPixelUnitToMillimeterYGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnrestrictedFloat>(impl.pixelUnitToMillimeterY());
    return result;
}

static inline JSValue jsSVGSVGElementScreenPixelToMillimeterXGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementScreenPixelToMillimeterX(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementScreenPixelToMillimeterXGetter>(state, thisValue, "screenPixelToMillimeterX");
}

static inline JSValue jsSVGSVGElementScreenPixelToMillimeterXGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnrestrictedFloat>(impl.screenPixelToMillimeterX());
    return result;
}

static inline JSValue jsSVGSVGElementScreenPixelToMillimeterYGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementScreenPixelToMillimeterY(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementScreenPixelToMillimeterYGetter>(state, thisValue, "screenPixelToMillimeterY");
}

static inline JSValue jsSVGSVGElementScreenPixelToMillimeterYGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnrestrictedFloat>(impl.screenPixelToMillimeterY());
    return result;
}

static inline JSValue jsSVGSVGElementUseCurrentViewGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementUseCurrentView(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementUseCurrentViewGetter>(state, thisValue, "useCurrentView");
}

static inline JSValue jsSVGSVGElementUseCurrentViewGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLBoolean>(impl.useCurrentView());
    return result;
}

static inline JSValue jsSVGSVGElementCurrentViewGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementCurrentView(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementCurrentViewGetter>(state, thisValue, "currentView");
}

static inline JSValue jsSVGSVGElementCurrentViewGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<SVGViewSpec>>(state, *thisObject.globalObject(), impl.currentView());
    return result;
}

static inline JSValue jsSVGSVGElementCurrentScaleGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementCurrentScale(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementCurrentScaleGetter>(state, thisValue, "currentScale");
}

static inline JSValue jsSVGSVGElementCurrentScaleGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnrestrictedFloat>(impl.currentScale());
    return result;
}

static inline JSValue jsSVGSVGElementCurrentTranslateGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementCurrentTranslate(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementCurrentTranslateGetter>(state, thisValue, "currentTranslate");
}

static inline JSValue jsSVGSVGElementCurrentTranslateGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJSNewlyCreated<IDLInterface<SVGPoint>>(state, *thisObject.globalObject(), impl.currentTranslate());
    return result;
}

static inline JSValue jsSVGSVGElementExternalResourcesRequiredGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementExternalResourcesRequired(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementExternalResourcesRequiredGetter>(state, thisValue, "externalResourcesRequired");
}

static inline JSValue jsSVGSVGElementExternalResourcesRequiredGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<SVGAnimatedBoolean>>(state, *thisObject.globalObject(), impl.externalResourcesRequiredAnimated());
    return result;
}

static inline JSValue jsSVGSVGElementViewBoxGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementViewBox(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementViewBoxGetter>(state, thisValue, "viewBox");
}

static inline JSValue jsSVGSVGElementViewBoxGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<SVGAnimatedRect>>(state, *thisObject.globalObject(), impl.viewBoxAnimated());
    return result;
}

static inline JSValue jsSVGSVGElementPreserveAspectRatioGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementPreserveAspectRatio(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementPreserveAspectRatioGetter>(state, thisValue, "preserveAspectRatio");
}

static inline JSValue jsSVGSVGElementPreserveAspectRatioGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<SVGAnimatedPreserveAspectRatio>>(state, *thisObject.globalObject(), impl.preserveAspectRatioAnimated());
    return result;
}

static inline JSValue jsSVGSVGElementZoomAndPanGetter(ExecState&, JSSVGSVGElement&, ThrowScope& throwScope);

EncodedJSValue jsSVGSVGElementZoomAndPan(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSSVGSVGElement>::attribute<jsSVGSVGElementZoomAndPanGetter>(state, thisValue, "zoomAndPan");
}

static inline JSValue jsSVGSVGElementZoomAndPanGetter(ExecState& state, JSSVGSVGElement& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLUnsignedShort>(impl.zoomAndPan());
    return result;
}

EncodedJSValue jsSVGSVGElementConstructor(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSVGSVGElementPrototype* domObject = jsDynamicDowncast<JSSVGSVGElementPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject))
        return throwVMTypeError(state, throwScope);
    return JSValue::encode(JSSVGSVGElement::getConstructor(state->vm(), domObject->globalObject()));
}

bool setJSSVGSVGElementConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSValue value = JSValue::decode(encodedValue);
    JSSVGSVGElementPrototype* domObject = jsDynamicDowncast<JSSVGSVGElementPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject)) {
        throwVMTypeError(state, throwScope);
        return false;
    }
    // Shadowing a built-in constructor
    return domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
}

static inline bool setJSSVGSVGElementContentScriptTypeFunction(ExecState&, JSSVGSVGElement&, JSValue, ThrowScope&);

bool setJSSVGSVGElementContentScriptType(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSSVGSVGElement>::setAttribute<setJSSVGSVGElementContentScriptTypeFunction>(state, thisValue, encodedValue, "contentScriptType");
}

static inline bool setJSSVGSVGElementContentScriptTypeFunction(ExecState& state, JSSVGSVGElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLDOMString>(state, value, StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setContentScriptType(WTFMove(nativeValue));
    return true;
}


static inline bool setJSSVGSVGElementContentStyleTypeFunction(ExecState&, JSSVGSVGElement&, JSValue, ThrowScope&);

bool setJSSVGSVGElementContentStyleType(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSSVGSVGElement>::setAttribute<setJSSVGSVGElementContentStyleTypeFunction>(state, thisValue, encodedValue, "contentStyleType");
}

static inline bool setJSSVGSVGElementContentStyleTypeFunction(ExecState& state, JSSVGSVGElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLDOMString>(state, value, StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setContentStyleType(WTFMove(nativeValue));
    return true;
}


static inline bool setJSSVGSVGElementCurrentScaleFunction(ExecState&, JSSVGSVGElement&, JSValue, ThrowScope&);

bool setJSSVGSVGElementCurrentScale(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSSVGSVGElement>::setAttribute<setJSSVGSVGElementCurrentScaleFunction>(state, thisValue, encodedValue, "currentScale");
}

static inline bool setJSSVGSVGElementCurrentScaleFunction(ExecState& state, JSSVGSVGElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLUnrestrictedFloat>(state, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setCurrentScale(WTFMove(nativeValue));
    return true;
}


static inline bool setJSSVGSVGElementZoomAndPanFunction(ExecState&, JSSVGSVGElement&, JSValue, ThrowScope&);

bool setJSSVGSVGElementZoomAndPan(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    return BindingCaller<JSSVGSVGElement>::setAttribute<setJSSVGSVGElementZoomAndPanFunction>(state, thisValue, encodedValue, "zoomAndPan");
}

static inline bool setJSSVGSVGElementZoomAndPanFunction(ExecState& state, JSSVGSVGElement& thisObject, JSValue value, ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = thisObject.wrapped();
    auto nativeValue = convert<IDLUnsignedShort>(state, value, IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, false);
    impl.setZoomAndPan(WTFMove(nativeValue));
    return true;
}


JSValue JSSVGSVGElement::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSSVGSVGElementConstructor>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionSuspendRedrawCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionSuspendRedraw(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionSuspendRedrawCaller>(state, "suspendRedraw");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionSuspendRedrawCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto maxWaitMilliseconds = convert<IDLUnsignedLong>(*state, state->argument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLUnsignedLong>(impl.suspendRedraw(WTFMove(maxWaitMilliseconds))));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionUnsuspendRedrawCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionUnsuspendRedraw(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionUnsuspendRedrawCaller>(state, "unsuspendRedraw");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionUnsuspendRedrawCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto suspendHandleId = convert<IDLUnsignedLong>(*state, state->argument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.unsuspendRedraw(WTFMove(suspendHandleId));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionUnsuspendRedrawAllCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionUnsuspendRedrawAll(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionUnsuspendRedrawAllCaller>(state, "unsuspendRedrawAll");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionUnsuspendRedrawAllCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.unsuspendRedrawAll();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionForceRedrawCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionForceRedraw(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionForceRedrawCaller>(state, "forceRedraw");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionForceRedrawCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.forceRedraw();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionPauseAnimationsCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionPauseAnimations(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionPauseAnimationsCaller>(state, "pauseAnimations");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionPauseAnimationsCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.pauseAnimations();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionUnpauseAnimationsCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionUnpauseAnimations(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionUnpauseAnimationsCaller>(state, "unpauseAnimations");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionUnpauseAnimationsCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.unpauseAnimations();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionAnimationsPausedCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionAnimationsPaused(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionAnimationsPausedCaller>(state, "animationsPaused");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionAnimationsPausedCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLBoolean>(impl.animationsPaused()));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionGetCurrentTimeCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionGetCurrentTime(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionGetCurrentTimeCaller>(state, "getCurrentTime");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionGetCurrentTimeCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLUnrestrictedFloat>(impl.getCurrentTime()));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionSetCurrentTimeCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionSetCurrentTime(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionSetCurrentTimeCaller>(state, "setCurrentTime");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionSetCurrentTimeCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    auto seconds = convert<IDLUnrestrictedFloat>(*state, state->argument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.setCurrentTime(WTFMove(seconds));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionGetIntersectionListCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionGetIntersectionList(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionGetIntersectionListCaller>(state, "getIntersectionList");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionGetIntersectionListCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto rect = convert<IDLInterface<SVGRect>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "rect", "SVGSVGElement", "getIntersectionList", "SVGRect"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto referenceElement = convert<IDLNullable<IDLInterface<SVGElement>>>(*state, state->argument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "referenceElement", "SVGSVGElement", "getIntersectionList", "SVGElement"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<NodeList>>(*state, *castedThis->globalObject(), impl.getIntersectionList(*rect, WTFMove(referenceElement))));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionGetEnclosureListCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionGetEnclosureList(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionGetEnclosureListCaller>(state, "getEnclosureList");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionGetEnclosureListCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto rect = convert<IDLInterface<SVGRect>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "rect", "SVGSVGElement", "getEnclosureList", "SVGRect"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto referenceElement = convert<IDLNullable<IDLInterface<SVGElement>>>(*state, state->argument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "referenceElement", "SVGSVGElement", "getEnclosureList", "SVGElement"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<NodeList>>(*state, *castedThis->globalObject(), impl.getEnclosureList(*rect, WTFMove(referenceElement))));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCheckIntersectionCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCheckIntersection(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionCheckIntersectionCaller>(state, "checkIntersection");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCheckIntersectionCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto element = convert<IDLNullable<IDLInterface<SVGElement>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "element", "SVGSVGElement", "checkIntersection", "SVGElement"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto rect = convert<IDLInterface<SVGRect>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "rect", "SVGSVGElement", "checkIntersection", "SVGRect"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.checkIntersection(WTFMove(element), *rect)));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCheckEnclosureCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCheckEnclosure(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionCheckEnclosureCaller>(state, "checkEnclosure");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCheckEnclosureCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto element = convert<IDLNullable<IDLInterface<SVGElement>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "element", "SVGSVGElement", "checkEnclosure", "SVGElement"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto rect = convert<IDLInterface<SVGRect>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "rect", "SVGSVGElement", "checkEnclosure", "SVGRect"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.checkEnclosure(WTFMove(element), *rect)));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionDeselectAllCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionDeselectAll(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionDeselectAllCaller>(state, "deselectAll");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionDeselectAllCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.deselectAll();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGNumberCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGNumber(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionCreateSVGNumberCaller>(state, "createSVGNumber");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGNumberCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJSNewlyCreated<IDLInterface<SVGNumber>>(*state, *castedThis->globalObject(), impl.createSVGNumber()));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGLengthCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGLength(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionCreateSVGLengthCaller>(state, "createSVGLength");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGLengthCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJSNewlyCreated<IDLInterface<SVGLength>>(*state, *castedThis->globalObject(), impl.createSVGLength()));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGAngleCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGAngle(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionCreateSVGAngleCaller>(state, "createSVGAngle");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGAngleCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJSNewlyCreated<IDLInterface<SVGAngle>>(*state, *castedThis->globalObject(), impl.createSVGAngle()));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGPointCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGPoint(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionCreateSVGPointCaller>(state, "createSVGPoint");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGPointCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJSNewlyCreated<IDLInterface<SVGPoint>>(*state, *castedThis->globalObject(), impl.createSVGPoint()));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGMatrixCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGMatrix(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionCreateSVGMatrixCaller>(state, "createSVGMatrix");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGMatrixCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJSNewlyCreated<IDLInterface<SVGMatrix>>(*state, *castedThis->globalObject(), impl.createSVGMatrix()));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGRectCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGRect(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionCreateSVGRectCaller>(state, "createSVGRect");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGRectCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJSNewlyCreated<IDLInterface<SVGRect>>(*state, *castedThis->globalObject(), impl.createSVGRect()));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGTransformCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGTransform(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionCreateSVGTransformCaller>(state, "createSVGTransform");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGTransformCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJSNewlyCreated<IDLInterface<SVGTransform>>(*state, *castedThis->globalObject(), impl.createSVGTransform()));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGTransformFromMatrixCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionCreateSVGTransformFromMatrix(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionCreateSVGTransformFromMatrixCaller>(state, "createSVGTransformFromMatrix");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionCreateSVGTransformFromMatrixCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto matrix = convert<IDLInterface<SVGMatrix>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "matrix", "SVGSVGElement", "createSVGTransformFromMatrix", "SVGMatrix"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJSNewlyCreated<IDLInterface<SVGTransform>>(*state, *castedThis->globalObject(), impl.createSVGTransformFromMatrix(*matrix)));
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionGetElementByIdCaller(JSC::ExecState*, JSSVGSVGElement*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsSVGSVGElementPrototypeFunctionGetElementById(ExecState* state)
{
    return BindingCaller<JSSVGSVGElement>::callOperation<jsSVGSVGElementPrototypeFunctionGetElementByIdCaller>(state, "getElementById");
}

static inline JSC::EncodedJSValue jsSVGSVGElementPrototypeFunctionGetElementByIdCaller(JSC::ExecState* state, JSSVGSVGElement* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto elementId = AtomicString(state->uncheckedArgument(0).toString(state)->toExistingAtomicString(state));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<Element>>(*state, *castedThis->globalObject(), impl.getElementById(WTFMove(elementId))));
}

void JSSVGSVGElement::visitChildren(JSCell* cell, SlotVisitor& visitor)
{
    auto* thisObject = jsCast<JSSVGSVGElement*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    thisObject->wrapped().visitJSEventListeners(visitor);
}


}
