/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(WEBGL)

#include "JSWebGLRenderingContextBase.h"

#include "JSDOMBinding.h"
#include "JSDOMConvert.h"
#include "JSHTMLCanvasElement.h"
#include "JSHTMLImageElement.h"
#include "JSHTMLVideoElement.h"
#include "JSImageData.h"
#include "JSWebGLActiveInfo.h"
#include "JSWebGLBuffer.h"
#include "JSWebGLContextAttributes.h"
#include "JSWebGLFramebuffer.h"
#include "JSWebGLProgram.h"
#include "JSWebGLRenderbuffer.h"
#include "JSWebGLShader.h"
#include "JSWebGLShaderPrecisionFormat.h"
#include "JSWebGLTexture.h"
#include "JSWebGLUniformLocation.h"
#include <runtime/Error.h>
#include <runtime/JSArray.h>
#include <wtf/GetPtr.h>
#include <wtf/Variant.h>

using namespace JSC;

namespace WebCore {

// Functions

JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionActiveTexture(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionAttachShader(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindAttribLocation(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindBuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindRenderbuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindTexture(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendColor(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendEquation(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendEquationSeparate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendFunc(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendFuncSeparate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBufferData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBufferSubData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCheckFramebufferStatus(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClear(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClearColor(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClearDepth(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClearStencil(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionColorMask(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCompileShader(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCompressedTexImage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCompressedTexSubImage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCopyTexImage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCopyTexSubImage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateBuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateProgram(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateRenderbuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateShader(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateTexture(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCullFace(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteBuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteProgram(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteRenderbuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteShader(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteTexture(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDepthFunc(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDepthMask(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDepthRange(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDetachShader(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDisable(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDisableVertexAttribArray(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDrawArrays(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDrawElements(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionEnable(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionEnableVertexAttribArray(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFinish(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFlush(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFramebufferRenderbuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFramebufferTexture2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFrontFace(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGenerateMipmap(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetActiveAttrib(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetActiveUniform(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetAttachedShaders(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetAttribLocation(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetBufferParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetContextAttributes(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetError(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetSupportedExtensions(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetExtension(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetFramebufferAttachmentParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetProgramParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetProgramInfoLog(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetRenderbufferParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderInfoLog(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderPrecisionFormat(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderSource(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetTexParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetUniform(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetUniformLocation(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttrib(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttribOffset(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionHint(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsBuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsContextLost(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsEnabled(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsProgram(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsRenderbuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsShader(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsTexture(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionLineWidth(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionLinkProgram(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionPixelStorei(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionPolygonOffset(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionReadPixels(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionReleaseShaderCompiler(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionRenderbufferStorage(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionSampleCoverage(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionScissor(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionShaderSource(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilFunc(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilFuncSeparate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilMask(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilMaskSeparate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilOp(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilOpSeparate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexParameterf(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexParameteri(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexImage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1i(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2i(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3i(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4i(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1iv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2iv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3iv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4iv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix2fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix3fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix4fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUseProgram(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionValidateProgram(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttribPointer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionViewport(JSC::ExecState*);

// Attributes

JSC::EncodedJSValue jsWebGLRenderingContextBaseCanvas(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsWebGLRenderingContextBaseDrawingBufferWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsWebGLRenderingContextBaseDrawingBufferHeight(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSWebGLRenderingContextBaseConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);

class JSWebGLRenderingContextBasePrototype : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;
    static JSWebGLRenderingContextBasePrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSWebGLRenderingContextBasePrototype* ptr = new (NotNull, JSC::allocateCell<JSWebGLRenderingContextBasePrototype>(vm.heap)) JSWebGLRenderingContextBasePrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSWebGLRenderingContextBasePrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};

/* Hash table for prototype */

static const HashTableValue JSWebGLRenderingContextBasePrototypeTableValues[] =
{
    { "canvas", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsWebGLRenderingContextBaseCanvas), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "drawingBufferWidth", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsWebGLRenderingContextBaseDrawingBufferWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "drawingBufferHeight", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsWebGLRenderingContextBaseDrawingBufferHeight), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "activeTexture", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionActiveTexture), (intptr_t) (1) } },
    { "attachShader", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionAttachShader), (intptr_t) (2) } },
    { "bindAttribLocation", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBindAttribLocation), (intptr_t) (3) } },
    { "bindBuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBindBuffer), (intptr_t) (2) } },
    { "bindFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBindFramebuffer), (intptr_t) (2) } },
    { "bindRenderbuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBindRenderbuffer), (intptr_t) (2) } },
    { "bindTexture", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBindTexture), (intptr_t) (2) } },
    { "blendColor", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBlendColor), (intptr_t) (4) } },
    { "blendEquation", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBlendEquation), (intptr_t) (1) } },
    { "blendEquationSeparate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBlendEquationSeparate), (intptr_t) (2) } },
    { "blendFunc", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBlendFunc), (intptr_t) (2) } },
    { "blendFuncSeparate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBlendFuncSeparate), (intptr_t) (4) } },
    { "bufferData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBufferData), (intptr_t) (3) } },
    { "bufferSubData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBufferSubData), (intptr_t) (3) } },
    { "checkFramebufferStatus", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCheckFramebufferStatus), (intptr_t) (1) } },
    { "clear", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionClear), (intptr_t) (1) } },
    { "clearColor", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionClearColor), (intptr_t) (4) } },
    { "clearDepth", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionClearDepth), (intptr_t) (1) } },
    { "clearStencil", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionClearStencil), (intptr_t) (1) } },
    { "colorMask", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionColorMask), (intptr_t) (4) } },
    { "compileShader", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCompileShader), (intptr_t) (1) } },
    { "compressedTexImage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCompressedTexImage2D), (intptr_t) (7) } },
    { "compressedTexSubImage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCompressedTexSubImage2D), (intptr_t) (8) } },
    { "copyTexImage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCopyTexImage2D), (intptr_t) (8) } },
    { "copyTexSubImage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCopyTexSubImage2D), (intptr_t) (8) } },
    { "createBuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCreateBuffer), (intptr_t) (0) } },
    { "createFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCreateFramebuffer), (intptr_t) (0) } },
    { "createProgram", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCreateProgram), (intptr_t) (0) } },
    { "createRenderbuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCreateRenderbuffer), (intptr_t) (0) } },
    { "createShader", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCreateShader), (intptr_t) (1) } },
    { "createTexture", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCreateTexture), (intptr_t) (0) } },
    { "cullFace", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCullFace), (intptr_t) (1) } },
    { "deleteBuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDeleteBuffer), (intptr_t) (1) } },
    { "deleteFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDeleteFramebuffer), (intptr_t) (1) } },
    { "deleteProgram", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDeleteProgram), (intptr_t) (1) } },
    { "deleteRenderbuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDeleteRenderbuffer), (intptr_t) (1) } },
    { "deleteShader", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDeleteShader), (intptr_t) (1) } },
    { "deleteTexture", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDeleteTexture), (intptr_t) (1) } },
    { "depthFunc", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDepthFunc), (intptr_t) (1) } },
    { "depthMask", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDepthMask), (intptr_t) (1) } },
    { "depthRange", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDepthRange), (intptr_t) (2) } },
    { "detachShader", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDetachShader), (intptr_t) (2) } },
    { "disable", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDisable), (intptr_t) (1) } },
    { "disableVertexAttribArray", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDisableVertexAttribArray), (intptr_t) (1) } },
    { "drawArrays", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDrawArrays), (intptr_t) (3) } },
    { "drawElements", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDrawElements), (intptr_t) (4) } },
    { "enable", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionEnable), (intptr_t) (1) } },
    { "enableVertexAttribArray", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionEnableVertexAttribArray), (intptr_t) (1) } },
    { "finish", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionFinish), (intptr_t) (0) } },
    { "flush", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionFlush), (intptr_t) (0) } },
    { "framebufferRenderbuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionFramebufferRenderbuffer), (intptr_t) (4) } },
    { "framebufferTexture2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionFramebufferTexture2D), (intptr_t) (5) } },
    { "frontFace", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionFrontFace), (intptr_t) (1) } },
    { "generateMipmap", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGenerateMipmap), (intptr_t) (1) } },
    { "getActiveAttrib", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetActiveAttrib), (intptr_t) (2) } },
    { "getActiveUniform", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetActiveUniform), (intptr_t) (2) } },
    { "getAttachedShaders", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetAttachedShaders), (intptr_t) (1) } },
    { "getAttribLocation", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetAttribLocation), (intptr_t) (2) } },
    { "getBufferParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetBufferParameter), (intptr_t) (2) } },
    { "getContextAttributes", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetContextAttributes), (intptr_t) (0) } },
    { "getError", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetError), (intptr_t) (0) } },
    { "getSupportedExtensions", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetSupportedExtensions), (intptr_t) (0) } },
    { "getExtension", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetExtension), (intptr_t) (1) } },
    { "getFramebufferAttachmentParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetFramebufferAttachmentParameter), (intptr_t) (3) } },
    { "getParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetParameter), (intptr_t) (1) } },
    { "getProgramParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetProgramParameter), (intptr_t) (2) } },
    { "getProgramInfoLog", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetProgramInfoLog), (intptr_t) (1) } },
    { "getRenderbufferParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetRenderbufferParameter), (intptr_t) (2) } },
    { "getShaderParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetShaderParameter), (intptr_t) (2) } },
    { "getShaderInfoLog", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetShaderInfoLog), (intptr_t) (1) } },
    { "getShaderPrecisionFormat", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetShaderPrecisionFormat), (intptr_t) (2) } },
    { "getShaderSource", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetShaderSource), (intptr_t) (1) } },
    { "getTexParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetTexParameter), (intptr_t) (2) } },
    { "getUniform", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetUniform), (intptr_t) (2) } },
    { "getUniformLocation", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetUniformLocation), (intptr_t) (2) } },
    { "getVertexAttrib", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttrib), (intptr_t) (2) } },
    { "getVertexAttribOffset", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttribOffset), (intptr_t) (2) } },
    { "hint", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionHint), (intptr_t) (2) } },
    { "isBuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsBuffer), (intptr_t) (1) } },
    { "isContextLost", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsContextLost), (intptr_t) (0) } },
    { "isEnabled", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsEnabled), (intptr_t) (1) } },
    { "isFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsFramebuffer), (intptr_t) (1) } },
    { "isProgram", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsProgram), (intptr_t) (1) } },
    { "isRenderbuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsRenderbuffer), (intptr_t) (1) } },
    { "isShader", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsShader), (intptr_t) (1) } },
    { "isTexture", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsTexture), (intptr_t) (1) } },
    { "lineWidth", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionLineWidth), (intptr_t) (1) } },
    { "linkProgram", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionLinkProgram), (intptr_t) (1) } },
    { "pixelStorei", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionPixelStorei), (intptr_t) (2) } },
    { "polygonOffset", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionPolygonOffset), (intptr_t) (2) } },
    { "readPixels", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionReadPixels), (intptr_t) (7) } },
    { "releaseShaderCompiler", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionReleaseShaderCompiler), (intptr_t) (0) } },
    { "renderbufferStorage", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionRenderbufferStorage), (intptr_t) (4) } },
    { "sampleCoverage", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionSampleCoverage), (intptr_t) (2) } },
    { "scissor", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionScissor), (intptr_t) (4) } },
    { "shaderSource", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionShaderSource), (intptr_t) (2) } },
    { "stencilFunc", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionStencilFunc), (intptr_t) (3) } },
    { "stencilFuncSeparate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionStencilFuncSeparate), (intptr_t) (4) } },
    { "stencilMask", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionStencilMask), (intptr_t) (1) } },
    { "stencilMaskSeparate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionStencilMaskSeparate), (intptr_t) (2) } },
    { "stencilOp", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionStencilOp), (intptr_t) (3) } },
    { "stencilOpSeparate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionStencilOpSeparate), (intptr_t) (4) } },
    { "texParameterf", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionTexParameterf), (intptr_t) (3) } },
    { "texParameteri", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionTexParameteri), (intptr_t) (3) } },
    { "texImage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionTexImage2D), (intptr_t) (6) } },
    { "texSubImage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D), (intptr_t) (7) } },
    { "uniform1f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform1f), (intptr_t) (2) } },
    { "uniform2f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform2f), (intptr_t) (3) } },
    { "uniform3f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform3f), (intptr_t) (4) } },
    { "uniform4f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform4f), (intptr_t) (5) } },
    { "uniform1i", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform1i), (intptr_t) (2) } },
    { "uniform2i", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform2i), (intptr_t) (3) } },
    { "uniform3i", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform3i), (intptr_t) (4) } },
    { "uniform4i", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform4i), (intptr_t) (5) } },
    { "uniform1fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform1fv), (intptr_t) (2) } },
    { "uniform2fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform2fv), (intptr_t) (2) } },
    { "uniform3fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform3fv), (intptr_t) (2) } },
    { "uniform4fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform4fv), (intptr_t) (2) } },
    { "uniform1iv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform1iv), (intptr_t) (2) } },
    { "uniform2iv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform2iv), (intptr_t) (2) } },
    { "uniform3iv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform3iv), (intptr_t) (2) } },
    { "uniform4iv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform4iv), (intptr_t) (2) } },
    { "uniformMatrix2fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix2fv), (intptr_t) (3) } },
    { "uniformMatrix3fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix3fv), (intptr_t) (3) } },
    { "uniformMatrix4fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix4fv), (intptr_t) (3) } },
    { "useProgram", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUseProgram), (intptr_t) (1) } },
    { "validateProgram", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionValidateProgram), (intptr_t) (1) } },
    { "vertexAttrib1f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1f), (intptr_t) (2) } },
    { "vertexAttrib2f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2f), (intptr_t) (3) } },
    { "vertexAttrib3f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3f), (intptr_t) (4) } },
    { "vertexAttrib4f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4f), (intptr_t) (5) } },
    { "vertexAttrib1fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1fv), (intptr_t) (2) } },
    { "vertexAttrib2fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2fv), (intptr_t) (2) } },
    { "vertexAttrib3fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3fv), (intptr_t) (2) } },
    { "vertexAttrib4fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4fv), (intptr_t) (2) } },
    { "vertexAttribPointer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttribPointer), (intptr_t) (6) } },
    { "viewport", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionViewport), (intptr_t) (4) } },
    { "DEPTH_BUFFER_BIT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x00000100) } },
    { "STENCIL_BUFFER_BIT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x00000400) } },
    { "COLOR_BUFFER_BIT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x00004000) } },
    { "POINTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0000) } },
    { "LINES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0001) } },
    { "LINE_LOOP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0002) } },
    { "LINE_STRIP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0003) } },
    { "TRIANGLES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0004) } },
    { "TRIANGLE_STRIP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0005) } },
    { "TRIANGLE_FAN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0006) } },
    { "ZERO", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0) } },
    { "ONE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(1) } },
    { "SRC_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0300) } },
    { "ONE_MINUS_SRC_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0301) } },
    { "SRC_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0302) } },
    { "ONE_MINUS_SRC_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0303) } },
    { "DST_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0304) } },
    { "ONE_MINUS_DST_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0305) } },
    { "DST_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0306) } },
    { "ONE_MINUS_DST_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0307) } },
    { "SRC_ALPHA_SATURATE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0308) } },
    { "FUNC_ADD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8006) } },
    { "BLEND_EQUATION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8009) } },
    { "BLEND_EQUATION_RGB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8009) } },
    { "BLEND_EQUATION_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x883D) } },
    { "FUNC_SUBTRACT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x800A) } },
    { "FUNC_REVERSE_SUBTRACT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x800B) } },
    { "BLEND_DST_RGB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80C8) } },
    { "BLEND_SRC_RGB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80C9) } },
    { "BLEND_DST_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80CA) } },
    { "BLEND_SRC_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80CB) } },
    { "CONSTANT_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8001) } },
    { "ONE_MINUS_CONSTANT_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8002) } },
    { "CONSTANT_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8003) } },
    { "ONE_MINUS_CONSTANT_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8004) } },
    { "BLEND_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8005) } },
    { "ARRAY_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8892) } },
    { "ELEMENT_ARRAY_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8893) } },
    { "ARRAY_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8894) } },
    { "ELEMENT_ARRAY_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8895) } },
    { "STREAM_DRAW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E0) } },
    { "STATIC_DRAW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E4) } },
    { "DYNAMIC_DRAW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E8) } },
    { "BUFFER_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8764) } },
    { "BUFFER_USAGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8765) } },
    { "CURRENT_VERTEX_ATTRIB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8626) } },
    { "FRONT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0404) } },
    { "BACK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0405) } },
    { "FRONT_AND_BACK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0408) } },
    { "TEXTURE_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0DE1) } },
    { "CULL_FACE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B44) } },
    { "BLEND", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0BE2) } },
    { "DITHER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0BD0) } },
    { "STENCIL_TEST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B90) } },
    { "DEPTH_TEST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B71) } },
    { "SCISSOR_TEST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0C11) } },
    { "POLYGON_OFFSET_FILL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8037) } },
    { "SAMPLE_ALPHA_TO_COVERAGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x809E) } },
    { "SAMPLE_COVERAGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80A0) } },
    { "NO_ERROR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0) } },
    { "INVALID_ENUM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0500) } },
    { "INVALID_VALUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0501) } },
    { "INVALID_OPERATION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0502) } },
    { "OUT_OF_MEMORY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0505) } },
    { "CW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0900) } },
    { "CCW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0901) } },
    { "LINE_WIDTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B21) } },
    { "ALIASED_POINT_SIZE_RANGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x846D) } },
    { "ALIASED_LINE_WIDTH_RANGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x846E) } },
    { "CULL_FACE_MODE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B45) } },
    { "FRONT_FACE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B46) } },
    { "DEPTH_RANGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B70) } },
    { "DEPTH_WRITEMASK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B72) } },
    { "DEPTH_CLEAR_VALUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B73) } },
    { "DEPTH_FUNC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B74) } },
    { "STENCIL_CLEAR_VALUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B91) } },
    { "STENCIL_FUNC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B92) } },
    { "STENCIL_FAIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B94) } },
    { "STENCIL_PASS_DEPTH_FAIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B95) } },
    { "STENCIL_PASS_DEPTH_PASS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B96) } },
    { "STENCIL_REF", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B97) } },
    { "STENCIL_VALUE_MASK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B93) } },
    { "STENCIL_WRITEMASK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B98) } },
    { "STENCIL_BACK_FUNC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8800) } },
    { "STENCIL_BACK_FAIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8801) } },
    { "STENCIL_BACK_PASS_DEPTH_FAIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8802) } },
    { "STENCIL_BACK_PASS_DEPTH_PASS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8803) } },
    { "STENCIL_BACK_REF", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA3) } },
    { "STENCIL_BACK_VALUE_MASK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA4) } },
    { "STENCIL_BACK_WRITEMASK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA5) } },
    { "VIEWPORT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0BA2) } },
    { "SCISSOR_BOX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0C10) } },
    { "COLOR_CLEAR_VALUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0C22) } },
    { "COLOR_WRITEMASK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0C23) } },
    { "UNPACK_ALIGNMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF5) } },
    { "PACK_ALIGNMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D05) } },
    { "MAX_TEXTURE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D33) } },
    { "MAX_VIEWPORT_DIMS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D3A) } },
    { "SUBPIXEL_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D50) } },
    { "RED_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D52) } },
    { "GREEN_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D53) } },
    { "BLUE_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D54) } },
    { "ALPHA_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D55) } },
    { "DEPTH_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D56) } },
    { "STENCIL_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D57) } },
    { "POLYGON_OFFSET_UNITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2A00) } },
    { "POLYGON_OFFSET_FACTOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8038) } },
    { "TEXTURE_BINDING_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8069) } },
    { "SAMPLE_BUFFERS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80A8) } },
    { "SAMPLES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80A9) } },
    { "SAMPLE_COVERAGE_VALUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80AA) } },
    { "SAMPLE_COVERAGE_INVERT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80AB) } },
    { "COMPRESSED_TEXTURE_FORMATS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x86A3) } },
    { "DONT_CARE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1100) } },
    { "FASTEST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1101) } },
    { "NICEST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1102) } },
    { "GENERATE_MIPMAP_HINT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8192) } },
    { "BYTE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1400) } },
    { "UNSIGNED_BYTE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1401) } },
    { "SHORT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1402) } },
    { "UNSIGNED_SHORT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1403) } },
    { "INT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1404) } },
    { "UNSIGNED_INT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1405) } },
    { "FLOAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1406) } },
    { "DEPTH_COMPONENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1902) } },
    { "ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1906) } },
    { "RGB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1907) } },
    { "RGBA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1908) } },
    { "LUMINANCE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1909) } },
    { "LUMINANCE_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x190A) } },
    { "UNSIGNED_SHORT_4_4_4_4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8033) } },
    { "UNSIGNED_SHORT_5_5_5_1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8034) } },
    { "UNSIGNED_SHORT_5_6_5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8363) } },
    { "FRAGMENT_SHADER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B30) } },
    { "VERTEX_SHADER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B31) } },
    { "MAX_VERTEX_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8869) } },
    { "MAX_VERTEX_UNIFORM_VECTORS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DFB) } },
    { "MAX_VARYING_VECTORS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DFC) } },
    { "MAX_COMBINED_TEXTURE_IMAGE_UNITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4D) } },
    { "MAX_VERTEX_TEXTURE_IMAGE_UNITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4C) } },
    { "MAX_TEXTURE_IMAGE_UNITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8872) } },
    { "MAX_FRAGMENT_UNIFORM_VECTORS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DFD) } },
    { "SHADER_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4F) } },
    { "DELETE_STATUS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B80) } },
    { "LINK_STATUS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B82) } },
    { "VALIDATE_STATUS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B83) } },
    { "ATTACHED_SHADERS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B85) } },
    { "ACTIVE_UNIFORMS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B86) } },
    { "ACTIVE_ATTRIBUTES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B89) } },
    { "SHADING_LANGUAGE_VERSION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B8C) } },
    { "CURRENT_PROGRAM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B8D) } },
    { "NEVER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0200) } },
    { "LESS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0201) } },
    { "EQUAL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0202) } },
    { "LEQUAL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0203) } },
    { "GREATER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0204) } },
    { "NOTEQUAL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0205) } },
    { "GEQUAL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0206) } },
    { "ALWAYS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0207) } },
    { "KEEP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1E00) } },
    { "REPLACE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1E01) } },
    { "INCR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1E02) } },
    { "DECR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1E03) } },
    { "INVERT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x150A) } },
    { "INCR_WRAP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8507) } },
    { "DECR_WRAP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8508) } },
    { "VENDOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1F00) } },
    { "RENDERER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1F01) } },
    { "VERSION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1F02) } },
    { "NEAREST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2600) } },
    { "LINEAR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2601) } },
    { "NEAREST_MIPMAP_NEAREST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2700) } },
    { "LINEAR_MIPMAP_NEAREST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2701) } },
    { "NEAREST_MIPMAP_LINEAR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2702) } },
    { "LINEAR_MIPMAP_LINEAR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2703) } },
    { "TEXTURE_MAG_FILTER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2800) } },
    { "TEXTURE_MIN_FILTER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2801) } },
    { "TEXTURE_WRAP_S", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2802) } },
    { "TEXTURE_WRAP_T", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2803) } },
    { "TEXTURE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1702) } },
    { "TEXTURE_CUBE_MAP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8513) } },
    { "TEXTURE_BINDING_CUBE_MAP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8514) } },
    { "TEXTURE_CUBE_MAP_POSITIVE_X", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8515) } },
    { "TEXTURE_CUBE_MAP_NEGATIVE_X", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8516) } },
    { "TEXTURE_CUBE_MAP_POSITIVE_Y", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8517) } },
    { "TEXTURE_CUBE_MAP_NEGATIVE_Y", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8518) } },
    { "TEXTURE_CUBE_MAP_POSITIVE_Z", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8519) } },
    { "TEXTURE_CUBE_MAP_NEGATIVE_Z", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x851A) } },
    { "MAX_CUBE_MAP_TEXTURE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x851C) } },
    { "TEXTURE0", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C0) } },
    { "TEXTURE1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C1) } },
    { "TEXTURE2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C2) } },
    { "TEXTURE3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C3) } },
    { "TEXTURE4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C4) } },
    { "TEXTURE5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C5) } },
    { "TEXTURE6", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C6) } },
    { "TEXTURE7", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C7) } },
    { "TEXTURE8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C8) } },
    { "TEXTURE9", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C9) } },
    { "TEXTURE10", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84CA) } },
    { "TEXTURE11", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84CB) } },
    { "TEXTURE12", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84CC) } },
    { "TEXTURE13", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84CD) } },
    { "TEXTURE14", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84CE) } },
    { "TEXTURE15", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84CF) } },
    { "TEXTURE16", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D0) } },
    { "TEXTURE17", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D1) } },
    { "TEXTURE18", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D2) } },
    { "TEXTURE19", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D3) } },
    { "TEXTURE20", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D4) } },
    { "TEXTURE21", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D5) } },
    { "TEXTURE22", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D6) } },
    { "TEXTURE23", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D7) } },
    { "TEXTURE24", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D8) } },
    { "TEXTURE25", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D9) } },
    { "TEXTURE26", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84DA) } },
    { "TEXTURE27", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84DB) } },
    { "TEXTURE28", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84DC) } },
    { "TEXTURE29", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84DD) } },
    { "TEXTURE30", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84DE) } },
    { "TEXTURE31", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84DF) } },
    { "ACTIVE_TEXTURE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84E0) } },
    { "REPEAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2901) } },
    { "CLAMP_TO_EDGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x812F) } },
    { "MIRRORED_REPEAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8370) } },
    { "FLOAT_VEC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B50) } },
    { "FLOAT_VEC3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B51) } },
    { "FLOAT_VEC4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B52) } },
    { "INT_VEC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B53) } },
    { "INT_VEC3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B54) } },
    { "INT_VEC4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B55) } },
    { "BOOL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B56) } },
    { "BOOL_VEC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B57) } },
    { "BOOL_VEC3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B58) } },
    { "BOOL_VEC4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B59) } },
    { "FLOAT_MAT2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B5A) } },
    { "FLOAT_MAT3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B5B) } },
    { "FLOAT_MAT4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B5C) } },
    { "SAMPLER_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B5E) } },
    { "SAMPLER_CUBE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B60) } },
    { "VERTEX_ATTRIB_ARRAY_ENABLED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8622) } },
    { "VERTEX_ATTRIB_ARRAY_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8623) } },
    { "VERTEX_ATTRIB_ARRAY_STRIDE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8624) } },
    { "VERTEX_ATTRIB_ARRAY_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8625) } },
    { "VERTEX_ATTRIB_ARRAY_NORMALIZED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x886A) } },
    { "VERTEX_ATTRIB_ARRAY_POINTER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8645) } },
    { "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x889F) } },
    { "IMPLEMENTATION_COLOR_READ_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B9A) } },
    { "IMPLEMENTATION_COLOR_READ_FORMAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B9B) } },
    { "COMPILE_STATUS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B81) } },
    { "LOW_FLOAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DF0) } },
    { "MEDIUM_FLOAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DF1) } },
    { "HIGH_FLOAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DF2) } },
    { "LOW_INT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DF3) } },
    { "MEDIUM_INT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DF4) } },
    { "HIGH_INT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DF5) } },
    { "FRAMEBUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D40) } },
    { "RENDERBUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D41) } },
    { "RGBA4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8056) } },
    { "RGB5_A1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8057) } },
    { "RGB565", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D62) } },
    { "DEPTH_COMPONENT16", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x81A5) } },
    { "STENCIL_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1901) } },
    { "STENCIL_INDEX8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D48) } },
    { "DEPTH_STENCIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84F9) } },
    { "RENDERBUFFER_WIDTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D42) } },
    { "RENDERBUFFER_HEIGHT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D43) } },
    { "RENDERBUFFER_INTERNAL_FORMAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D44) } },
    { "RENDERBUFFER_RED_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D50) } },
    { "RENDERBUFFER_GREEN_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D51) } },
    { "RENDERBUFFER_BLUE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D52) } },
    { "RENDERBUFFER_ALPHA_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D53) } },
    { "RENDERBUFFER_DEPTH_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D54) } },
    { "RENDERBUFFER_STENCIL_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D55) } },
    { "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD0) } },
    { "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD1) } },
    { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD2) } },
    { "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD3) } },
    { "COLOR_ATTACHMENT0", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE0) } },
    { "DEPTH_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D00) } },
    { "STENCIL_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D20) } },
    { "DEPTH_STENCIL_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x821A) } },
    { "NONE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0) } },
    { "FRAMEBUFFER_COMPLETE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD5) } },
    { "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD6) } },
    { "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD7) } },
    { "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD9) } },
    { "FRAMEBUFFER_UNSUPPORTED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CDD) } },
    { "FRAMEBUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA6) } },
    { "RENDERBUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA7) } },
    { "MAX_RENDERBUFFER_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84E8) } },
    { "INVALID_FRAMEBUFFER_OPERATION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0506) } },
    { "UNPACK_FLIP_Y_WEBGL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9240) } },
    { "UNPACK_PREMULTIPLY_ALPHA_WEBGL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9241) } },
    { "CONTEXT_LOST_WEBGL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9242) } },
    { "UNPACK_COLORSPACE_CONVERSION_WEBGL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9243) } },
    { "BROWSER_DEFAULT_WEBGL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9244) } },
};

const ClassInfo JSWebGLRenderingContextBasePrototype::s_info = { "WebGLRenderingContextBasePrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSWebGLRenderingContextBasePrototype) };

void JSWebGLRenderingContextBasePrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSWebGLRenderingContextBasePrototypeTableValues, *this);
}

const ClassInfo JSWebGLRenderingContextBase::s_info = { "WebGLRenderingContextBase", &Base::s_info, 0, CREATE_METHOD_TABLE(JSWebGLRenderingContextBase) };

JSWebGLRenderingContextBase::JSWebGLRenderingContextBase(Structure* structure, JSDOMGlobalObject& globalObject, Ref<WebGLRenderingContextBase>&& impl)
    : JSDOMWrapper<WebGLRenderingContextBase>(structure, globalObject, WTFMove(impl))
{
}

void JSWebGLRenderingContextBase::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));

}

JSObject* JSWebGLRenderingContextBase::createPrototype(VM& vm, JSGlobalObject* globalObject)
{
    return JSWebGLRenderingContextBasePrototype::create(vm, globalObject, JSWebGLRenderingContextBasePrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

JSObject* JSWebGLRenderingContextBase::prototype(VM& vm, JSGlobalObject* globalObject)
{
    return getDOMPrototype<JSWebGLRenderingContextBase>(vm, globalObject);
}

void JSWebGLRenderingContextBase::destroy(JSC::JSCell* cell)
{
    JSWebGLRenderingContextBase* thisObject = static_cast<JSWebGLRenderingContextBase*>(cell);
    thisObject->JSWebGLRenderingContextBase::~JSWebGLRenderingContextBase();
}

template<> inline JSWebGLRenderingContextBase* BindingCaller<JSWebGLRenderingContextBase>::castForAttribute(ExecState&, EncodedJSValue thisValue)
{
    return jsDynamicDowncast<JSWebGLRenderingContextBase*>(JSValue::decode(thisValue));
}

template<> inline JSWebGLRenderingContextBase* BindingCaller<JSWebGLRenderingContextBase>::castForOperation(ExecState& state)
{
    return jsDynamicDowncast<JSWebGLRenderingContextBase*>(state.thisValue());
}

static inline JSValue jsWebGLRenderingContextBaseCanvasGetter(ExecState&, JSWebGLRenderingContextBase&, ThrowScope& throwScope);

EncodedJSValue jsWebGLRenderingContextBaseCanvas(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSWebGLRenderingContextBase>::attribute<jsWebGLRenderingContextBaseCanvasGetter>(state, thisValue, "canvas");
}

static inline JSValue jsWebGLRenderingContextBaseCanvasGetter(ExecState& state, JSWebGLRenderingContextBase& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLInterface<HTMLCanvasElement>>(state, *thisObject.globalObject(), impl.canvas());
    return result;
}

static inline JSValue jsWebGLRenderingContextBaseDrawingBufferWidthGetter(ExecState&, JSWebGLRenderingContextBase&, ThrowScope& throwScope);

EncodedJSValue jsWebGLRenderingContextBaseDrawingBufferWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSWebGLRenderingContextBase>::attribute<jsWebGLRenderingContextBaseDrawingBufferWidthGetter>(state, thisValue, "drawingBufferWidth");
}

static inline JSValue jsWebGLRenderingContextBaseDrawingBufferWidthGetter(ExecState& state, JSWebGLRenderingContextBase& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLLong>(impl.drawingBufferWidth());
    return result;
}

static inline JSValue jsWebGLRenderingContextBaseDrawingBufferHeightGetter(ExecState&, JSWebGLRenderingContextBase&, ThrowScope& throwScope);

EncodedJSValue jsWebGLRenderingContextBaseDrawingBufferHeight(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    return BindingCaller<JSWebGLRenderingContextBase>::attribute<jsWebGLRenderingContextBaseDrawingBufferHeightGetter>(state, thisValue, "drawingBufferHeight");
}

static inline JSValue jsWebGLRenderingContextBaseDrawingBufferHeightGetter(ExecState& state, JSWebGLRenderingContextBase& thisObject, ThrowScope& throwScope)
{
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(state);
    auto& impl = thisObject.wrapped();
    JSValue result = toJS<IDLLong>(impl.drawingBufferHeight());
    return result;
}

bool setJSWebGLRenderingContextBaseConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSValue value = JSValue::decode(encodedValue);
    JSWebGLRenderingContextBasePrototype* domObject = jsDynamicDowncast<JSWebGLRenderingContextBasePrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject)) {
        throwVMTypeError(state, throwScope);
        return false;
    }
    // Shadowing a built-in constructor
    return domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionActiveTextureCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionActiveTexture(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionActiveTextureCaller>(state, "activeTexture");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionActiveTextureCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto texture = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.activeTexture(WTFMove(texture));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionAttachShaderCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionAttachShader(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionAttachShaderCaller>(state, "attachShader");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionAttachShaderCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "attachShader", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto shader = convert<IDLNullable<IDLInterface<WebGLShader>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "shader", "WebGLRenderingContextBase", "attachShader", "WebGLShader"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.attachShader(WTFMove(program), WTFMove(shader));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBindAttribLocationCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindAttribLocation(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBindAttribLocationCaller>(state, "bindAttribLocation");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBindAttribLocationCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "bindAttribLocation", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto name = convert<IDLDOMString>(*state, state->uncheckedArgument(2), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bindAttribLocation(WTFMove(program), WTFMove(index), WTFMove(name));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBindBufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindBuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBindBufferCaller>(state, "bindBuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBindBufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto buffer = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "buffer", "WebGLRenderingContextBase", "bindBuffer", "WebGLBuffer"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bindBuffer(WTFMove(target), WTFMove(buffer));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBindFramebufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindFramebuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBindFramebufferCaller>(state, "bindFramebuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBindFramebufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto framebuffer = convert<IDLNullable<IDLInterface<WebGLFramebuffer>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "framebuffer", "WebGLRenderingContextBase", "bindFramebuffer", "WebGLFramebuffer"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bindFramebuffer(WTFMove(target), WTFMove(framebuffer));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBindRenderbufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindRenderbuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBindRenderbufferCaller>(state, "bindRenderbuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBindRenderbufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto renderbuffer = convert<IDLNullable<IDLInterface<WebGLRenderbuffer>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "renderbuffer", "WebGLRenderingContextBase", "bindRenderbuffer", "WebGLRenderbuffer"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bindRenderbuffer(WTFMove(target), WTFMove(renderbuffer));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBindTextureCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindTexture(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBindTextureCaller>(state, "bindTexture");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBindTextureCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto texture = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "texture", "WebGLRenderingContextBase", "bindTexture", "WebGLTexture"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bindTexture(WTFMove(target), WTFMove(texture));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBlendColorCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendColor(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBlendColorCaller>(state, "blendColor");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBlendColorCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto red = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto green = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto blue = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto alpha = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(3));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.blendColor(WTFMove(red), WTFMove(green), WTFMove(blue), WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBlendEquationCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendEquation(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBlendEquationCaller>(state, "blendEquation");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBlendEquationCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto mode = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.blendEquation(WTFMove(mode));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBlendEquationSeparateCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendEquationSeparate(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBlendEquationSeparateCaller>(state, "blendEquationSeparate");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBlendEquationSeparateCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto modeRGB = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto modeAlpha = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.blendEquationSeparate(WTFMove(modeRGB), WTFMove(modeAlpha));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBlendFuncCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendFunc(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBlendFuncCaller>(state, "blendFunc");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBlendFuncCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto sfactor = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto dfactor = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.blendFunc(WTFMove(sfactor), WTFMove(dfactor));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBlendFuncSeparateCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendFuncSeparate(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBlendFuncSeparateCaller>(state, "blendFuncSeparate");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBlendFuncSeparateCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto srcRGB = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto dstRGB = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto srcAlpha = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto dstAlpha = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.blendFuncSeparate(WTFMove(srcRGB), WTFMove(dstRGB), WTFMove(srcAlpha), WTFMove(dstAlpha));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferData1Caller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferData1(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBufferData1Caller>(state, "bufferData");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferData1Caller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto data = convert<IDLNullable<IDLUnion<IDLInterface<ArrayBuffer>, IDLInterface<ArrayBufferView>>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto usage = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bufferData(WTFMove(target), WTFMove(data), WTFMove(usage));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferData2Caller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferData2(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBufferData2Caller>(state, "bufferData");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferData2Caller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto size = convert<IDLLongLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto usage = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bufferData(WTFMove(target), WTFMove(size), WTFMove(usage));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBufferData(ExecState* state)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    size_t argsCount = std::min<size_t>(3, state->argumentCount());
    if (argsCount == 3) {
        JSValue distinguishingArg = state->uncheckedArgument(1);
        if (distinguishingArg.isUndefinedOrNull())
            return jsWebGLRenderingContextBasePrototypeFunctionBufferData1(state);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSArrayBuffer::info()))
            return jsWebGLRenderingContextBasePrototypeFunctionBufferData1(state);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSArrayBufferView::info()))
            return jsWebGLRenderingContextBasePrototypeFunctionBufferData1(state);
        if (distinguishingArg.isNumber())
            return jsWebGLRenderingContextBasePrototypeFunctionBufferData2(state);
        return jsWebGLRenderingContextBasePrototypeFunctionBufferData2(state);
    }
    return argsCount < 3 ? throwVMError(state, throwScope, createNotEnoughArgumentsError(state)) : throwVMTypeError(state, throwScope);
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferSubDataCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBufferSubData(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionBufferSubDataCaller>(state, "bufferSubData");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferSubDataCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto offset = convert<IDLLongLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto data = convert<IDLNullable<IDLUnion<IDLInterface<ArrayBuffer>, IDLInterface<ArrayBufferView>>>>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bufferSubData(WTFMove(target), WTFMove(offset), WTFMove(data));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCheckFramebufferStatusCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCheckFramebufferStatus(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCheckFramebufferStatusCaller>(state, "checkFramebufferStatus");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCheckFramebufferStatusCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLUnsignedLong>(impl.checkFramebufferStatus(WTFMove(target))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionClearCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClear(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionClearCaller>(state, "clear");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionClearCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto mask = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.clear(WTFMove(mask));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionClearColorCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClearColor(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionClearColorCaller>(state, "clearColor");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionClearColorCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto red = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto green = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto blue = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto alpha = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(3));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.clearColor(WTFMove(red), WTFMove(green), WTFMove(blue), WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionClearDepthCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClearDepth(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionClearDepthCaller>(state, "clearDepth");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionClearDepthCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto depth = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.clearDepth(WTFMove(depth));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionClearStencilCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClearStencil(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionClearStencilCaller>(state, "clearStencil");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionClearStencilCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto s = convert<IDLLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.clearStencil(WTFMove(s));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionColorMaskCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionColorMask(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionColorMaskCaller>(state, "colorMask");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionColorMaskCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto red = convert<IDLBoolean>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto green = convert<IDLBoolean>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto blue = convert<IDLBoolean>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto alpha = convert<IDLBoolean>(*state, state->uncheckedArgument(3));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.colorMask(WTFMove(red), WTFMove(green), WTFMove(blue), WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCompileShaderCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCompileShader(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCompileShaderCaller>(state, "compileShader");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCompileShaderCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto shader = convert<IDLNullable<IDLInterface<WebGLShader>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "shader", "WebGLRenderingContextBase", "compileShader", "WebGLShader"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.compileShader(WTFMove(shader));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCompressedTexImage2DCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCompressedTexImage2D(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCompressedTexImage2DCaller>(state, "compressedTexImage2D");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCompressedTexImage2DCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto internalformat = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto border = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto data = convert<IDLInterface<ArrayBufferView>>(*state, state->uncheckedArgument(6), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 6, "data", "WebGLRenderingContextBase", "compressedTexImage2D", "ArrayBufferView"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.compressedTexImage2D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(width), WTFMove(height), WTFMove(border), data.releaseNonNull());
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCompressedTexSubImage2DCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCompressedTexSubImage2D(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCompressedTexSubImage2DCaller>(state, "compressedTexSubImage2D");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCompressedTexSubImage2DCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 8))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto xoffset = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto yoffset = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto format = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(6), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto data = convert<IDLInterface<ArrayBufferView>>(*state, state->uncheckedArgument(7), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 7, "data", "WebGLRenderingContextBase", "compressedTexSubImage2D", "ArrayBufferView"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.compressedTexSubImage2D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(width), WTFMove(height), WTFMove(format), data.releaseNonNull());
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCopyTexImage2DCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCopyTexImage2D(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCopyTexImage2DCaller>(state, "copyTexImage2D");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCopyTexImage2DCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 8))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto internalformat = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(6), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto border = convert<IDLLong>(*state, state->uncheckedArgument(7), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.copyTexImage2D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height), WTFMove(border));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCopyTexSubImage2DCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCopyTexSubImage2D(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCopyTexSubImage2DCaller>(state, "copyTexSubImage2D");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCopyTexSubImage2DCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 8))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto xoffset = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto yoffset = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(6), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(7), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.copyTexSubImage2D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCreateBufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateBuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCreateBufferCaller>(state, "createBuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCreateBufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLInterface<WebGLBuffer>>(*state, *castedThis->globalObject(), impl.createBuffer()));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCreateFramebufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateFramebuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCreateFramebufferCaller>(state, "createFramebuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCreateFramebufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLInterface<WebGLFramebuffer>>(*state, *castedThis->globalObject(), impl.createFramebuffer()));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCreateProgramCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateProgram(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCreateProgramCaller>(state, "createProgram");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCreateProgramCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLInterface<WebGLProgram>>(*state, *castedThis->globalObject(), impl.createProgram()));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCreateRenderbufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateRenderbuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCreateRenderbufferCaller>(state, "createRenderbuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCreateRenderbufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLInterface<WebGLRenderbuffer>>(*state, *castedThis->globalObject(), impl.createRenderbuffer()));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCreateShaderCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateShader(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCreateShaderCaller>(state, "createShader");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCreateShaderCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<WebGLShader>>(*state, *castedThis->globalObject(), impl.createShader(WTFMove(type))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCreateTextureCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateTexture(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCreateTextureCaller>(state, "createTexture");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCreateTextureCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLInterface<WebGLTexture>>(*state, *castedThis->globalObject(), impl.createTexture()));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCullFaceCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCullFace(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionCullFaceCaller>(state, "cullFace");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionCullFaceCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto mode = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.cullFace(WTFMove(mode));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDeleteBufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteBuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDeleteBufferCaller>(state, "deleteBuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDeleteBufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto buffer = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "buffer", "WebGLRenderingContextBase", "deleteBuffer", "WebGLBuffer"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.deleteBuffer(WTFMove(buffer));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDeleteFramebufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteFramebuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDeleteFramebufferCaller>(state, "deleteFramebuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDeleteFramebufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto framebuffer = convert<IDLNullable<IDLInterface<WebGLFramebuffer>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "framebuffer", "WebGLRenderingContextBase", "deleteFramebuffer", "WebGLFramebuffer"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.deleteFramebuffer(WTFMove(framebuffer));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDeleteProgramCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteProgram(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDeleteProgramCaller>(state, "deleteProgram");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDeleteProgramCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "deleteProgram", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.deleteProgram(WTFMove(program));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDeleteRenderbufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteRenderbuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDeleteRenderbufferCaller>(state, "deleteRenderbuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDeleteRenderbufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto renderbuffer = convert<IDLNullable<IDLInterface<WebGLRenderbuffer>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "renderbuffer", "WebGLRenderingContextBase", "deleteRenderbuffer", "WebGLRenderbuffer"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.deleteRenderbuffer(WTFMove(renderbuffer));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDeleteShaderCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteShader(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDeleteShaderCaller>(state, "deleteShader");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDeleteShaderCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto shader = convert<IDLNullable<IDLInterface<WebGLShader>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "shader", "WebGLRenderingContextBase", "deleteShader", "WebGLShader"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.deleteShader(WTFMove(shader));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDeleteTextureCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteTexture(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDeleteTextureCaller>(state, "deleteTexture");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDeleteTextureCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto texture = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "texture", "WebGLRenderingContextBase", "deleteTexture", "WebGLTexture"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.deleteTexture(WTFMove(texture));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDepthFuncCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDepthFunc(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDepthFuncCaller>(state, "depthFunc");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDepthFuncCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto func = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.depthFunc(WTFMove(func));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDepthMaskCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDepthMask(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDepthMaskCaller>(state, "depthMask");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDepthMaskCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto flag = convert<IDLBoolean>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.depthMask(WTFMove(flag));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDepthRangeCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDepthRange(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDepthRangeCaller>(state, "depthRange");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDepthRangeCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto zNear = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto zFar = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.depthRange(WTFMove(zNear), WTFMove(zFar));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDetachShaderCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDetachShader(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDetachShaderCaller>(state, "detachShader");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDetachShaderCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "detachShader", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto shader = convert<IDLNullable<IDLInterface<WebGLShader>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "shader", "WebGLRenderingContextBase", "detachShader", "WebGLShader"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.detachShader(WTFMove(program), WTFMove(shader));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDisableCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDisable(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDisableCaller>(state, "disable");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDisableCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto cap = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.disable(WTFMove(cap));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDisableVertexAttribArrayCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDisableVertexAttribArray(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDisableVertexAttribArrayCaller>(state, "disableVertexAttribArray");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDisableVertexAttribArrayCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.disableVertexAttribArray(WTFMove(index));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDrawArraysCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDrawArrays(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDrawArraysCaller>(state, "drawArrays");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDrawArraysCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto mode = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto first = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto count = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.drawArrays(WTFMove(mode), WTFMove(first), WTFMove(count));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDrawElementsCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDrawElements(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionDrawElementsCaller>(state, "drawElements");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionDrawElementsCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto mode = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto count = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto offset = convert<IDLLongLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.drawElements(WTFMove(mode), WTFMove(count), WTFMove(type), WTFMove(offset));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionEnableCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionEnable(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionEnableCaller>(state, "enable");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionEnableCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto cap = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.enable(WTFMove(cap));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionEnableVertexAttribArrayCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionEnableVertexAttribArray(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionEnableVertexAttribArrayCaller>(state, "enableVertexAttribArray");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionEnableVertexAttribArrayCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.enableVertexAttribArray(WTFMove(index));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionFinishCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFinish(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionFinishCaller>(state, "finish");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionFinishCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.finish();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionFlushCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFlush(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionFlushCaller>(state, "flush");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionFlushCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.flush();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionFramebufferRenderbufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFramebufferRenderbuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionFramebufferRenderbufferCaller>(state, "framebufferRenderbuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionFramebufferRenderbufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto attachment = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto renderbuffertarget = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto renderbuffer = convert<IDLNullable<IDLInterface<WebGLRenderbuffer>>>(*state, state->uncheckedArgument(3), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 3, "renderbuffer", "WebGLRenderingContextBase", "framebufferRenderbuffer", "WebGLRenderbuffer"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.framebufferRenderbuffer(WTFMove(target), WTFMove(attachment), WTFMove(renderbuffertarget), WTFMove(renderbuffer));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionFramebufferTexture2DCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFramebufferTexture2D(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionFramebufferTexture2DCaller>(state, "framebufferTexture2D");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionFramebufferTexture2DCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto attachment = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto textarget = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto texture = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*state, state->uncheckedArgument(3), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 3, "texture", "WebGLRenderingContextBase", "framebufferTexture2D", "WebGLTexture"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.framebufferTexture2D(WTFMove(target), WTFMove(attachment), WTFMove(textarget), WTFMove(texture), WTFMove(level));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionFrontFaceCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFrontFace(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionFrontFaceCaller>(state, "frontFace");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionFrontFaceCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto mode = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.frontFace(WTFMove(mode));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGenerateMipmapCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGenerateMipmap(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGenerateMipmapCaller>(state, "generateMipmap");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGenerateMipmapCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.generateMipmap(WTFMove(target));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetActiveAttribCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetActiveAttrib(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetActiveAttribCaller>(state, "getActiveAttrib");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetActiveAttribCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "getActiveAttrib", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<WebGLActiveInfo>>(*state, *castedThis->globalObject(), impl.getActiveAttrib(WTFMove(program), WTFMove(index))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetActiveUniformCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetActiveUniform(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetActiveUniformCaller>(state, "getActiveUniform");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetActiveUniformCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "getActiveUniform", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<WebGLActiveInfo>>(*state, *castedThis->globalObject(), impl.getActiveUniform(WTFMove(program), WTFMove(index))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetAttachedShadersCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetAttachedShaders(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetAttachedShadersCaller>(state, "getAttachedShaders");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetAttachedShadersCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "getAttachedShaders", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLSequence<IDLInterface<WebGLShader>>>>(*state, *castedThis->globalObject(), impl.getAttachedShaders(WTFMove(program))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetAttribLocationCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetAttribLocation(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetAttribLocationCaller>(state, "getAttribLocation");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetAttribLocationCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "getAttribLocation", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto name = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLLong>(impl.getAttribLocation(WTFMove(program), WTFMove(name))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetBufferParameterCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetBufferParameter(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetBufferParameterCaller>(state, "getBufferParameter");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetBufferParameterCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getBufferParameter(WTFMove(target), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetContextAttributesCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetContextAttributes(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetContextAttributesCaller>(state, "getContextAttributes");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetContextAttributesCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLNullable<IDLDictionary<WebGLContextAttributes>>>(*state, *castedThis->globalObject(), impl.getContextAttributes()));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetErrorCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetError(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetErrorCaller>(state, "getError");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetErrorCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLUnsignedLong>(impl.getError()));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetSupportedExtensionsCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetSupportedExtensions(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetSupportedExtensionsCaller>(state, "getSupportedExtensions");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetSupportedExtensionsCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLNullable<IDLSequence<IDLDOMString>>>(*state, *castedThis->globalObject(), impl.getSupportedExtensions()));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetExtensionCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetExtension(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetExtensionCaller>(state, "getExtension");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetExtensionCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    return JSValue::encode(castedThis->getExtension(*state));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetFramebufferAttachmentParameterCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetFramebufferAttachmentParameter(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetFramebufferAttachmentParameterCaller>(state, "getFramebufferAttachmentParameter");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetFramebufferAttachmentParameterCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto attachment = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getFramebufferAttachmentParameter(WTFMove(target), WTFMove(attachment), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetParameterCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetParameter(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetParameterCaller>(state, "getParameter");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetParameterCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getParameter(WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetProgramParameterCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetProgramParameter(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetProgramParameterCaller>(state, "getProgramParameter");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetProgramParameterCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "getProgramParameter", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getProgramParameter(WTFMove(program), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetProgramInfoLogCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetProgramInfoLog(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetProgramInfoLogCaller>(state, "getProgramInfoLog");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetProgramInfoLogCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "getProgramInfoLog", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLDOMString>>(*state, impl.getProgramInfoLog(WTFMove(program))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetRenderbufferParameterCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetRenderbufferParameter(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetRenderbufferParameterCaller>(state, "getRenderbufferParameter");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetRenderbufferParameterCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getRenderbufferParameter(WTFMove(target), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetShaderParameterCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderParameter(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetShaderParameterCaller>(state, "getShaderParameter");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetShaderParameterCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto shader = convert<IDLNullable<IDLInterface<WebGLShader>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "shader", "WebGLRenderingContextBase", "getShaderParameter", "WebGLShader"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getShaderParameter(WTFMove(shader), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetShaderInfoLogCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderInfoLog(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetShaderInfoLogCaller>(state, "getShaderInfoLog");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetShaderInfoLogCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto shader = convert<IDLNullable<IDLInterface<WebGLShader>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "shader", "WebGLRenderingContextBase", "getShaderInfoLog", "WebGLShader"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLDOMString>>(*state, impl.getShaderInfoLog(WTFMove(shader))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetShaderPrecisionFormatCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderPrecisionFormat(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetShaderPrecisionFormatCaller>(state, "getShaderPrecisionFormat");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetShaderPrecisionFormatCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto shadertype = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto precisiontype = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<WebGLShaderPrecisionFormat>>(*state, *castedThis->globalObject(), impl.getShaderPrecisionFormat(WTFMove(shadertype), WTFMove(precisiontype))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetShaderSourceCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderSource(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetShaderSourceCaller>(state, "getShaderSource");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetShaderSourceCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto shader = convert<IDLNullable<IDLInterface<WebGLShader>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "shader", "WebGLRenderingContextBase", "getShaderSource", "WebGLShader"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLNullable<IDLDOMString>>(*state, impl.getShaderSource(WTFMove(shader))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetTexParameterCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetTexParameter(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetTexParameterCaller>(state, "getTexParameter");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetTexParameterCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getTexParameter(WTFMove(target), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetUniformCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetUniform(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetUniformCaller>(state, "getUniform");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetUniformCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "getUniform", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "location", "WebGLRenderingContextBase", "getUniform", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getUniform(WTFMove(program), WTFMove(location))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetUniformLocationCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetUniformLocation(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetUniformLocationCaller>(state, "getUniformLocation");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetUniformLocationCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "getUniformLocation", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto name = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<WebGLUniformLocation>>(*state, *castedThis->globalObject(), impl.getUniformLocation(WTFMove(program), WTFMove(name))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttribCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttrib(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttribCaller>(state, "getVertexAttrib");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttribCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getVertexAttrib(WTFMove(index), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttribOffsetCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttribOffset(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttribOffsetCaller>(state, "getVertexAttribOffset");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttribOffsetCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLLongLong>(impl.getVertexAttribOffset(WTFMove(index), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionHintCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionHint(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionHintCaller>(state, "hint");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionHintCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto mode = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.hint(WTFMove(target), WTFMove(mode));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsBufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsBuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionIsBufferCaller>(state, "isBuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsBufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto buffer = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "buffer", "WebGLRenderingContextBase", "isBuffer", "WebGLBuffer"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.isBuffer(WTFMove(buffer))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsContextLostCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsContextLost(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionIsContextLostCaller>(state, "isContextLost");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsContextLostCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLBoolean>(impl.isContextLost()));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsEnabledCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsEnabled(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionIsEnabledCaller>(state, "isEnabled");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsEnabledCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto cap = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.isEnabled(WTFMove(cap))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsFramebufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsFramebuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionIsFramebufferCaller>(state, "isFramebuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsFramebufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto framebuffer = convert<IDLNullable<IDLInterface<WebGLFramebuffer>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "framebuffer", "WebGLRenderingContextBase", "isFramebuffer", "WebGLFramebuffer"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.isFramebuffer(WTFMove(framebuffer))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsProgramCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsProgram(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionIsProgramCaller>(state, "isProgram");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsProgramCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "isProgram", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.isProgram(WTFMove(program))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsRenderbufferCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsRenderbuffer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionIsRenderbufferCaller>(state, "isRenderbuffer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsRenderbufferCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto renderbuffer = convert<IDLNullable<IDLInterface<WebGLRenderbuffer>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "renderbuffer", "WebGLRenderingContextBase", "isRenderbuffer", "WebGLRenderbuffer"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.isRenderbuffer(WTFMove(renderbuffer))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsShaderCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsShader(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionIsShaderCaller>(state, "isShader");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsShaderCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto shader = convert<IDLNullable<IDLInterface<WebGLShader>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "shader", "WebGLRenderingContextBase", "isShader", "WebGLShader"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.isShader(WTFMove(shader))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsTextureCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsTexture(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionIsTextureCaller>(state, "isTexture");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionIsTextureCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto texture = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "texture", "WebGLRenderingContextBase", "isTexture", "WebGLTexture"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.isTexture(WTFMove(texture))));
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionLineWidthCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionLineWidth(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionLineWidthCaller>(state, "lineWidth");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionLineWidthCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto width = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.lineWidth(WTFMove(width));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionLinkProgramCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionLinkProgram(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionLinkProgramCaller>(state, "linkProgram");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionLinkProgramCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "linkProgram", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.linkProgram(WTFMove(program));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionPixelStoreiCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionPixelStorei(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionPixelStoreiCaller>(state, "pixelStorei");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionPixelStoreiCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto param = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.pixelStorei(WTFMove(pname), WTFMove(param));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionPolygonOffsetCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionPolygonOffset(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionPolygonOffsetCaller>(state, "polygonOffset");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionPolygonOffsetCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto factor = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto units = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.polygonOffset(WTFMove(factor), WTFMove(units));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionReadPixelsCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionReadPixels(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionReadPixelsCaller>(state, "readPixels");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionReadPixelsCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto x = convert<IDLLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto format = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pixels = convert<IDLInterface<ArrayBufferView>>(*state, state->uncheckedArgument(6), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 6, "pixels", "WebGLRenderingContextBase", "readPixels", "ArrayBufferView"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.readPixels(WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height), WTFMove(format), WTFMove(type), pixels.releaseNonNull());
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionReleaseShaderCompilerCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionReleaseShaderCompiler(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionReleaseShaderCompilerCaller>(state, "releaseShaderCompiler");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionReleaseShaderCompilerCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.releaseShaderCompiler();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionRenderbufferStorageCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionRenderbufferStorage(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionRenderbufferStorageCaller>(state, "renderbufferStorage");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionRenderbufferStorageCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto internalformat = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.renderbufferStorage(WTFMove(target), WTFMove(internalformat), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionSampleCoverageCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionSampleCoverage(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionSampleCoverageCaller>(state, "sampleCoverage");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionSampleCoverageCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto value = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto invert = convert<IDLBoolean>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.sampleCoverage(WTFMove(value), WTFMove(invert));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionScissorCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionScissor(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionScissorCaller>(state, "scissor");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionScissorCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto x = convert<IDLLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.scissor(WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionShaderSourceCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionShaderSource(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionShaderSourceCaller>(state, "shaderSource");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionShaderSourceCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto shader = convert<IDLNullable<IDLInterface<WebGLShader>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "shader", "WebGLRenderingContextBase", "shaderSource", "WebGLShader"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto string = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.shaderSource(WTFMove(shader), WTFMove(string));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionStencilFuncCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilFunc(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionStencilFuncCaller>(state, "stencilFunc");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionStencilFuncCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto func = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto ref = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto mask = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.stencilFunc(WTFMove(func), WTFMove(ref), WTFMove(mask));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionStencilFuncSeparateCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilFuncSeparate(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionStencilFuncSeparateCaller>(state, "stencilFuncSeparate");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionStencilFuncSeparateCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto face = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto func = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto ref = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto mask = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.stencilFuncSeparate(WTFMove(face), WTFMove(func), WTFMove(ref), WTFMove(mask));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionStencilMaskCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilMask(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionStencilMaskCaller>(state, "stencilMask");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionStencilMaskCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto mask = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.stencilMask(WTFMove(mask));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionStencilMaskSeparateCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilMaskSeparate(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionStencilMaskSeparateCaller>(state, "stencilMaskSeparate");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionStencilMaskSeparateCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto face = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto mask = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.stencilMaskSeparate(WTFMove(face), WTFMove(mask));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionStencilOpCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilOp(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionStencilOpCaller>(state, "stencilOp");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionStencilOpCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto fail = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto zfail = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto zpass = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.stencilOp(WTFMove(fail), WTFMove(zfail), WTFMove(zpass));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionStencilOpSeparateCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilOpSeparate(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionStencilOpSeparateCaller>(state, "stencilOpSeparate");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionStencilOpSeparateCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto face = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto fail = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto zfail = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto zpass = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.stencilOpSeparate(WTFMove(face), WTFMove(fail), WTFMove(zfail), WTFMove(zpass));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexParameterfCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexParameterf(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionTexParameterfCaller>(state, "texParameterf");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexParameterfCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto param = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.texParameterf(WTFMove(target), WTFMove(pname), WTFMove(param));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexParameteriCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexParameteri(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionTexParameteriCaller>(state, "texParameteri");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexParameteriCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto param = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.texParameteri(WTFMove(target), WTFMove(pname), WTFMove(param));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexImage2D1Caller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexImage2D1(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionTexImage2D1Caller>(state, "texImage2D");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexImage2D1Caller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 9))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto internalformat = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto border = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto format = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(6), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(7), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pixels = convert<IDLNullable<IDLInterface<ArrayBufferView>>>(*state, state->uncheckedArgument(8), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 8, "pixels", "WebGLRenderingContextBase", "texImage2D", "ArrayBufferView"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.texImage2D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(width), WTFMove(height), WTFMove(border), WTFMove(format), WTFMove(type), WTFMove(pixels));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexImage2D2Caller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexImage2D2(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionTexImage2D2Caller>(state, "texImage2D");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexImage2D2Caller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto internalformat = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto format = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto source = convert<IDLNullable<IDLUnion<IDLInterface<ImageData>, IDLInterface<HTMLImageElement>, IDLInterface<HTMLCanvasElement>, IDLInterface<HTMLVideoElement>>>>(*state, state->uncheckedArgument(5));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    propagateException(*state, throwScope, impl.texImage2D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(format), WTFMove(type), WTFMove(source)));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexImage2D(ExecState* state)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    size_t argsCount = std::min<size_t>(9, state->argumentCount());
    if (argsCount == 6) {
        return jsWebGLRenderingContextBasePrototypeFunctionTexImage2D2(state);
    }
    if (argsCount == 9) {
        return jsWebGLRenderingContextBasePrototypeFunctionTexImage2D1(state);
    }
    return argsCount < 6 ? throwVMError(state, throwScope, createNotEnoughArgumentsError(state)) : throwVMTypeError(state, throwScope);
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D1Caller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D1(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D1Caller>(state, "texSubImage2D");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D1Caller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 9))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto xoffset = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto yoffset = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto format = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(6), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(7), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pixels = convert<IDLNullable<IDLInterface<ArrayBufferView>>>(*state, state->uncheckedArgument(8), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 8, "pixels", "WebGLRenderingContextBase", "texSubImage2D", "ArrayBufferView"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.texSubImage2D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(width), WTFMove(height), WTFMove(format), WTFMove(type), WTFMove(pixels));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D2Caller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D2(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D2Caller>(state, "texSubImage2D");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D2Caller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto xoffset = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto yoffset = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto format = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto source = convert<IDLNullable<IDLUnion<IDLInterface<ImageData>, IDLInterface<HTMLImageElement>, IDLInterface<HTMLCanvasElement>, IDLInterface<HTMLVideoElement>>>>(*state, state->uncheckedArgument(6));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    propagateException(*state, throwScope, impl.texSubImage2D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(format), WTFMove(type), WTFMove(source)));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D(ExecState* state)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    size_t argsCount = std::min<size_t>(9, state->argumentCount());
    if (argsCount == 7) {
        return jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D2(state);
    }
    if (argsCount == 9) {
        return jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D1(state);
    }
    return argsCount < 7 ? throwVMError(state, throwScope, createNotEnoughArgumentsError(state)) : throwVMTypeError(state, throwScope);
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform1fCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1f(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform1fCaller>(state, "uniform1f");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform1fCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform1f", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform1f(WTFMove(location), WTFMove(x));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform2fCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2f(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform2fCaller>(state, "uniform2f");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform2fCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform2f", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform2f(WTFMove(location), WTFMove(x), WTFMove(y));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform3fCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3f(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform3fCaller>(state, "uniform3f");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform3fCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform3f", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto z = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(3));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform3f(WTFMove(location), WTFMove(x), WTFMove(y), WTFMove(z));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform4fCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4f(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform4fCaller>(state, "uniform4f");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform4fCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform4f", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto z = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(3));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto w = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(4));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform4f(WTFMove(location), WTFMove(x), WTFMove(y), WTFMove(z), WTFMove(w));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform1iCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1i(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform1iCaller>(state, "uniform1i");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform1iCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform1i", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform1i(WTFMove(location), WTFMove(x));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform2iCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2i(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform2iCaller>(state, "uniform2i");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform2iCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform2i", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform2i(WTFMove(location), WTFMove(x), WTFMove(y));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform3iCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3i(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform3iCaller>(state, "uniform3i");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform3iCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform3i", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto z = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform3i(WTFMove(location), WTFMove(x), WTFMove(y), WTFMove(z));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform4iCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4i(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform4iCaller>(state, "uniform4i");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform4iCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform4i", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto z = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto w = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform4i(WTFMove(location), WTFMove(x), WTFMove(y), WTFMove(z), WTFMove(w));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform1fvCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1fv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform1fvCaller>(state, "uniform1fv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform1fvCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform1fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v = convert<IDLUnion<IDLInterface<Float32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform1fv(WTFMove(location), WTFMove(v));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform2fvCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2fv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform2fvCaller>(state, "uniform2fv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform2fvCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform2fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v = convert<IDLUnion<IDLInterface<Float32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform2fv(WTFMove(location), WTFMove(v));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform3fvCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3fv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform3fvCaller>(state, "uniform3fv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform3fvCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform3fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v = convert<IDLUnion<IDLInterface<Float32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform3fv(WTFMove(location), WTFMove(v));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform4fvCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4fv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform4fvCaller>(state, "uniform4fv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform4fvCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform4fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v = convert<IDLUnion<IDLInterface<Float32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform4fv(WTFMove(location), WTFMove(v));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform1ivCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1iv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform1ivCaller>(state, "uniform1iv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform1ivCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform1iv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v = convert<IDLUnion<IDLInterface<Int32Array>, IDLSequence<IDLLong>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform1iv(WTFMove(location), WTFMove(v));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform2ivCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2iv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform2ivCaller>(state, "uniform2iv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform2ivCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform2iv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v = convert<IDLUnion<IDLInterface<Int32Array>, IDLSequence<IDLLong>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform2iv(WTFMove(location), WTFMove(v));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform3ivCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3iv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform3ivCaller>(state, "uniform3iv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform3ivCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform3iv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v = convert<IDLUnion<IDLInterface<Int32Array>, IDLSequence<IDLLong>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform3iv(WTFMove(location), WTFMove(v));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform4ivCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4iv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniform4ivCaller>(state, "uniform4iv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniform4ivCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniform4iv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v = convert<IDLUnion<IDLInterface<Int32Array>, IDLSequence<IDLLong>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform4iv(WTFMove(location), WTFMove(v));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix2fvCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix2fv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix2fvCaller>(state, "uniformMatrix2fv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix2fvCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniformMatrix2fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto transpose = convert<IDLBoolean>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto array = convert<IDLUnion<IDLInterface<Float32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniformMatrix2fv(WTFMove(location), WTFMove(transpose), WTFMove(array));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix3fvCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix3fv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix3fvCaller>(state, "uniformMatrix3fv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix3fvCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniformMatrix3fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto transpose = convert<IDLBoolean>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto array = convert<IDLUnion<IDLInterface<Float32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniformMatrix3fv(WTFMove(location), WTFMove(transpose), WTFMove(array));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix4fvCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix4fv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix4fvCaller>(state, "uniformMatrix4fv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix4fvCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGLRenderingContextBase", "uniformMatrix4fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto transpose = convert<IDLBoolean>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto array = convert<IDLUnion<IDLInterface<Float32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniformMatrix4fv(WTFMove(location), WTFMove(transpose), WTFMove(array));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUseProgramCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUseProgram(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionUseProgramCaller>(state, "useProgram");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionUseProgramCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "useProgram", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.useProgram(WTFMove(program));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionValidateProgramCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionValidateProgram(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionValidateProgramCaller>(state, "validateProgram");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionValidateProgramCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGLRenderingContextBase", "validateProgram", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.validateProgram(WTFMove(program));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1fCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1f(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1fCaller>(state, "vertexAttrib1f");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1fCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttrib1f(WTFMove(index), WTFMove(x));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2fCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2f(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2fCaller>(state, "vertexAttrib2f");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2fCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttrib2f(WTFMove(index), WTFMove(x), WTFMove(y));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3fCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3f(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3fCaller>(state, "vertexAttrib3f");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3fCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto z = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(3));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttrib3f(WTFMove(index), WTFMove(x), WTFMove(y), WTFMove(z));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4fCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4f(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4fCaller>(state, "vertexAttrib4f");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4fCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto z = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(3));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto w = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(4));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttrib4f(WTFMove(index), WTFMove(x), WTFMove(y), WTFMove(z), WTFMove(w));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1fvCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1fv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1fvCaller>(state, "vertexAttrib1fv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1fvCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto values = convert<IDLUnion<IDLInterface<Float32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttrib1fv(WTFMove(index), WTFMove(values));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2fvCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2fv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2fvCaller>(state, "vertexAttrib2fv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2fvCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto values = convert<IDLUnion<IDLInterface<Float32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttrib2fv(WTFMove(index), WTFMove(values));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3fvCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3fv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3fvCaller>(state, "vertexAttrib3fv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3fvCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto values = convert<IDLUnion<IDLInterface<Float32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttrib3fv(WTFMove(index), WTFMove(values));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4fvCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4fv(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4fvCaller>(state, "vertexAttrib4fv");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4fvCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto values = convert<IDLUnion<IDLInterface<Float32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttrib4fv(WTFMove(index), WTFMove(values));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttribPointerCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttribPointer(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionVertexAttribPointerCaller>(state, "vertexAttribPointer");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionVertexAttribPointerCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto indx = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto size = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto normalized = convert<IDLBoolean>(*state, state->uncheckedArgument(3));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto stride = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto offset = convert<IDLLongLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttribPointer(WTFMove(indx), WTFMove(size), WTFMove(type), WTFMove(normalized), WTFMove(stride), WTFMove(offset));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionViewportCaller(JSC::ExecState*, JSWebGLRenderingContextBase*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionViewport(ExecState* state)
{
    return BindingCaller<JSWebGLRenderingContextBase>::callOperation<jsWebGLRenderingContextBasePrototypeFunctionViewportCaller>(state, "viewport");
}

static inline JSC::EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionViewportCaller(JSC::ExecState* state, JSWebGLRenderingContextBase* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto x = convert<IDLLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.viewport(WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

void JSWebGLRenderingContextBase::visitChildren(JSCell* cell, SlotVisitor& visitor)
{
    auto* thisObject = jsCast<JSWebGLRenderingContextBase*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    thisObject->visitAdditionalChildren(visitor);
}

void JSWebGLRenderingContextBase::visitOutputConstraints(JSCell* cell, SlotVisitor& visitor)
{
    auto* thisObject = jsCast<JSWebGLRenderingContextBase*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitOutputConstraints(thisObject, visitor);
    thisObject->visitAdditionalChildren(visitor);
}

void JSWebGLRenderingContextBaseOwner::finalize(JSC::Handle<JSC::Unknown> handle, void* context)
{
    auto* jsWebGLRenderingContextBase = static_cast<JSWebGLRenderingContextBase*>(handle.slot()->asCell());
    auto& world = *static_cast<DOMWrapperWorld*>(context);
    uncacheWrapper(world, &jsWebGLRenderingContextBase->wrapped(), jsWebGLRenderingContextBase);
}

WebGLRenderingContextBase* JSWebGLRenderingContextBase::toWrapped(JSC::JSValue value)
{
    if (auto* wrapper = jsDynamicDowncast<JSWebGLRenderingContextBase*>(value))
        return &wrapper->wrapped();
    return nullptr;
}

}

#endif // ENABLE(WEBGL)
