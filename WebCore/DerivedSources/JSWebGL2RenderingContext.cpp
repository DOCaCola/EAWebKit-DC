/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(WEBGL2)

#include "JSWebGL2RenderingContext.h"

#include "JSDOMBinding.h"
#include "JSDOMConstructor.h"
#include "JSDOMConvert.h"
#include "JSHTMLCanvasElement.h"
#include "JSHTMLImageElement.h"
#include "JSHTMLVideoElement.h"
#include "JSImageData.h"
#include "JSWebGLActiveInfo.h"
#include "JSWebGLBuffer.h"
#include "JSWebGLProgram.h"
#include "JSWebGLQuery.h"
#include "JSWebGLSampler.h"
#include "JSWebGLSync.h"
#include "JSWebGLTransformFeedback.h"
#include "JSWebGLUniformLocation.h"
#include "JSWebGLVertexArrayObject.h"
#include <runtime/Error.h>
#include <runtime/FunctionPrototype.h>
#include <runtime/JSArray.h>
#include <wtf/GetPtr.h>
#include <wtf/Variant.h>

using namespace JSC;

namespace WebCore {

// Functions

JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBufferData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBufferSubData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCopyBufferSubData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetBufferSubData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBlitFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionFramebufferTextureLayer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetInternalformatParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionInvalidateFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionInvalidateSubFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionReadBuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionRenderbufferStorageMultisample(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexStorage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexStorage3D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexImage3D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCopyTexSubImage3D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCompressedTexImage3D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCompressedTexSubImage3D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetFragDataLocation(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform1ui(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform2ui(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform3ui(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform4ui(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform1uiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform2uiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform3uiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform4uiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x3fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x2fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x4fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x2fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x4fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x3fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4i(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4iv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4ui(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4uiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribIPointer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribDivisor(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawArraysInstanced(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawElementsInstanced(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawRangeElements(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawBuffers(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferuiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferfv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferfi(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateQuery(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteQuery(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsQuery(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBeginQuery(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionEndQuery(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetQuery(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetQueryParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateSampler(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteSampler(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsSampler(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindSampler(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionSamplerParameteri(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionSamplerParameterf(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetSamplerParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionFenceSync(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsSync(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteSync(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClientWaitSync(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionWaitSync(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetSyncParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBeginTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionEndTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTransformFeedbackVaryings(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetTransformFeedbackVarying(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionPauseTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionResumeTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindBufferBase(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindBufferRange(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetIndexedParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetUniformIndices(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetActiveUniforms(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetUniformBlockIndex(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockName(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformBlockBinding(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateVertexArray(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteVertexArray(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsVertexArray(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindVertexArray(JSC::ExecState*);

// Attributes

JSC::EncodedJSValue jsWebGL2RenderingContextConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSWebGL2RenderingContextConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);

class JSWebGL2RenderingContextPrototype : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;
    static JSWebGL2RenderingContextPrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSWebGL2RenderingContextPrototype* ptr = new (NotNull, JSC::allocateCell<JSWebGL2RenderingContextPrototype>(vm.heap)) JSWebGL2RenderingContextPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSWebGL2RenderingContextPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};

using JSWebGL2RenderingContextConstructor = JSDOMConstructorNotConstructable<JSWebGL2RenderingContext>;

/* Hash table for constructor */

static const HashTableValue JSWebGL2RenderingContextConstructorTableValues[] =
{
    { "READ_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0C02) } },
    { "UNPACK_ROW_LENGTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF2) } },
    { "UNPACK_SKIP_ROWS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF3) } },
    { "UNPACK_SKIP_PIXELS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF4) } },
    { "PACK_ROW_LENGTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D02) } },
    { "PACK_SKIP_ROWS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D03) } },
    { "PACK_SKIP_PIXELS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D04) } },
    { "COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1800) } },
    { "DEPTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1801) } },
    { "STENCIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1802) } },
    { "RED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1903) } },
    { "RGB8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8051) } },
    { "RGBA8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8058) } },
    { "RGB10_A2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8059) } },
    { "TEXTURE_BINDING_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806A) } },
    { "UNPACK_SKIP_IMAGES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806D) } },
    { "UNPACK_IMAGE_HEIGHT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806E) } },
    { "TEXTURE_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806F) } },
    { "TEXTURE_WRAP_R", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8072) } },
    { "MAX_3D_TEXTURE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8073) } },
    { "UNSIGNED_INT_2_10_10_10_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8368) } },
    { "MAX_ELEMENTS_VERTICES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80E8) } },
    { "MAX_ELEMENTS_INDICES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80E9) } },
    { "TEXTURE_MIN_LOD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813A) } },
    { "TEXTURE_MAX_LOD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813B) } },
    { "TEXTURE_BASE_LEVEL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813C) } },
    { "TEXTURE_MAX_LEVEL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813D) } },
    { "MIN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8007) } },
    { "MAX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8008) } },
    { "DEPTH_COMPONENT24", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x81A6) } },
    { "MAX_TEXTURE_LOD_BIAS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84FD) } },
    { "TEXTURE_COMPARE_MODE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x884C) } },
    { "TEXTURE_COMPARE_FUNC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x884D) } },
    { "CURRENT_QUERY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8865) } },
    { "QUERY_RESULT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8866) } },
    { "QUERY_RESULT_AVAILABLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8867) } },
    { "STREAM_READ", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E1) } },
    { "STREAM_COPY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E2) } },
    { "STATIC_READ", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E5) } },
    { "STATIC_COPY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E6) } },
    { "DYNAMIC_READ", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E9) } },
    { "DYNAMIC_COPY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EA) } },
    { "MAX_DRAW_BUFFERS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8824) } },
    { "DRAW_BUFFER0", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8825) } },
    { "DRAW_BUFFER1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8826) } },
    { "DRAW_BUFFER2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8827) } },
    { "DRAW_BUFFER3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8828) } },
    { "DRAW_BUFFER4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8829) } },
    { "DRAW_BUFFER5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882A) } },
    { "DRAW_BUFFER6", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882B) } },
    { "DRAW_BUFFER7", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882C) } },
    { "DRAW_BUFFER8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882D) } },
    { "DRAW_BUFFER9", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882E) } },
    { "DRAW_BUFFER10", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882F) } },
    { "DRAW_BUFFER11", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8830) } },
    { "DRAW_BUFFER12", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8831) } },
    { "DRAW_BUFFER13", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8832) } },
    { "DRAW_BUFFER14", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8833) } },
    { "DRAW_BUFFER15", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8834) } },
    { "MAX_FRAGMENT_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B49) } },
    { "MAX_VERTEX_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4A) } },
    { "SAMPLER_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B5F) } },
    { "SAMPLER_2D_SHADOW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B62) } },
    { "FRAGMENT_SHADER_DERIVATIVE_HINT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B8B) } },
    { "PIXEL_PACK_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EB) } },
    { "PIXEL_UNPACK_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EC) } },
    { "PIXEL_PACK_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88ED) } },
    { "PIXEL_UNPACK_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EF) } },
    { "FLOAT_MAT2x3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B65) } },
    { "FLOAT_MAT2x4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B66) } },
    { "FLOAT_MAT3x2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B67) } },
    { "FLOAT_MAT3x4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B68) } },
    { "FLOAT_MAT4x2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B69) } },
    { "FLOAT_MAT4x3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B6A) } },
    { "SRGB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C40) } },
    { "SRGB8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C41) } },
    { "SRGB8_ALPHA8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C43) } },
    { "COMPARE_REF_TO_TEXTURE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x884E) } },
    { "RGBA32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8814) } },
    { "RGB32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8815) } },
    { "RGBA16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x881A) } },
    { "RGB16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x881B) } },
    { "VERTEX_ATTRIB_ARRAY_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FD) } },
    { "MAX_ARRAY_TEXTURE_LAYERS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FF) } },
    { "MIN_PROGRAM_TEXEL_OFFSET", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8904) } },
    { "MAX_PROGRAM_TEXEL_OFFSET", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8905) } },
    { "MAX_VARYING_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4B) } },
    { "TEXTURE_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C1A) } },
    { "TEXTURE_BINDING_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C1D) } },
    { "R11F_G11F_B10F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3A) } },
    { "UNSIGNED_INT_10F_11F_11F_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3B) } },
    { "RGB9_E5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3D) } },
    { "UNSIGNED_INT_5_9_9_9_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3E) } },
    { "TRANSFORM_FEEDBACK_BUFFER_MODE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C7F) } },
    { "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C80) } },
    { "TRANSFORM_FEEDBACK_VARYINGS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C83) } },
    { "TRANSFORM_FEEDBACK_BUFFER_START", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C84) } },
    { "TRANSFORM_FEEDBACK_BUFFER_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C85) } },
    { "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C88) } },
    { "RASTERIZER_DISCARD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C89) } },
    { "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8A) } },
    { "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8B) } },
    { "INTERLEAVED_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8C) } },
    { "SEPARATE_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8D) } },
    { "TRANSFORM_FEEDBACK_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8E) } },
    { "TRANSFORM_FEEDBACK_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8F) } },
    { "RGBA32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D70) } },
    { "RGB32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D71) } },
    { "RGBA16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D76) } },
    { "RGB16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D77) } },
    { "RGBA8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D7C) } },
    { "RGB8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D7D) } },
    { "RGBA32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D82) } },
    { "RGB32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D83) } },
    { "RGBA16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D88) } },
    { "RGB16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D89) } },
    { "RGBA8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D8E) } },
    { "RGB8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D8F) } },
    { "RED_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D94) } },
    { "RGB_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D98) } },
    { "RGBA_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D99) } },
    { "SAMPLER_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC1) } },
    { "SAMPLER_2D_ARRAY_SHADOW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC4) } },
    { "SAMPLER_CUBE_SHADOW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC5) } },
    { "UNSIGNED_INT_VEC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC6) } },
    { "UNSIGNED_INT_VEC3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC7) } },
    { "UNSIGNED_INT_VEC4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC8) } },
    { "INT_SAMPLER_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCA) } },
    { "INT_SAMPLER_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCB) } },
    { "INT_SAMPLER_CUBE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCC) } },
    { "INT_SAMPLER_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCF) } },
    { "UNSIGNED_INT_SAMPLER_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD2) } },
    { "UNSIGNED_INT_SAMPLER_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD3) } },
    { "UNSIGNED_INT_SAMPLER_CUBE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD4) } },
    { "UNSIGNED_INT_SAMPLER_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD7) } },
    { "DEPTH_COMPONENT32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAC) } },
    { "DEPTH32F_STENCIL8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAD) } },
    { "FLOAT_32_UNSIGNED_INT_24_8_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DAD) } },
    { "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8210) } },
    { "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8211) } },
    { "FRAMEBUFFER_ATTACHMENT_RED_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8212) } },
    { "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8213) } },
    { "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8214) } },
    { "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8215) } },
    { "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8216) } },
    { "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8217) } },
    { "FRAMEBUFFER_DEFAULT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8218) } },
    { "DEPTH_STENCIL_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x821A) } },
    { "DEPTH_STENCIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84F9) } },
    { "UNSIGNED_INT_24_8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84FA) } },
    { "DEPTH24_STENCIL8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88F0) } },
    { "UNSIGNED_NORMALIZED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C17) } },
    { "DRAW_FRAMEBUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA6) } },
    { "READ_FRAMEBUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA8) } },
    { "DRAW_FRAMEBUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA9) } },
    { "READ_FRAMEBUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAA) } },
    { "RENDERBUFFER_SAMPLES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAB) } },
    { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD4) } },
    { "MAX_COLOR_ATTACHMENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CDF) } },
    { "COLOR_ATTACHMENT1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE1) } },
    { "COLOR_ATTACHMENT2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE2) } },
    { "COLOR_ATTACHMENT3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE3) } },
    { "COLOR_ATTACHMENT4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE4) } },
    { "COLOR_ATTACHMENT5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE5) } },
    { "COLOR_ATTACHMENT6", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE6) } },
    { "COLOR_ATTACHMENT7", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE7) } },
    { "COLOR_ATTACHMENT8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE8) } },
    { "COLOR_ATTACHMENT9", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE9) } },
    { "COLOR_ATTACHMENT10", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEA) } },
    { "COLOR_ATTACHMENT11", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEB) } },
    { "COLOR_ATTACHMENT12", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEC) } },
    { "COLOR_ATTACHMENT13", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CED) } },
    { "COLOR_ATTACHMENT14", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEE) } },
    { "COLOR_ATTACHMENT15", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEF) } },
    { "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D56) } },
    { "MAX_SAMPLES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D57) } },
    { "HALF_FLOAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x140B) } },
    { "RG", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8227) } },
    { "RG_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8228) } },
    { "R8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8229) } },
    { "RG8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822B) } },
    { "R16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822D) } },
    { "R32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822E) } },
    { "RG16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822F) } },
    { "RG32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8230) } },
    { "R8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8231) } },
    { "R8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8232) } },
    { "R16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8233) } },
    { "R16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8234) } },
    { "R32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8235) } },
    { "R32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8236) } },
    { "RG8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8237) } },
    { "RG8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8238) } },
    { "RG16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8239) } },
    { "RG16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x823A) } },
    { "RG32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x823B) } },
    { "RG32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x823C) } },
    { "VERTEX_ARRAY_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x85B5) } },
    { "R8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F94) } },
    { "RG8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F95) } },
    { "RGB8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F96) } },
    { "RGBA8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F97) } },
    { "SIGNED_NORMALIZED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F9C) } },
    { "PRIMITIVE_RESTART_FIXED_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D69) } },
    { "COPY_READ_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F36) } },
    { "COPY_WRITE_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F37) } },
    { "COPY_READ_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F36) } },
    { "COPY_WRITE_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F37) } },
    { "UNIFORM_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A11) } },
    { "UNIFORM_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A28) } },
    { "UNIFORM_BUFFER_START", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A29) } },
    { "UNIFORM_BUFFER_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2A) } },
    { "MAX_VERTEX_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2B) } },
    { "MAX_FRAGMENT_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2D) } },
    { "MAX_COMBINED_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2E) } },
    { "MAX_UNIFORM_BUFFER_BINDINGS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2F) } },
    { "MAX_UNIFORM_BLOCK_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A30) } },
    { "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A31) } },
    { "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A33) } },
    { "UNIFORM_BUFFER_OFFSET_ALIGNMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A34) } },
    { "ACTIVE_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A36) } },
    { "UNIFORM_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A37) } },
    { "UNIFORM_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A38) } },
    { "UNIFORM_BLOCK_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3A) } },
    { "UNIFORM_OFFSET", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3B) } },
    { "UNIFORM_ARRAY_STRIDE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3C) } },
    { "UNIFORM_MATRIX_STRIDE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3D) } },
    { "UNIFORM_IS_ROW_MAJOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3E) } },
    { "UNIFORM_BLOCK_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3F) } },
    { "UNIFORM_BLOCK_DATA_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A40) } },
    { "UNIFORM_BLOCK_ACTIVE_UNIFORMS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A42) } },
    { "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A43) } },
    { "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A44) } },
    { "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A46) } },
    { "INVALID_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0xFFFFFFFF) } },
    { "MAX_VERTEX_OUTPUT_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9122) } },
    { "MAX_FRAGMENT_INPUT_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9125) } },
    { "MAX_SERVER_WAIT_TIMEOUT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9111) } },
    { "OBJECT_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9112) } },
    { "SYNC_CONDITION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9113) } },
    { "SYNC_STATUS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9114) } },
    { "SYNC_FLAGS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9115) } },
    { "SYNC_FENCE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9116) } },
    { "SYNC_GPU_COMMANDS_COMPLETE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9117) } },
    { "UNSIGNALED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9118) } },
    { "SIGNALED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9119) } },
    { "ALREADY_SIGNALED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911A) } },
    { "TIMEOUT_EXPIRED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911B) } },
    { "CONDITION_SATISFIED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911C) } },
    { "WAIT_FAILED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911D) } },
    { "SYNC_FLUSH_COMMANDS_BIT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x00000001) } },
    { "VERTEX_ATTRIB_ARRAY_DIVISOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FE) } },
    { "ANY_SAMPLES_PASSED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C2F) } },
    { "ANY_SAMPLES_PASSED_CONSERVATIVE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D6A) } },
    { "SAMPLER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8919) } },
    { "RGB10_A2UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x906F) } },
    { "TEXTURE_SWIZZLE_R", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E42) } },
    { "TEXTURE_SWIZZLE_G", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E43) } },
    { "TEXTURE_SWIZZLE_B", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E44) } },
    { "TEXTURE_SWIZZLE_A", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E45) } },
    { "GREEN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1904) } },
    { "BLUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1905) } },
    { "INT_2_10_10_10_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D9F) } },
    { "TRANSFORM_FEEDBACK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E22) } },
    { "TRANSFORM_FEEDBACK_PAUSED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E23) } },
    { "TRANSFORM_FEEDBACK_ACTIVE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E24) } },
    { "TRANSFORM_FEEDBACK_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E25) } },
    { "COMPRESSED_R11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9270) } },
    { "COMPRESSED_SIGNED_R11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9271) } },
    { "COMPRESSED_RG11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9272) } },
    { "COMPRESSED_SIGNED_RG11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9273) } },
    { "COMPRESSED_RGB8_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9274) } },
    { "COMPRESSED_SRGB8_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9275) } },
    { "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9276) } },
    { "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9277) } },
    { "COMPRESSED_RGBA8_ETC2_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9278) } },
    { "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9279) } },
    { "TEXTURE_IMMUTABLE_FORMAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x912F) } },
    { "MAX_ELEMENT_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D6B) } },
    { "NUM_SAMPLE_COUNTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9380) } },
    { "TEXTURE_IMMUTABLE_LEVELS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x82DF) } },
    { "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FE) } },
    { "TIMEOUT_IGNORED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0xFFFFFFFFFFFFFFFF) } },
};

template<> JSValue JSWebGL2RenderingContextConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    UNUSED_PARAM(vm);
    return globalObject.functionPrototype();
}

template<> void JSWebGL2RenderingContextConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    putDirect(vm, vm.propertyNames->prototype, JSWebGL2RenderingContext::prototype(vm, &globalObject), DontDelete | ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("WebGL2RenderingContext"))), ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
    reifyStaticProperties(vm, JSWebGL2RenderingContextConstructorTableValues, *this);
}

template<> const ClassInfo JSWebGL2RenderingContextConstructor::s_info = { "WebGL2RenderingContext", &Base::s_info, 0, CREATE_METHOD_TABLE(JSWebGL2RenderingContextConstructor) };

/* Hash table for prototype */

static const HashTableValue JSWebGL2RenderingContextPrototypeTableValues[] =
{
    { "constructor", DontEnum, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsWebGL2RenderingContextConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSWebGL2RenderingContextConstructor) } },
    { "bufferData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBufferData), (intptr_t) (3) } },
    { "bufferSubData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBufferSubData), (intptr_t) (3) } },
    { "copyBufferSubData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCopyBufferSubData), (intptr_t) (5) } },
    { "getBufferSubData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetBufferSubData), (intptr_t) (3) } },
    { "blitFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBlitFramebuffer), (intptr_t) (10) } },
    { "framebufferTextureLayer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionFramebufferTextureLayer), (intptr_t) (5) } },
    { "getInternalformatParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetInternalformatParameter), (intptr_t) (3) } },
    { "invalidateFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionInvalidateFramebuffer), (intptr_t) (2) } },
    { "invalidateSubFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionInvalidateSubFramebuffer), (intptr_t) (6) } },
    { "readBuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionReadBuffer), (intptr_t) (1) } },
    { "renderbufferStorageMultisample", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionRenderbufferStorageMultisample), (intptr_t) (5) } },
    { "texStorage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionTexStorage2D), (intptr_t) (5) } },
    { "texStorage3D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionTexStorage3D), (intptr_t) (6) } },
    { "texImage3D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionTexImage3D), (intptr_t) (10) } },
    { "texSubImage3D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D), (intptr_t) (8) } },
    { "copyTexSubImage3D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCopyTexSubImage3D), (intptr_t) (9) } },
    { "compressedTexImage3D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCompressedTexImage3D), (intptr_t) (9) } },
    { "compressedTexSubImage3D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCompressedTexSubImage3D), (intptr_t) (11) } },
    { "getFragDataLocation", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetFragDataLocation), (intptr_t) (2) } },
    { "uniform1ui", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform1ui), (intptr_t) (2) } },
    { "uniform2ui", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform2ui), (intptr_t) (3) } },
    { "uniform3ui", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform3ui), (intptr_t) (4) } },
    { "uniform4ui", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform4ui), (intptr_t) (5) } },
    { "uniform1uiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform1uiv), (intptr_t) (2) } },
    { "uniform2uiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform2uiv), (intptr_t) (2) } },
    { "uniform3uiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform3uiv), (intptr_t) (2) } },
    { "uniform4uiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform4uiv), (intptr_t) (2) } },
    { "uniformMatrix2x3fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x3fv), (intptr_t) (3) } },
    { "uniformMatrix3x2fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x2fv), (intptr_t) (3) } },
    { "uniformMatrix2x4fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x4fv), (intptr_t) (3) } },
    { "uniformMatrix4x2fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x2fv), (intptr_t) (3) } },
    { "uniformMatrix3x4fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x4fv), (intptr_t) (3) } },
    { "uniformMatrix4x3fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x3fv), (intptr_t) (3) } },
    { "vertexAttribI4i", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4i), (intptr_t) (5) } },
    { "vertexAttribI4iv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4iv), (intptr_t) (2) } },
    { "vertexAttribI4ui", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4ui), (intptr_t) (5) } },
    { "vertexAttribI4uiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4uiv), (intptr_t) (2) } },
    { "vertexAttribIPointer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionVertexAttribIPointer), (intptr_t) (5) } },
    { "vertexAttribDivisor", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionVertexAttribDivisor), (intptr_t) (2) } },
    { "drawArraysInstanced", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDrawArraysInstanced), (intptr_t) (4) } },
    { "drawElementsInstanced", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDrawElementsInstanced), (intptr_t) (5) } },
    { "drawRangeElements", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDrawRangeElements), (intptr_t) (6) } },
    { "drawBuffers", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDrawBuffers), (intptr_t) (1) } },
    { "clearBufferiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionClearBufferiv), (intptr_t) (3) } },
    { "clearBufferuiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionClearBufferuiv), (intptr_t) (3) } },
    { "clearBufferfv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionClearBufferfv), (intptr_t) (3) } },
    { "clearBufferfi", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionClearBufferfi), (intptr_t) (4) } },
    { "createQuery", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCreateQuery), (intptr_t) (0) } },
    { "deleteQuery", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDeleteQuery), (intptr_t) (1) } },
    { "isQuery", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionIsQuery), (intptr_t) (1) } },
    { "beginQuery", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBeginQuery), (intptr_t) (2) } },
    { "endQuery", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionEndQuery), (intptr_t) (1) } },
    { "getQuery", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetQuery), (intptr_t) (2) } },
    { "getQueryParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetQueryParameter), (intptr_t) (2) } },
    { "createSampler", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCreateSampler), (intptr_t) (0) } },
    { "deleteSampler", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDeleteSampler), (intptr_t) (1) } },
    { "isSampler", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionIsSampler), (intptr_t) (1) } },
    { "bindSampler", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBindSampler), (intptr_t) (2) } },
    { "samplerParameteri", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionSamplerParameteri), (intptr_t) (3) } },
    { "samplerParameterf", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionSamplerParameterf), (intptr_t) (3) } },
    { "getSamplerParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetSamplerParameter), (intptr_t) (2) } },
    { "fenceSync", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionFenceSync), (intptr_t) (2) } },
    { "isSync", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionIsSync), (intptr_t) (1) } },
    { "deleteSync", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDeleteSync), (intptr_t) (1) } },
    { "clientWaitSync", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionClientWaitSync), (intptr_t) (3) } },
    { "waitSync", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionWaitSync), (intptr_t) (3) } },
    { "getSyncParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetSyncParameter), (intptr_t) (2) } },
    { "createTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCreateTransformFeedback), (intptr_t) (0) } },
    { "deleteTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDeleteTransformFeedback), (intptr_t) (1) } },
    { "isTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionIsTransformFeedback), (intptr_t) (1) } },
    { "bindTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBindTransformFeedback), (intptr_t) (2) } },
    { "beginTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBeginTransformFeedback), (intptr_t) (1) } },
    { "endTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionEndTransformFeedback), (intptr_t) (0) } },
    { "transformFeedbackVaryings", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionTransformFeedbackVaryings), (intptr_t) (3) } },
    { "getTransformFeedbackVarying", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetTransformFeedbackVarying), (intptr_t) (2) } },
    { "pauseTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionPauseTransformFeedback), (intptr_t) (0) } },
    { "resumeTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionResumeTransformFeedback), (intptr_t) (0) } },
    { "bindBufferBase", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBindBufferBase), (intptr_t) (3) } },
    { "bindBufferRange", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBindBufferRange), (intptr_t) (5) } },
    { "getIndexedParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetIndexedParameter), (intptr_t) (2) } },
    { "getUniformIndices", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetUniformIndices), (intptr_t) (2) } },
    { "getActiveUniforms", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetActiveUniforms), (intptr_t) (3) } },
    { "getUniformBlockIndex", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetUniformBlockIndex), (intptr_t) (2) } },
    { "getActiveUniformBlockParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockParameter), (intptr_t) (3) } },
    { "getActiveUniformBlockName", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockName), (intptr_t) (2) } },
    { "uniformBlockBinding", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformBlockBinding), (intptr_t) (3) } },
    { "createVertexArray", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCreateVertexArray), (intptr_t) (0) } },
    { "deleteVertexArray", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDeleteVertexArray), (intptr_t) (1) } },
    { "isVertexArray", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionIsVertexArray), (intptr_t) (1) } },
    { "bindVertexArray", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBindVertexArray), (intptr_t) (1) } },
    { "READ_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0C02) } },
    { "UNPACK_ROW_LENGTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF2) } },
    { "UNPACK_SKIP_ROWS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF3) } },
    { "UNPACK_SKIP_PIXELS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF4) } },
    { "PACK_ROW_LENGTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D02) } },
    { "PACK_SKIP_ROWS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D03) } },
    { "PACK_SKIP_PIXELS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D04) } },
    { "COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1800) } },
    { "DEPTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1801) } },
    { "STENCIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1802) } },
    { "RED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1903) } },
    { "RGB8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8051) } },
    { "RGBA8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8058) } },
    { "RGB10_A2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8059) } },
    { "TEXTURE_BINDING_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806A) } },
    { "UNPACK_SKIP_IMAGES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806D) } },
    { "UNPACK_IMAGE_HEIGHT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806E) } },
    { "TEXTURE_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806F) } },
    { "TEXTURE_WRAP_R", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8072) } },
    { "MAX_3D_TEXTURE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8073) } },
    { "UNSIGNED_INT_2_10_10_10_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8368) } },
    { "MAX_ELEMENTS_VERTICES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80E8) } },
    { "MAX_ELEMENTS_INDICES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80E9) } },
    { "TEXTURE_MIN_LOD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813A) } },
    { "TEXTURE_MAX_LOD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813B) } },
    { "TEXTURE_BASE_LEVEL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813C) } },
    { "TEXTURE_MAX_LEVEL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813D) } },
    { "MIN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8007) } },
    { "MAX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8008) } },
    { "DEPTH_COMPONENT24", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x81A6) } },
    { "MAX_TEXTURE_LOD_BIAS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84FD) } },
    { "TEXTURE_COMPARE_MODE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x884C) } },
    { "TEXTURE_COMPARE_FUNC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x884D) } },
    { "CURRENT_QUERY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8865) } },
    { "QUERY_RESULT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8866) } },
    { "QUERY_RESULT_AVAILABLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8867) } },
    { "STREAM_READ", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E1) } },
    { "STREAM_COPY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E2) } },
    { "STATIC_READ", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E5) } },
    { "STATIC_COPY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E6) } },
    { "DYNAMIC_READ", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E9) } },
    { "DYNAMIC_COPY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EA) } },
    { "MAX_DRAW_BUFFERS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8824) } },
    { "DRAW_BUFFER0", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8825) } },
    { "DRAW_BUFFER1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8826) } },
    { "DRAW_BUFFER2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8827) } },
    { "DRAW_BUFFER3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8828) } },
    { "DRAW_BUFFER4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8829) } },
    { "DRAW_BUFFER5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882A) } },
    { "DRAW_BUFFER6", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882B) } },
    { "DRAW_BUFFER7", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882C) } },
    { "DRAW_BUFFER8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882D) } },
    { "DRAW_BUFFER9", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882E) } },
    { "DRAW_BUFFER10", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882F) } },
    { "DRAW_BUFFER11", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8830) } },
    { "DRAW_BUFFER12", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8831) } },
    { "DRAW_BUFFER13", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8832) } },
    { "DRAW_BUFFER14", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8833) } },
    { "DRAW_BUFFER15", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8834) } },
    { "MAX_FRAGMENT_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B49) } },
    { "MAX_VERTEX_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4A) } },
    { "SAMPLER_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B5F) } },
    { "SAMPLER_2D_SHADOW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B62) } },
    { "FRAGMENT_SHADER_DERIVATIVE_HINT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B8B) } },
    { "PIXEL_PACK_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EB) } },
    { "PIXEL_UNPACK_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EC) } },
    { "PIXEL_PACK_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88ED) } },
    { "PIXEL_UNPACK_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EF) } },
    { "FLOAT_MAT2x3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B65) } },
    { "FLOAT_MAT2x4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B66) } },
    { "FLOAT_MAT3x2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B67) } },
    { "FLOAT_MAT3x4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B68) } },
    { "FLOAT_MAT4x2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B69) } },
    { "FLOAT_MAT4x3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B6A) } },
    { "SRGB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C40) } },
    { "SRGB8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C41) } },
    { "SRGB8_ALPHA8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C43) } },
    { "COMPARE_REF_TO_TEXTURE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x884E) } },
    { "RGBA32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8814) } },
    { "RGB32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8815) } },
    { "RGBA16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x881A) } },
    { "RGB16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x881B) } },
    { "VERTEX_ATTRIB_ARRAY_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FD) } },
    { "MAX_ARRAY_TEXTURE_LAYERS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FF) } },
    { "MIN_PROGRAM_TEXEL_OFFSET", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8904) } },
    { "MAX_PROGRAM_TEXEL_OFFSET", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8905) } },
    { "MAX_VARYING_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4B) } },
    { "TEXTURE_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C1A) } },
    { "TEXTURE_BINDING_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C1D) } },
    { "R11F_G11F_B10F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3A) } },
    { "UNSIGNED_INT_10F_11F_11F_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3B) } },
    { "RGB9_E5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3D) } },
    { "UNSIGNED_INT_5_9_9_9_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3E) } },
    { "TRANSFORM_FEEDBACK_BUFFER_MODE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C7F) } },
    { "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C80) } },
    { "TRANSFORM_FEEDBACK_VARYINGS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C83) } },
    { "TRANSFORM_FEEDBACK_BUFFER_START", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C84) } },
    { "TRANSFORM_FEEDBACK_BUFFER_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C85) } },
    { "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C88) } },
    { "RASTERIZER_DISCARD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C89) } },
    { "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8A) } },
    { "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8B) } },
    { "INTERLEAVED_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8C) } },
    { "SEPARATE_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8D) } },
    { "TRANSFORM_FEEDBACK_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8E) } },
    { "TRANSFORM_FEEDBACK_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8F) } },
    { "RGBA32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D70) } },
    { "RGB32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D71) } },
    { "RGBA16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D76) } },
    { "RGB16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D77) } },
    { "RGBA8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D7C) } },
    { "RGB8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D7D) } },
    { "RGBA32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D82) } },
    { "RGB32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D83) } },
    { "RGBA16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D88) } },
    { "RGB16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D89) } },
    { "RGBA8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D8E) } },
    { "RGB8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D8F) } },
    { "RED_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D94) } },
    { "RGB_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D98) } },
    { "RGBA_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D99) } },
    { "SAMPLER_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC1) } },
    { "SAMPLER_2D_ARRAY_SHADOW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC4) } },
    { "SAMPLER_CUBE_SHADOW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC5) } },
    { "UNSIGNED_INT_VEC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC6) } },
    { "UNSIGNED_INT_VEC3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC7) } },
    { "UNSIGNED_INT_VEC4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC8) } },
    { "INT_SAMPLER_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCA) } },
    { "INT_SAMPLER_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCB) } },
    { "INT_SAMPLER_CUBE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCC) } },
    { "INT_SAMPLER_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCF) } },
    { "UNSIGNED_INT_SAMPLER_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD2) } },
    { "UNSIGNED_INT_SAMPLER_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD3) } },
    { "UNSIGNED_INT_SAMPLER_CUBE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD4) } },
    { "UNSIGNED_INT_SAMPLER_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD7) } },
    { "DEPTH_COMPONENT32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAC) } },
    { "DEPTH32F_STENCIL8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAD) } },
    { "FLOAT_32_UNSIGNED_INT_24_8_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DAD) } },
    { "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8210) } },
    { "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8211) } },
    { "FRAMEBUFFER_ATTACHMENT_RED_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8212) } },
    { "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8213) } },
    { "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8214) } },
    { "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8215) } },
    { "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8216) } },
    { "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8217) } },
    { "FRAMEBUFFER_DEFAULT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8218) } },
    { "DEPTH_STENCIL_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x821A) } },
    { "DEPTH_STENCIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84F9) } },
    { "UNSIGNED_INT_24_8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84FA) } },
    { "DEPTH24_STENCIL8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88F0) } },
    { "UNSIGNED_NORMALIZED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C17) } },
    { "DRAW_FRAMEBUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA6) } },
    { "READ_FRAMEBUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA8) } },
    { "DRAW_FRAMEBUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA9) } },
    { "READ_FRAMEBUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAA) } },
    { "RENDERBUFFER_SAMPLES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAB) } },
    { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD4) } },
    { "MAX_COLOR_ATTACHMENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CDF) } },
    { "COLOR_ATTACHMENT1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE1) } },
    { "COLOR_ATTACHMENT2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE2) } },
    { "COLOR_ATTACHMENT3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE3) } },
    { "COLOR_ATTACHMENT4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE4) } },
    { "COLOR_ATTACHMENT5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE5) } },
    { "COLOR_ATTACHMENT6", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE6) } },
    { "COLOR_ATTACHMENT7", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE7) } },
    { "COLOR_ATTACHMENT8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE8) } },
    { "COLOR_ATTACHMENT9", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE9) } },
    { "COLOR_ATTACHMENT10", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEA) } },
    { "COLOR_ATTACHMENT11", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEB) } },
    { "COLOR_ATTACHMENT12", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEC) } },
    { "COLOR_ATTACHMENT13", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CED) } },
    { "COLOR_ATTACHMENT14", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEE) } },
    { "COLOR_ATTACHMENT15", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEF) } },
    { "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D56) } },
    { "MAX_SAMPLES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D57) } },
    { "HALF_FLOAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x140B) } },
    { "RG", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8227) } },
    { "RG_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8228) } },
    { "R8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8229) } },
    { "RG8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822B) } },
    { "R16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822D) } },
    { "R32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822E) } },
    { "RG16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822F) } },
    { "RG32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8230) } },
    { "R8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8231) } },
    { "R8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8232) } },
    { "R16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8233) } },
    { "R16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8234) } },
    { "R32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8235) } },
    { "R32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8236) } },
    { "RG8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8237) } },
    { "RG8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8238) } },
    { "RG16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8239) } },
    { "RG16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x823A) } },
    { "RG32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x823B) } },
    { "RG32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x823C) } },
    { "VERTEX_ARRAY_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x85B5) } },
    { "R8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F94) } },
    { "RG8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F95) } },
    { "RGB8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F96) } },
    { "RGBA8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F97) } },
    { "SIGNED_NORMALIZED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F9C) } },
    { "PRIMITIVE_RESTART_FIXED_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D69) } },
    { "COPY_READ_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F36) } },
    { "COPY_WRITE_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F37) } },
    { "COPY_READ_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F36) } },
    { "COPY_WRITE_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F37) } },
    { "UNIFORM_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A11) } },
    { "UNIFORM_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A28) } },
    { "UNIFORM_BUFFER_START", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A29) } },
    { "UNIFORM_BUFFER_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2A) } },
    { "MAX_VERTEX_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2B) } },
    { "MAX_FRAGMENT_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2D) } },
    { "MAX_COMBINED_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2E) } },
    { "MAX_UNIFORM_BUFFER_BINDINGS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2F) } },
    { "MAX_UNIFORM_BLOCK_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A30) } },
    { "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A31) } },
    { "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A33) } },
    { "UNIFORM_BUFFER_OFFSET_ALIGNMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A34) } },
    { "ACTIVE_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A36) } },
    { "UNIFORM_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A37) } },
    { "UNIFORM_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A38) } },
    { "UNIFORM_BLOCK_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3A) } },
    { "UNIFORM_OFFSET", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3B) } },
    { "UNIFORM_ARRAY_STRIDE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3C) } },
    { "UNIFORM_MATRIX_STRIDE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3D) } },
    { "UNIFORM_IS_ROW_MAJOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3E) } },
    { "UNIFORM_BLOCK_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3F) } },
    { "UNIFORM_BLOCK_DATA_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A40) } },
    { "UNIFORM_BLOCK_ACTIVE_UNIFORMS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A42) } },
    { "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A43) } },
    { "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A44) } },
    { "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A46) } },
    { "INVALID_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0xFFFFFFFF) } },
    { "MAX_VERTEX_OUTPUT_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9122) } },
    { "MAX_FRAGMENT_INPUT_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9125) } },
    { "MAX_SERVER_WAIT_TIMEOUT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9111) } },
    { "OBJECT_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9112) } },
    { "SYNC_CONDITION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9113) } },
    { "SYNC_STATUS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9114) } },
    { "SYNC_FLAGS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9115) } },
    { "SYNC_FENCE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9116) } },
    { "SYNC_GPU_COMMANDS_COMPLETE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9117) } },
    { "UNSIGNALED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9118) } },
    { "SIGNALED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9119) } },
    { "ALREADY_SIGNALED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911A) } },
    { "TIMEOUT_EXPIRED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911B) } },
    { "CONDITION_SATISFIED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911C) } },
    { "WAIT_FAILED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911D) } },
    { "SYNC_FLUSH_COMMANDS_BIT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x00000001) } },
    { "VERTEX_ATTRIB_ARRAY_DIVISOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FE) } },
    { "ANY_SAMPLES_PASSED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C2F) } },
    { "ANY_SAMPLES_PASSED_CONSERVATIVE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D6A) } },
    { "SAMPLER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8919) } },
    { "RGB10_A2UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x906F) } },
    { "TEXTURE_SWIZZLE_R", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E42) } },
    { "TEXTURE_SWIZZLE_G", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E43) } },
    { "TEXTURE_SWIZZLE_B", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E44) } },
    { "TEXTURE_SWIZZLE_A", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E45) } },
    { "GREEN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1904) } },
    { "BLUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1905) } },
    { "INT_2_10_10_10_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D9F) } },
    { "TRANSFORM_FEEDBACK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E22) } },
    { "TRANSFORM_FEEDBACK_PAUSED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E23) } },
    { "TRANSFORM_FEEDBACK_ACTIVE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E24) } },
    { "TRANSFORM_FEEDBACK_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E25) } },
    { "COMPRESSED_R11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9270) } },
    { "COMPRESSED_SIGNED_R11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9271) } },
    { "COMPRESSED_RG11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9272) } },
    { "COMPRESSED_SIGNED_RG11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9273) } },
    { "COMPRESSED_RGB8_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9274) } },
    { "COMPRESSED_SRGB8_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9275) } },
    { "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9276) } },
    { "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9277) } },
    { "COMPRESSED_RGBA8_ETC2_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9278) } },
    { "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9279) } },
    { "TEXTURE_IMMUTABLE_FORMAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x912F) } },
    { "MAX_ELEMENT_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D6B) } },
    { "NUM_SAMPLE_COUNTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9380) } },
    { "TEXTURE_IMMUTABLE_LEVELS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x82DF) } },
    { "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FE) } },
    { "TIMEOUT_IGNORED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0xFFFFFFFFFFFFFFFF) } },
};

const ClassInfo JSWebGL2RenderingContextPrototype::s_info = { "WebGL2RenderingContextPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSWebGL2RenderingContextPrototype) };

void JSWebGL2RenderingContextPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSWebGL2RenderingContextPrototypeTableValues, *this);
}

const ClassInfo JSWebGL2RenderingContext::s_info = { "WebGL2RenderingContext", &Base::s_info, 0, CREATE_METHOD_TABLE(JSWebGL2RenderingContext) };

JSWebGL2RenderingContext::JSWebGL2RenderingContext(Structure* structure, JSDOMGlobalObject& globalObject, Ref<WebGL2RenderingContext>&& impl)
    : JSWebGLRenderingContextBase(structure, globalObject, WTFMove(impl))
{
}

void JSWebGL2RenderingContext::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));

}

JSObject* JSWebGL2RenderingContext::createPrototype(VM& vm, JSGlobalObject* globalObject)
{
    return JSWebGL2RenderingContextPrototype::create(vm, globalObject, JSWebGL2RenderingContextPrototype::createStructure(vm, globalObject, JSWebGLRenderingContextBase::prototype(vm, globalObject)));
}

JSObject* JSWebGL2RenderingContext::prototype(VM& vm, JSGlobalObject* globalObject)
{
    return getDOMPrototype<JSWebGL2RenderingContext>(vm, globalObject);
}

template<> inline JSWebGL2RenderingContext* BindingCaller<JSWebGL2RenderingContext>::castForOperation(ExecState& state)
{
    return jsDynamicDowncast<JSWebGL2RenderingContext*>(state.thisValue());
}

EncodedJSValue jsWebGL2RenderingContextConstructor(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSWebGL2RenderingContextPrototype* domObject = jsDynamicDowncast<JSWebGL2RenderingContextPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject))
        return throwVMTypeError(state, throwScope);
    return JSValue::encode(JSWebGL2RenderingContext::getConstructor(state->vm(), domObject->globalObject()));
}

bool setJSWebGL2RenderingContextConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSValue value = JSValue::decode(encodedValue);
    JSWebGL2RenderingContextPrototype* domObject = jsDynamicDowncast<JSWebGL2RenderingContextPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject)) {
        throwVMTypeError(state, throwScope);
        return false;
    }
    // Shadowing a built-in constructor
    return domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
}

JSValue JSWebGL2RenderingContext::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSWebGL2RenderingContextConstructor>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferData1Caller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferData1(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBufferData1Caller>(state, "bufferData");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferData1Caller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto size = convert<IDLLongLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto usage = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bufferData(WTFMove(target), WTFMove(size), WTFMove(usage));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferData2Caller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferData2(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBufferData2Caller>(state, "bufferData");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferData2Caller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto srcData = convert<IDLNullable<IDLUnion<IDLInterface<ArrayBuffer>, IDLInterface<ArrayBufferView>>>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto usage = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bufferData(WTFMove(target), WTFMove(srcData), WTFMove(usage));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferSubData1Caller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferSubData1(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBufferSubData1Caller>(state, "bufferSubData");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferSubData1Caller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto dstByteOffset = convert<IDLLongLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto srcData = convert<IDLNullable<IDLUnion<IDLInterface<ArrayBuffer>, IDLInterface<ArrayBufferView>>>>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bufferSubData(WTFMove(target), WTFMove(dstByteOffset), WTFMove(srcData));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferData3Caller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferData3(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBufferData3Caller>(state, "bufferData");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferData3Caller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto data = convert<IDLInterface<ArrayBufferView>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "data", "WebGL2RenderingContext", "bufferData", "ArrayBufferView"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto usage = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto srcOffset = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto length = convert<IDLUnsignedLong>(*state, state->argument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bufferData(WTFMove(target), data.releaseNonNull(), WTFMove(usage), WTFMove(srcOffset), WTFMove(length));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBufferData(ExecState* state)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    size_t argsCount = std::min<size_t>(5, state->argumentCount());
    if (argsCount == 3) {
        JSValue distinguishingArg = state->uncheckedArgument(1);
        if (distinguishingArg.isUndefinedOrNull())
            return jsWebGL2RenderingContextPrototypeFunctionBufferData2(state);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSArrayBuffer::info()))
            return jsWebGL2RenderingContextPrototypeFunctionBufferData2(state);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSArrayBufferView::info()))
            return jsWebGL2RenderingContextPrototypeFunctionBufferData2(state);
        if (distinguishingArg.isNumber())
            return jsWebGL2RenderingContextPrototypeFunctionBufferData1(state);
        return jsWebGL2RenderingContextPrototypeFunctionBufferData1(state);
    }
    if (argsCount == 4) {
        return jsWebGL2RenderingContextPrototypeFunctionBufferData3(state);
    }
    if (argsCount == 5) {
        return jsWebGL2RenderingContextPrototypeFunctionBufferData3(state);
    }
    return argsCount < 3 ? throwVMError(state, throwScope, createNotEnoughArgumentsError(state)) : throwVMTypeError(state, throwScope);
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferSubData2Caller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferSubData2(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBufferSubData2Caller>(state, "bufferSubData");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBufferSubData2Caller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto dstByteOffset = convert<IDLLongLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto srcData = convert<IDLInterface<ArrayBufferView>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "srcData", "WebGL2RenderingContext", "bufferSubData", "ArrayBufferView"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto srcOffset = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto length = convert<IDLUnsignedLong>(*state, state->argument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bufferSubData(WTFMove(target), WTFMove(dstByteOffset), srcData.releaseNonNull(), WTFMove(srcOffset), WTFMove(length));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBufferSubData(ExecState* state)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    size_t argsCount = std::min<size_t>(5, state->argumentCount());
    if (argsCount == 3) {
        return jsWebGL2RenderingContextPrototypeFunctionBufferSubData1(state);
    }
    if (argsCount == 4) {
        return jsWebGL2RenderingContextPrototypeFunctionBufferSubData2(state);
    }
    if (argsCount == 5) {
        return jsWebGL2RenderingContextPrototypeFunctionBufferSubData2(state);
    }
    return argsCount < 3 ? throwVMError(state, throwScope, createNotEnoughArgumentsError(state)) : throwVMTypeError(state, throwScope);
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCopyBufferSubDataCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCopyBufferSubData(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionCopyBufferSubDataCaller>(state, "copyBufferSubData");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCopyBufferSubDataCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto readTarget = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto writeTarget = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto readOffset = convert<IDLLongLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto writeOffset = convert<IDLLongLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto size = convert<IDLLongLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.copyBufferSubData(WTFMove(readTarget), WTFMove(writeTarget), WTFMove(readOffset), WTFMove(writeOffset), WTFMove(size));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetBufferSubDataCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetBufferSubData(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetBufferSubDataCaller>(state, "getBufferSubData");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetBufferSubDataCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto srcByteOffset = convert<IDLLongLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto dstData = convert<IDLInterface<ArrayBufferView>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "dstData", "WebGL2RenderingContext", "getBufferSubData", "ArrayBufferView"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto dstOffset = convert<IDLUnsignedLong>(*state, state->argument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto length = convert<IDLUnsignedLong>(*state, state->argument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.getBufferSubData(WTFMove(target), WTFMove(srcByteOffset), dstData.releaseNonNull(), WTFMove(dstOffset), WTFMove(length));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBlitFramebufferCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBlitFramebuffer(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBlitFramebufferCaller>(state, "blitFramebuffer");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBlitFramebufferCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 10))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto srcX0 = convert<IDLLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto srcY0 = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto srcX1 = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto srcY1 = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto dstX0 = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto dstY0 = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto dstX1 = convert<IDLLong>(*state, state->uncheckedArgument(6), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto dstY1 = convert<IDLLong>(*state, state->uncheckedArgument(7), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto mask = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(8), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto filter = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(9), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.blitFramebuffer(WTFMove(srcX0), WTFMove(srcY0), WTFMove(srcX1), WTFMove(srcY1), WTFMove(dstX0), WTFMove(dstY0), WTFMove(dstX1), WTFMove(dstY1), WTFMove(mask), WTFMove(filter));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionFramebufferTextureLayerCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionFramebufferTextureLayer(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionFramebufferTextureLayerCaller>(state, "framebufferTextureLayer");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionFramebufferTextureLayerCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto attachment = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto texture = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto layer = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.framebufferTextureLayer(WTFMove(target), WTFMove(attachment), WTFMove(texture), WTFMove(level), WTFMove(layer));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetInternalformatParameterCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetInternalformatParameter(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetInternalformatParameterCaller>(state, "getInternalformatParameter");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetInternalformatParameterCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto internalformat = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getInternalformatParameter(WTFMove(target), WTFMove(internalformat), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionInvalidateFramebufferCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionInvalidateFramebuffer(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionInvalidateFramebufferCaller>(state, "invalidateFramebuffer");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionInvalidateFramebufferCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto attachments = convert<IDLSequence<IDLUnsignedLong>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.invalidateFramebuffer(WTFMove(target), WTFMove(attachments));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionInvalidateSubFramebufferCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionInvalidateSubFramebuffer(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionInvalidateSubFramebufferCaller>(state, "invalidateSubFramebuffer");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionInvalidateSubFramebufferCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto attachments = convert<IDLSequence<IDLUnsignedLong>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.invalidateSubFramebuffer(WTFMove(target), WTFMove(attachments), WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionReadBufferCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionReadBuffer(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionReadBufferCaller>(state, "readBuffer");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionReadBufferCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto src = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.readBuffer(WTFMove(src));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionRenderbufferStorageMultisampleCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionRenderbufferStorageMultisample(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionRenderbufferStorageMultisampleCaller>(state, "renderbufferStorageMultisample");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionRenderbufferStorageMultisampleCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto samples = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto internalformat = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.renderbufferStorageMultisample(WTFMove(target), WTFMove(samples), WTFMove(internalformat), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexStorage2DCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexStorage2D(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionTexStorage2DCaller>(state, "texStorage2D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexStorage2DCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto levels = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto internalformat = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.texStorage2D(WTFMove(target), WTFMove(levels), WTFMove(internalformat), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexStorage3DCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexStorage3D(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionTexStorage3DCaller>(state, "texStorage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexStorage3DCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto levels = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto internalformat = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto depth = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.texStorage3D(WTFMove(target), WTFMove(levels), WTFMove(internalformat), WTFMove(width), WTFMove(height), WTFMove(depth));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexImage3DCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexImage3D(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionTexImage3DCaller>(state, "texImage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexImage3DCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 10))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto internalformat = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto depth = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto border = convert<IDLLong>(*state, state->uncheckedArgument(6), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto format = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(7), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(8), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pixels = convert<IDLNullable<IDLInterface<ArrayBufferView>>>(*state, state->uncheckedArgument(9), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 9, "pixels", "WebGL2RenderingContext", "texImage3D", "ArrayBufferView"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.texImage3D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(width), WTFMove(height), WTFMove(depth), WTFMove(border), WTFMove(format), WTFMove(type), WTFMove(pixels));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D1Caller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D1(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D1Caller>(state, "texSubImage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D1Caller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 11))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto xoffset = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto yoffset = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto zoffset = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(6), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto depth = convert<IDLLong>(*state, state->uncheckedArgument(7), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto format = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(8), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(9), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pixels = convert<IDLNullable<IDLInterface<ArrayBufferView>>>(*state, state->uncheckedArgument(10), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 10, "pixels", "WebGL2RenderingContext", "texSubImage3D", "ArrayBufferView"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.texSubImage3D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(zoffset), WTFMove(width), WTFMove(height), WTFMove(depth), WTFMove(format), WTFMove(type), WTFMove(pixels));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D2Caller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

static inline EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D2(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D2Caller>(state, "texSubImage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D2Caller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 8))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto xoffset = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto yoffset = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto zoffset = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto format = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(6), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto source = convert<IDLUnion<IDLInterface<ImageData>, IDLInterface<HTMLImageElement>, IDLInterface<HTMLCanvasElement>, IDLInterface<HTMLVideoElement>>>(*state, state->uncheckedArgument(7));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.texSubImage3D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(zoffset), WTFMove(format), WTFMove(type), WTFMove(source));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D(ExecState* state)
{
    VM& vm = state->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    size_t argsCount = std::min<size_t>(11, state->argumentCount());
    if (argsCount == 11) {
        return jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D1(state);
    }
    if (argsCount == 8) {
        return jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D2(state);
    }
    return argsCount < 8 ? throwVMError(state, throwScope, createNotEnoughArgumentsError(state)) : throwVMTypeError(state, throwScope);
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCopyTexSubImage3DCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCopyTexSubImage3D(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionCopyTexSubImage3DCaller>(state, "copyTexSubImage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCopyTexSubImage3DCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 9))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto xoffset = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto yoffset = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto zoffset = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLLong>(*state, state->uncheckedArgument(6), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(7), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(8), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.copyTexSubImage3D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(zoffset), WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCompressedTexImage3DCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCompressedTexImage3D(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionCompressedTexImage3DCaller>(state, "compressedTexImage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCompressedTexImage3DCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 9))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto internalformat = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto depth = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto border = convert<IDLLong>(*state, state->uncheckedArgument(6), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto imageSize = convert<IDLLong>(*state, state->uncheckedArgument(7), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto data = convert<IDLNullable<IDLInterface<ArrayBufferView>>>(*state, state->uncheckedArgument(8), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 8, "data", "WebGL2RenderingContext", "compressedTexImage3D", "ArrayBufferView"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.compressedTexImage3D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(width), WTFMove(height), WTFMove(depth), WTFMove(border), WTFMove(imageSize), WTFMove(data));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCompressedTexSubImage3DCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCompressedTexSubImage3D(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionCompressedTexSubImage3DCaller>(state, "compressedTexSubImage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCompressedTexSubImage3DCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 11))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto level = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto xoffset = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto yoffset = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto zoffset = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto width = convert<IDLLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto height = convert<IDLLong>(*state, state->uncheckedArgument(6), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto depth = convert<IDLLong>(*state, state->uncheckedArgument(7), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto format = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(8), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto imageSize = convert<IDLLong>(*state, state->uncheckedArgument(9), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto data = convert<IDLNullable<IDLInterface<ArrayBufferView>>>(*state, state->uncheckedArgument(10), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 10, "data", "WebGL2RenderingContext", "compressedTexSubImage3D", "ArrayBufferView"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.compressedTexSubImage3D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(zoffset), WTFMove(width), WTFMove(height), WTFMove(depth), WTFMove(format), WTFMove(imageSize), WTFMove(data));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetFragDataLocationCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetFragDataLocation(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetFragDataLocationCaller>(state, "getFragDataLocation");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetFragDataLocationCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGL2RenderingContext", "getFragDataLocation", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto name = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLLong>(impl.getFragDataLocation(WTFMove(program), WTFMove(name))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform1uiCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform1ui(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniform1uiCaller>(state, "uniform1ui");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform1uiCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniform1ui", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v0 = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform1ui(WTFMove(location), WTFMove(v0));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform2uiCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform2ui(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniform2uiCaller>(state, "uniform2ui");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform2uiCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniform2ui", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v0 = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v1 = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform2ui(WTFMove(location), WTFMove(v0), WTFMove(v1));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform3uiCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform3ui(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniform3uiCaller>(state, "uniform3ui");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform3uiCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniform3ui", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v0 = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v1 = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v2 = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform3ui(WTFMove(location), WTFMove(v0), WTFMove(v1), WTFMove(v2));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform4uiCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform4ui(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniform4uiCaller>(state, "uniform4ui");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform4uiCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniform4ui", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v0 = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v1 = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v2 = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v3 = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform4ui(WTFMove(location), WTFMove(v0), WTFMove(v1), WTFMove(v2), WTFMove(v3));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform1uivCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform1uiv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniform1uivCaller>(state, "uniform1uiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform1uivCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniform1uiv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Uint32Array>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "value", "WebGL2RenderingContext", "uniform1uiv", "Uint32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform1uiv(WTFMove(location), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform2uivCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform2uiv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniform2uivCaller>(state, "uniform2uiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform2uivCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniform2uiv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Uint32Array>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "value", "WebGL2RenderingContext", "uniform2uiv", "Uint32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform2uiv(WTFMove(location), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform3uivCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform3uiv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniform3uivCaller>(state, "uniform3uiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform3uivCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniform3uiv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Uint32Array>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "value", "WebGL2RenderingContext", "uniform3uiv", "Uint32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform3uiv(WTFMove(location), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform4uivCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform4uiv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniform4uivCaller>(state, "uniform4uiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniform4uivCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniform4uiv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Uint32Array>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "value", "WebGL2RenderingContext", "uniform4uiv", "Uint32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniform4uiv(WTFMove(location), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x3fvCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x3fv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x3fvCaller>(state, "uniformMatrix2x3fv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x3fvCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniformMatrix2x3fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto transpose = convert<IDLBoolean>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Float32Array>>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "value", "WebGL2RenderingContext", "uniformMatrix2x3fv", "Float32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniformMatrix2x3fv(WTFMove(location), WTFMove(transpose), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x2fvCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x2fv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x2fvCaller>(state, "uniformMatrix3x2fv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x2fvCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniformMatrix3x2fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto transpose = convert<IDLBoolean>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Float32Array>>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "value", "WebGL2RenderingContext", "uniformMatrix3x2fv", "Float32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniformMatrix3x2fv(WTFMove(location), WTFMove(transpose), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x4fvCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x4fv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x4fvCaller>(state, "uniformMatrix2x4fv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x4fvCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniformMatrix2x4fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto transpose = convert<IDLBoolean>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Float32Array>>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "value", "WebGL2RenderingContext", "uniformMatrix2x4fv", "Float32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniformMatrix2x4fv(WTFMove(location), WTFMove(transpose), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x2fvCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x2fv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x2fvCaller>(state, "uniformMatrix4x2fv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x2fvCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniformMatrix4x2fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto transpose = convert<IDLBoolean>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Float32Array>>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "value", "WebGL2RenderingContext", "uniformMatrix4x2fv", "Float32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniformMatrix4x2fv(WTFMove(location), WTFMove(transpose), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x4fvCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x4fv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x4fvCaller>(state, "uniformMatrix3x4fv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x4fvCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniformMatrix3x4fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto transpose = convert<IDLBoolean>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Float32Array>>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "value", "WebGL2RenderingContext", "uniformMatrix3x4fv", "Float32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniformMatrix3x4fv(WTFMove(location), WTFMove(transpose), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x3fvCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x3fv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x3fvCaller>(state, "uniformMatrix4x3fv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x3fvCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto location = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "location", "WebGL2RenderingContext", "uniformMatrix4x3fv", "WebGLUniformLocation"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto transpose = convert<IDLBoolean>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Float32Array>>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "value", "WebGL2RenderingContext", "uniformMatrix4x3fv", "Float32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniformMatrix4x3fv(WTFMove(location), WTFMove(transpose), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4iCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4i(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4iCaller>(state, "vertexAttribI4i");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4iCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto z = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto w = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttribI4i(WTFMove(index), WTFMove(x), WTFMove(y), WTFMove(z), WTFMove(w));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4ivCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4iv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4ivCaller>(state, "vertexAttribI4iv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4ivCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v = convert<IDLNullable<IDLInterface<Int32Array>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "v", "WebGL2RenderingContext", "vertexAttribI4iv", "Int32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttribI4iv(WTFMove(index), WTFMove(v));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4uiCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4ui(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4uiCaller>(state, "vertexAttribI4ui");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4uiCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto x = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto y = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto z = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto w = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttribI4ui(WTFMove(index), WTFMove(x), WTFMove(y), WTFMove(z), WTFMove(w));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4uivCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4uiv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4uivCaller>(state, "vertexAttribI4uiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4uivCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto v = convert<IDLNullable<IDLInterface<Uint32Array>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "v", "WebGL2RenderingContext", "vertexAttribI4uiv", "Uint32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttribI4uiv(WTFMove(index), WTFMove(v));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionVertexAttribIPointerCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribIPointer(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionVertexAttribIPointerCaller>(state, "vertexAttribIPointer");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionVertexAttribIPointerCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto size = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto stride = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto offset = convert<IDLLongLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttribIPointer(WTFMove(index), WTFMove(size), WTFMove(type), WTFMove(stride), WTFMove(offset));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionVertexAttribDivisorCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribDivisor(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionVertexAttribDivisorCaller>(state, "vertexAttribDivisor");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionVertexAttribDivisorCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto divisor = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.vertexAttribDivisor(WTFMove(index), WTFMove(divisor));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDrawArraysInstancedCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawArraysInstanced(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionDrawArraysInstancedCaller>(state, "drawArraysInstanced");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDrawArraysInstancedCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto mode = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto first = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto count = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto instanceCount = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.drawArraysInstanced(WTFMove(mode), WTFMove(first), WTFMove(count), WTFMove(instanceCount));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDrawElementsInstancedCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawElementsInstanced(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionDrawElementsInstancedCaller>(state, "drawElementsInstanced");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDrawElementsInstancedCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto mode = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto count = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto offset = convert<IDLLongLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto instanceCount = convert<IDLLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.drawElementsInstanced(WTFMove(mode), WTFMove(count), WTFMove(type), WTFMove(offset), WTFMove(instanceCount));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDrawRangeElementsCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawRangeElements(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionDrawRangeElementsCaller>(state, "drawRangeElements");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDrawRangeElementsCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto mode = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto start = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto end = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto count = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto type = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto offset = convert<IDLLongLong>(*state, state->uncheckedArgument(5), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.drawRangeElements(WTFMove(mode), WTFMove(start), WTFMove(end), WTFMove(count), WTFMove(type), WTFMove(offset));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDrawBuffersCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawBuffers(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionDrawBuffersCaller>(state, "drawBuffers");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDrawBuffersCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto buffers = convert<IDLSequence<IDLUnsignedLong>>(*state, state->uncheckedArgument(0));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.drawBuffers(WTFMove(buffers));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionClearBufferivCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferiv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionClearBufferivCaller>(state, "clearBufferiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionClearBufferivCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto buffer = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto drawbuffer = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Int32Array>>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "value", "WebGL2RenderingContext", "clearBufferiv", "Int32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.clearBufferiv(WTFMove(buffer), WTFMove(drawbuffer), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionClearBufferuivCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferuiv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionClearBufferuivCaller>(state, "clearBufferuiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionClearBufferuivCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto buffer = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto drawbuffer = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Uint32Array>>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "value", "WebGL2RenderingContext", "clearBufferuiv", "Uint32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.clearBufferuiv(WTFMove(buffer), WTFMove(drawbuffer), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionClearBufferfvCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferfv(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionClearBufferfvCaller>(state, "clearBufferfv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionClearBufferfvCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto buffer = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto drawbuffer = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto value = convert<IDLNullable<IDLInterface<Float32Array>>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "value", "WebGL2RenderingContext", "clearBufferfv", "Float32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.clearBufferfv(WTFMove(buffer), WTFMove(drawbuffer), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionClearBufferfiCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferfi(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionClearBufferfiCaller>(state, "clearBufferfi");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionClearBufferfiCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto buffer = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto drawbuffer = convert<IDLLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto depth = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto stencil = convert<IDLLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.clearBufferfi(WTFMove(buffer), WTFMove(drawbuffer), WTFMove(depth), WTFMove(stencil));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCreateQueryCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateQuery(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionCreateQueryCaller>(state, "createQuery");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCreateQueryCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLInterface<WebGLQuery>>(*state, *castedThis->globalObject(), impl.createQuery()));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDeleteQueryCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteQuery(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionDeleteQueryCaller>(state, "deleteQuery");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDeleteQueryCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto query = convert<IDLNullable<IDLInterface<WebGLQuery>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "query", "WebGL2RenderingContext", "deleteQuery", "WebGLQuery"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.deleteQuery(WTFMove(query));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionIsQueryCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsQuery(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionIsQueryCaller>(state, "isQuery");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionIsQueryCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto query = convert<IDLNullable<IDLInterface<WebGLQuery>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "query", "WebGL2RenderingContext", "isQuery", "WebGLQuery"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.isQuery(WTFMove(query))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBeginQueryCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBeginQuery(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBeginQueryCaller>(state, "beginQuery");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBeginQueryCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto query = convert<IDLNullable<IDLInterface<WebGLQuery>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "query", "WebGL2RenderingContext", "beginQuery", "WebGLQuery"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.beginQuery(WTFMove(target), WTFMove(query));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionEndQueryCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionEndQuery(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionEndQueryCaller>(state, "endQuery");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionEndQueryCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.endQuery(WTFMove(target));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetQueryCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetQuery(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetQueryCaller>(state, "getQuery");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetQueryCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<WebGLQuery>>(*state, *castedThis->globalObject(), impl.getQuery(WTFMove(target), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetQueryParameterCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetQueryParameter(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetQueryParameterCaller>(state, "getQueryParameter");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetQueryParameterCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto query = convert<IDLNullable<IDLInterface<WebGLQuery>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "query", "WebGL2RenderingContext", "getQueryParameter", "WebGLQuery"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getQueryParameter(WTFMove(query), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCreateSamplerCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateSampler(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionCreateSamplerCaller>(state, "createSampler");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCreateSamplerCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLInterface<WebGLSampler>>(*state, *castedThis->globalObject(), impl.createSampler()));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDeleteSamplerCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteSampler(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionDeleteSamplerCaller>(state, "deleteSampler");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDeleteSamplerCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto sampler = convert<IDLNullable<IDLInterface<WebGLSampler>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "sampler", "WebGL2RenderingContext", "deleteSampler", "WebGLSampler"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.deleteSampler(WTFMove(sampler));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionIsSamplerCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsSampler(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionIsSamplerCaller>(state, "isSampler");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionIsSamplerCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto sampler = convert<IDLNullable<IDLInterface<WebGLSampler>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "sampler", "WebGL2RenderingContext", "isSampler", "WebGLSampler"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.isSampler(WTFMove(sampler))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBindSamplerCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindSampler(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBindSamplerCaller>(state, "bindSampler");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBindSamplerCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto unit = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto sampler = convert<IDLNullable<IDLInterface<WebGLSampler>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "sampler", "WebGL2RenderingContext", "bindSampler", "WebGLSampler"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bindSampler(WTFMove(unit), WTFMove(sampler));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionSamplerParameteriCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionSamplerParameteri(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionSamplerParameteriCaller>(state, "samplerParameteri");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionSamplerParameteriCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto sampler = convert<IDLNullable<IDLInterface<WebGLSampler>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "sampler", "WebGL2RenderingContext", "samplerParameteri", "WebGLSampler"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto param = convert<IDLLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.samplerParameteri(WTFMove(sampler), WTFMove(pname), WTFMove(param));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionSamplerParameterfCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionSamplerParameterf(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionSamplerParameterfCaller>(state, "samplerParameterf");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionSamplerParameterfCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto sampler = convert<IDLNullable<IDLInterface<WebGLSampler>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "sampler", "WebGL2RenderingContext", "samplerParameterf", "WebGLSampler"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto param = convert<IDLUnrestrictedFloat>(*state, state->uncheckedArgument(2));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.samplerParameterf(WTFMove(sampler), WTFMove(pname), WTFMove(param));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetSamplerParameterCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetSamplerParameter(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetSamplerParameterCaller>(state, "getSamplerParameter");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetSamplerParameterCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto sampler = convert<IDLNullable<IDLInterface<WebGLSampler>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "sampler", "WebGL2RenderingContext", "getSamplerParameter", "WebGLSampler"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getSamplerParameter(WTFMove(sampler), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionFenceSyncCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionFenceSync(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionFenceSyncCaller>(state, "fenceSync");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionFenceSyncCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto condition = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto flags = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<WebGLSync>>(*state, *castedThis->globalObject(), impl.fenceSync(WTFMove(condition), WTFMove(flags))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionIsSyncCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsSync(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionIsSyncCaller>(state, "isSync");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionIsSyncCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto sync = convert<IDLNullable<IDLInterface<WebGLSync>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "sync", "WebGL2RenderingContext", "isSync", "WebGLSync"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.isSync(WTFMove(sync))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDeleteSyncCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteSync(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionDeleteSyncCaller>(state, "deleteSync");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDeleteSyncCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto sync = convert<IDLNullable<IDLInterface<WebGLSync>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "sync", "WebGL2RenderingContext", "deleteSync", "WebGLSync"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.deleteSync(WTFMove(sync));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionClientWaitSyncCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClientWaitSync(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionClientWaitSyncCaller>(state, "clientWaitSync");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionClientWaitSyncCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto sync = convert<IDLNullable<IDLInterface<WebGLSync>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "sync", "WebGL2RenderingContext", "clientWaitSync", "WebGLSync"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto flags = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto timeout = convert<IDLUnsignedLongLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLUnsignedLong>(impl.clientWaitSync(WTFMove(sync), WTFMove(flags), WTFMove(timeout))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionWaitSyncCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionWaitSync(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionWaitSyncCaller>(state, "waitSync");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionWaitSyncCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto sync = convert<IDLNullable<IDLInterface<WebGLSync>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "sync", "WebGL2RenderingContext", "waitSync", "WebGLSync"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto flags = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto timeout = convert<IDLUnsignedLongLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.waitSync(WTFMove(sync), WTFMove(flags), WTFMove(timeout));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetSyncParameterCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetSyncParameter(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetSyncParameterCaller>(state, "getSyncParameter");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetSyncParameterCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto sync = convert<IDLNullable<IDLInterface<WebGLSync>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "sync", "WebGL2RenderingContext", "getSyncParameter", "WebGLSync"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getSyncParameter(WTFMove(sync), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCreateTransformFeedbackCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateTransformFeedback(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionCreateTransformFeedbackCaller>(state, "createTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCreateTransformFeedbackCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLInterface<WebGLTransformFeedback>>(*state, *castedThis->globalObject(), impl.createTransformFeedback()));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDeleteTransformFeedbackCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteTransformFeedback(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionDeleteTransformFeedbackCaller>(state, "deleteTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDeleteTransformFeedbackCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto id = convert<IDLNullable<IDLInterface<WebGLTransformFeedback>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "id", "WebGL2RenderingContext", "deleteTransformFeedback", "WebGLTransformFeedback"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.deleteTransformFeedback(WTFMove(id));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionIsTransformFeedbackCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsTransformFeedback(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionIsTransformFeedbackCaller>(state, "isTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionIsTransformFeedbackCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto id = convert<IDLNullable<IDLInterface<WebGLTransformFeedback>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "id", "WebGL2RenderingContext", "isTransformFeedback", "WebGLTransformFeedback"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.isTransformFeedback(WTFMove(id))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBindTransformFeedbackCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindTransformFeedback(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBindTransformFeedbackCaller>(state, "bindTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBindTransformFeedbackCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto id = convert<IDLNullable<IDLInterface<WebGLTransformFeedback>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "id", "WebGL2RenderingContext", "bindTransformFeedback", "WebGLTransformFeedback"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bindTransformFeedback(WTFMove(target), WTFMove(id));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBeginTransformFeedbackCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBeginTransformFeedback(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBeginTransformFeedbackCaller>(state, "beginTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBeginTransformFeedbackCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto primitiveMode = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.beginTransformFeedback(WTFMove(primitiveMode));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionEndTransformFeedbackCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionEndTransformFeedback(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionEndTransformFeedbackCaller>(state, "endTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionEndTransformFeedbackCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.endTransformFeedback();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTransformFeedbackVaryingsCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTransformFeedbackVaryings(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionTransformFeedbackVaryingsCaller>(state, "transformFeedbackVaryings");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTransformFeedbackVaryingsCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGL2RenderingContext", "transformFeedbackVaryings", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto varyings = convert<IDLSequence<IDLDOMString>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto bufferMode = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.transformFeedbackVaryings(WTFMove(program), WTFMove(varyings), WTFMove(bufferMode));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetTransformFeedbackVaryingCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetTransformFeedbackVarying(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetTransformFeedbackVaryingCaller>(state, "getTransformFeedbackVarying");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetTransformFeedbackVaryingCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGL2RenderingContext", "getTransformFeedbackVarying", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<WebGLActiveInfo>>(*state, *castedThis->globalObject(), impl.getTransformFeedbackVarying(WTFMove(program), WTFMove(index))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionPauseTransformFeedbackCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionPauseTransformFeedback(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionPauseTransformFeedbackCaller>(state, "pauseTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionPauseTransformFeedbackCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.pauseTransformFeedback();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionResumeTransformFeedbackCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionResumeTransformFeedback(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionResumeTransformFeedbackCaller>(state, "resumeTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionResumeTransformFeedbackCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    impl.resumeTransformFeedback();
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBindBufferBaseCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindBufferBase(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBindBufferBaseCaller>(state, "bindBufferBase");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBindBufferBaseCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto buffer = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "buffer", "WebGL2RenderingContext", "bindBufferBase", "WebGLBuffer"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bindBufferBase(WTFMove(target), WTFMove(index), WTFMove(buffer));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBindBufferRangeCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindBufferRange(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBindBufferRangeCaller>(state, "bindBufferRange");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBindBufferRangeCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto buffer = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*state, state->uncheckedArgument(2), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 2, "buffer", "WebGL2RenderingContext", "bindBufferRange", "WebGLBuffer"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto offset = convert<IDLLongLong>(*state, state->uncheckedArgument(3), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto size = convert<IDLLongLong>(*state, state->uncheckedArgument(4), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bindBufferRange(WTFMove(target), WTFMove(index), WTFMove(buffer), WTFMove(offset), WTFMove(size));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetIndexedParameterCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetIndexedParameter(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetIndexedParameterCaller>(state, "getIndexedParameter");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetIndexedParameterCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto target = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(0), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto index = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getIndexedParameter(WTFMove(target), WTFMove(index))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetUniformIndicesCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetUniformIndices(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetUniformIndicesCaller>(state, "getUniformIndices");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetUniformIndicesCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGL2RenderingContext", "getUniformIndices", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto uniformNames = convert<IDLSequence<IDLDOMString>>(*state, state->uncheckedArgument(1));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<Uint32Array>>(*state, *castedThis->globalObject(), impl.getUniformIndices(WTFMove(program), WTFMove(uniformNames))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformsCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetActiveUniforms(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformsCaller>(state, "getActiveUniforms");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformsCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGL2RenderingContext", "getActiveUniforms", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto uniformIndices = convert<IDLNullable<IDLInterface<Uint32Array>>>(*state, state->uncheckedArgument(1), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 1, "uniformIndices", "WebGL2RenderingContext", "getActiveUniforms", "Uint32Array"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLInterface<Int32Array>>(*state, *castedThis->globalObject(), impl.getActiveUniforms(WTFMove(program), WTFMove(uniformIndices), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetUniformBlockIndexCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetUniformBlockIndex(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetUniformBlockIndexCaller>(state, "getUniformBlockIndex");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetUniformBlockIndexCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGL2RenderingContext", "getUniformBlockIndex", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto uniformBlockName = convert<IDLDOMString>(*state, state->uncheckedArgument(1), StringConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLUnsignedLong>(impl.getUniformBlockIndex(WTFMove(program), WTFMove(uniformBlockName))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockParameterCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockParameter(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockParameterCaller>(state, "getActiveUniformBlockParameter");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockParameterCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGL2RenderingContext", "getActiveUniformBlockParameter", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto uniformBlockIndex = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto pname = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getActiveUniformBlockParameter(WTFMove(program), WTFMove(uniformBlockIndex), WTFMove(pname))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockNameCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockName(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockNameCaller>(state, "getActiveUniformBlockName");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockNameCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGL2RenderingContext", "getActiveUniformBlockName", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto uniformBlockIndex = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLWebGLAny>(*state, *castedThis->globalObject(), impl.getActiveUniformBlockName(WTFMove(program), WTFMove(uniformBlockIndex))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformBlockBindingCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformBlockBinding(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionUniformBlockBindingCaller>(state, "uniformBlockBinding");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionUniformBlockBindingCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto program = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "program", "WebGL2RenderingContext", "uniformBlockBinding", "WebGLProgram"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto uniformBlockIndex = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(1), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    auto uniformBlockBinding = convert<IDLUnsignedLong>(*state, state->uncheckedArgument(2), IntegerConversionConfiguration::Normal);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.uniformBlockBinding(WTFMove(program), WTFMove(uniformBlockIndex), WTFMove(uniformBlockBinding));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCreateVertexArrayCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateVertexArray(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionCreateVertexArrayCaller>(state, "createVertexArray");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionCreateVertexArrayCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    return JSValue::encode(toJS<IDLInterface<WebGLVertexArrayObject>>(*state, *castedThis->globalObject(), impl.createVertexArray()));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDeleteVertexArrayCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteVertexArray(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionDeleteVertexArrayCaller>(state, "deleteVertexArray");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionDeleteVertexArrayCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto vertexArray = convert<IDLNullable<IDLInterface<WebGLVertexArrayObject>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "vertexArray", "WebGL2RenderingContext", "deleteVertexArray", "WebGLVertexArrayObject"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.deleteVertexArray(WTFMove(vertexArray));
    return JSValue::encode(jsUndefined());
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionIsVertexArrayCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsVertexArray(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionIsVertexArrayCaller>(state, "isVertexArray");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionIsVertexArrayCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto vertexArray = convert<IDLNullable<IDLInterface<WebGLVertexArrayObject>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "vertexArray", "WebGL2RenderingContext", "isVertexArray", "WebGLVertexArrayObject"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    return JSValue::encode(toJS<IDLBoolean>(impl.isVertexArray(WTFMove(vertexArray))));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBindVertexArrayCaller(JSC::ExecState*, JSWebGL2RenderingContext*, JSC::ThrowScope&);

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindVertexArray(ExecState* state)
{
    return BindingCaller<JSWebGL2RenderingContext>::callOperation<jsWebGL2RenderingContextPrototypeFunctionBindVertexArrayCaller>(state, "bindVertexArray");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionBindVertexArrayCaller(JSC::ExecState* state, JSWebGL2RenderingContext* castedThis, JSC::ThrowScope& throwScope)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(throwScope);
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));
    auto vertexArray = convert<IDLNullable<IDLInterface<WebGLVertexArrayObject>>>(*state, state->uncheckedArgument(0), [](JSC::ExecState& state, JSC::ThrowScope& scope) { throwArgumentTypeError(state, scope, 0, "vertexArray", "WebGL2RenderingContext", "bindVertexArray", "WebGLVertexArrayObject"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    impl.bindVertexArray(WTFMove(vertexArray));
    return JSValue::encode(jsUndefined());
}

void JSWebGL2RenderingContext::visitChildren(JSCell* cell, SlotVisitor& visitor)
{
    auto* thisObject = jsCast<JSWebGL2RenderingContext*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    thisObject->visitAdditionalChildren(visitor);
}

void JSWebGL2RenderingContext::visitOutputConstraints(JSCell* cell, SlotVisitor& visitor)
{
    auto* thisObject = jsCast<JSWebGL2RenderingContext*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitOutputConstraints(thisObject, visitor);
    thisObject->visitAdditionalChildren(visitor);
}

#if ENABLE(BINDING_INTEGRITY)
#if PLATFORM(WIN)
#pragma warning(disable: 4483)
extern "C" { extern void (*const __identifier("??_7WebGL2RenderingContext@WebCore@@6B@")[])(); }
#else
extern "C" { extern void* _ZTVN7WebCore22WebGL2RenderingContextE[]; }
#endif
#endif

JSC::JSValue toJSNewlyCreated(JSC::ExecState*, JSDOMGlobalObject* globalObject, Ref<WebGL2RenderingContext>&& impl)
{

#if ENABLE(BINDING_INTEGRITY)
    void* actualVTablePointer = *(reinterpret_cast<void**>(impl.ptr()));
#if PLATFORM(WIN)
    void* expectedVTablePointer = reinterpret_cast<void*>(__identifier("??_7WebGL2RenderingContext@WebCore@@6B@"));
#else
    void* expectedVTablePointer = &_ZTVN7WebCore22WebGL2RenderingContextE[2];
#if COMPILER(CLANG)
    // If this fails WebGL2RenderingContext does not have a vtable, so you need to add the
    // ImplementationLacksVTable attribute to the interface definition
    static_assert(__is_polymorphic(WebGL2RenderingContext), "WebGL2RenderingContext is not polymorphic");
#endif
#endif
    // If you hit this assertion you either have a use after free bug, or
    // WebGL2RenderingContext has subclasses. If WebGL2RenderingContext has subclasses that get passed
    // to toJS() we currently require WebGL2RenderingContext you to opt out of binding hardening
    // by adding the SkipVTableValidation attribute to the interface IDL definition
    RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
#endif
    return createWrapper<WebGL2RenderingContext>(globalObject, WTFMove(impl));
}

JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, WebGL2RenderingContext& impl)
{
    return wrap(state, globalObject, impl);
}


}

#endif // ENABLE(WEBGL2)
